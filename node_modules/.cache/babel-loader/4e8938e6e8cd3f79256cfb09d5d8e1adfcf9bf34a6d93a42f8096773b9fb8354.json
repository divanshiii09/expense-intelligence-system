{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies\n */\nconst PopulateOptions = require('./options/populateOptions');\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => p?.options?.lean == null).forEach(makeLean(options.lean));\n  }\n  const session = query?.options?.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n  const projection = query._fieldsForExec();\n  for (let i = 0; i < pop.length; ++i) {\n    if (pop[i] instanceof PopulateOptions) {\n      pop[i] = new PopulateOptions({\n        ...pop[i],\n        _queryProjection: projection,\n        _localModel: query.model\n      });\n    } else {\n      pop[i]._queryProjection = projection;\n      pop[i]._localModel = query.model;\n    }\n  }\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping?.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      const _opts = {\n        strict: options?.strict\n      };\n      return new discriminator(undefined, _fields, _opts);\n    }\n  }\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  if (options != null && 'strict' in options) {\n    _opts.strict = options.strict;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = {};\n  if (populatedIds) {\n    initOpts.populated = populatedIds;\n  }\n  if (options?.middleware != null) {\n    initOpts.middleware = options.middleware;\n  }\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if (!type?.selected || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type?.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema?.paths['_id']?.options?.select === false) {\n        fields._id = 0;\n      }\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options?.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.embeddedSchemaType);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      if (sanitizeProjection) {\n        fields[path] = 0;\n      }\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {\n        fields[path] = 1;\n      } else if (exclude == null && sanitizeProjection && type.selected === false) {\n        fields[path] = 0;\n      }\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type?.options?.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    if (Array.isArray(val?.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n    option.options.lean = val;\n  };\n}","map":{"version":3,"names":["PopulateOptions","require","checkEmbeddedDiscriminatorKeyProjection","get","getDiscriminatorByValue","isDefiningProjection","clone","isPathSelectedInclusive","exports","preparePopulationOptionsMQ","query","options","_populate","_mongooseOptions","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","session","path","projection","_fieldsForExec","i","length","_queryProjection","_localModel","model","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","_opts","strict","undefined","skipId","isNew","willInit","defaults","createModelAndInit","populatedIds","callback","initOpts","populated","middleware","casted","$init","error","sanitizeProjection","exclude","minusPathsToSkip","Set","minusPaths","push","slice","keyIndex","field","discriminatorKey","type","selected","add","excluded","stack","analyzeSchema","fieldName","paths","select","_id","has","startsWith","prefix","indexOf","addedPaths","eachPath","$isSchemaMap","endsWith","plusPath","hasPlusPath","addedPath","analyzePath","Array","isArray","$isMongooseArray","$isMongooseDocumentArray","embeddedSchemaType","_addedPaths","pieces","split","cur","$skipDiscriminatorCheck","val","option","virtuals","assign","map"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/mongoose/lib/queryHelpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst PopulateOptions = require('./options/populateOptions');\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => p?.options?.lean == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query?.options?.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  for (let i = 0; i < pop.length; ++i) {\n    if (pop[i] instanceof PopulateOptions) {\n      pop[i] = new PopulateOptions({\n        ...pop[i],\n        _queryProjection: projection,\n        _localModel: query.model\n      });\n    } else {\n      pop[i]._queryProjection = projection;\n      pop[i]._localModel = query.model;\n    }\n  }\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping?.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      const _opts = { strict: options?.strict };\n      return new discriminator(undefined, _fields, _opts);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  if (options != null && 'strict' in options) {\n    _opts.strict = options.strict;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = {};\n  if (populatedIds) {\n    initOpts.populated = populatedIds;\n  }\n  if (options?.middleware != null) {\n    initOpts.middleware = options.middleware;\n  }\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if (!type?.selected || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type?.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema?.paths['_id']?.options?.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options?.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.embeddedSchemaType);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      if (sanitizeProjection) {\n        fields[path] = 0;\n      }\n\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {\n        fields[path] = 1;\n      } else if (exclude == null && sanitizeProjection && type.selected === false) {\n        fields[path] = 0;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type?.options?.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (Array.isArray(val?.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}