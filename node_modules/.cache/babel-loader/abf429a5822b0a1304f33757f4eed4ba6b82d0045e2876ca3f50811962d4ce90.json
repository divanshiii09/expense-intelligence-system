{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar createError = require('http-errors');\nvar debug = require('debug')('body-parser:urlencoded');\nvar read = require('../read');\nvar qs = require('qs');\nvar {\n  normalizeOptions\n} = require('../utils');\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded;\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {Object} [options]\n * @returns {Function}\n * @public\n */\nfunction urlencoded(options) {\n  const normalizedOptions = normalizeOptions(options, 'application/x-www-form-urlencoded');\n  if (normalizedOptions.defaultCharset !== 'utf-8' && normalizedOptions.defaultCharset !== 'iso-8859-1') {\n    throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1');\n  }\n\n  // create the appropriate query parser\n  var queryparse = createQueryParser(options);\n  function parse(body, encoding) {\n    return body.length ? queryparse(body, encoding) : {};\n  }\n  const readOptions = {\n    ...normalizedOptions,\n    // assert charset\n    isValidCharset: charset => charset === 'utf-8' || charset === 'iso-8859-1'\n  };\n  return function urlencodedParser(req, res, next) {\n    read(req, res, next, parse, debug, readOptions);\n  };\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {Object} options\n * @returns {Function}\n * @private\n */\nfunction createQueryParser(options) {\n  var extended = Boolean(options?.extended);\n  var parameterLimit = options?.parameterLimit !== undefined ? options?.parameterLimit : 1000;\n  var charsetSentinel = options?.charsetSentinel;\n  var interpretNumericEntities = options?.interpretNumericEntities;\n  var depth = extended ? options?.depth !== undefined ? options?.depth : 32 : 0;\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n  if (isNaN(depth) || depth < 0) {\n    throw new TypeError('option depth must be a zero or a positive number');\n  }\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n  return function queryparse(body, encoding) {\n    var paramCount = parameterCount(body, parameterLimit);\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n    var arrayLimit = extended ? Math.max(100, paramCount) : paramCount;\n    debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding');\n    try {\n      return qs.parse(body, {\n        allowPrototypes: true,\n        arrayLimit: arrayLimit,\n        depth: depth,\n        charsetSentinel: charsetSentinel,\n        interpretNumericEntities: interpretNumericEntities,\n        charset: encoding,\n        parameterLimit: parameterLimit,\n        strictDepth: true\n      });\n    } catch (err) {\n      if (err instanceof RangeError) {\n        throw createError(400, 'The input exceeded the depth', {\n          type: 'querystring.parse.rangeError'\n        });\n      } else {\n        throw err;\n      }\n    }\n  };\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @returns {number|undefined} Returns undefined if limit exceeded\n * @private\n */\nfunction parameterCount(body, limit) {\n  let count = 0;\n  let index = -1;\n  do {\n    count++;\n    if (count > limit) return undefined; // Early exit if limit exceeded\n    index = body.indexOf('&', index + 1);\n  } while (index !== -1);\n  return count;\n}","map":{"version":3,"names":["createError","require","debug","read","qs","normalizeOptions","module","exports","urlencoded","options","normalizedOptions","defaultCharset","TypeError","queryparse","createQueryParser","parse","body","encoding","length","readOptions","isValidCharset","charset","urlencodedParser","req","res","next","extended","Boolean","parameterLimit","undefined","charsetSentinel","interpretNumericEntities","depth","isNaN","isFinite","paramCount","parameterCount","type","arrayLimit","Math","max","allowPrototypes","strictDepth","err","RangeError","limit","count","index","indexOf"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/body-parser/lib/types/urlencoded.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar read = require('../read')\nvar qs = require('qs')\nvar { normalizeOptions } = require('../utils')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {Object} [options]\n * @returns {Function}\n * @public\n */\nfunction urlencoded (options) {\n  const normalizedOptions = normalizeOptions(options, 'application/x-www-form-urlencoded')\n\n  if (normalizedOptions.defaultCharset !== 'utf-8' && normalizedOptions.defaultCharset !== 'iso-8859-1') {\n    throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1')\n  }\n\n  // create the appropriate query parser\n  var queryparse = createQueryParser(options)\n\n  function parse (body, encoding) {\n    return body.length\n      ? queryparse(body, encoding)\n      : {}\n  }\n\n  const readOptions = {\n    ...normalizedOptions,\n    // assert charset\n    isValidCharset: (charset) => charset === 'utf-8' || charset === 'iso-8859-1'\n  }\n\n  return function urlencodedParser (req, res, next) {\n    read(req, res, next, parse, debug, readOptions)\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {Object} options\n * @returns {Function}\n * @private\n */\nfunction createQueryParser (options) {\n  var extended = Boolean(options?.extended)\n  var parameterLimit = options?.parameterLimit !== undefined\n    ? options?.parameterLimit\n    : 1000\n  var charsetSentinel = options?.charsetSentinel\n  var interpretNumericEntities = options?.interpretNumericEntities\n  var depth = extended ? (options?.depth !== undefined ? options?.depth : 32) : 0\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isNaN(depth) || depth < 0) {\n    throw new TypeError('option depth must be a zero or a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body, encoding) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    var arrayLimit = extended ? Math.max(100, paramCount) : paramCount\n\n    debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding')\n    try {\n      return qs.parse(body, {\n        allowPrototypes: true,\n        arrayLimit: arrayLimit,\n        depth: depth,\n        charsetSentinel: charsetSentinel,\n        interpretNumericEntities: interpretNumericEntities,\n        charset: encoding,\n        parameterLimit: parameterLimit,\n        strictDepth: true\n      })\n    } catch (err) {\n      if (err instanceof RangeError) {\n        throw createError(400, 'The input exceeded the depth', {\n          type: 'querystring.parse.rangeError'\n        })\n      } else {\n        throw err\n      }\n    }\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @returns {number|undefined} Returns undefined if limit exceeded\n * @private\n */\nfunction parameterCount (body, limit) {\n  let count = 0\n  let index = -1\n  do {\n    count++\n    if (count > limit) return undefined // Early exit if limit exceeded\n    index = body.indexOf('&', index + 1)\n  } while (index !== -1)\n  return count\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}