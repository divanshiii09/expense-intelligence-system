{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies.\n */\nvar bytes = require('bytes');\nvar contentType = require('content-type');\nvar typeis = require('type-is');\n\n/**\n * Module exports.\n */\nmodule.exports = {\n  getCharset,\n  normalizeOptions,\n  passthrough\n};\n\n/**\n * Get the charset of a request.\n *\n * @param {Object} req\n * @returns {string | undefined}\n * @private\n */\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string | string[]} type\n * @returns {Function}\n * @private\n */\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}\n\n/**\n * Normalizes the common options for all parsers.\n *\n * @param {Object} options options to normalize\n * @param {string | string[] | Function} defaultType default content type(s) or a function to determine it\n * @returns {Object}\n * @private\n */\nfunction normalizeOptions(options, defaultType) {\n  if (!defaultType) {\n    // Parsers must define a default content type\n    throw new TypeError('defaultType must be provided');\n  }\n  var inflate = options?.inflate !== false;\n  var limit = typeof options?.limit !== 'number' ? bytes.parse(options?.limit || '100kb') : options?.limit;\n  var type = options?.type || defaultType;\n  var verify = options?.verify || false;\n  var defaultCharset = options?.defaultCharset || 'utf-8';\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  return {\n    inflate,\n    limit,\n    verify,\n    defaultCharset,\n    shouldParse\n  };\n}\n\n/**\n * Passthrough function that returns input unchanged.\n * Used by parsers that don't need to transform the data.\n *\n * @param {*} value\n * @returns {*}\n * @private\n */\nfunction passthrough(value) {\n  return value;\n}","map":{"version":3,"names":["bytes","require","contentType","typeis","module","exports","getCharset","normalizeOptions","passthrough","req","parse","parameters","charset","toLowerCase","undefined","typeChecker","type","checkType","Boolean","options","defaultType","TypeError","inflate","limit","verify","defaultCharset","shouldParse","value"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/body-parser/lib/utils.js"],"sourcesContent":["'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\nmodule.exports = {\n  getCharset,\n  normalizeOptions,\n  passthrough\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {Object} req\n * @returns {string | undefined}\n * @private\n */\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string | string[]} type\n * @returns {Function}\n * @private\n */\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n\n/**\n * Normalizes the common options for all parsers.\n *\n * @param {Object} options options to normalize\n * @param {string | string[] | Function} defaultType default content type(s) or a function to determine it\n * @returns {Object}\n * @private\n */\nfunction normalizeOptions (options, defaultType) {\n  if (!defaultType) {\n    // Parsers must define a default content type\n    throw new TypeError('defaultType must be provided')\n  }\n\n  var inflate = options?.inflate !== false\n  var limit = typeof options?.limit !== 'number'\n    ? bytes.parse(options?.limit || '100kb')\n    : options?.limit\n  var type = options?.type || defaultType\n  var verify = options?.verify || false\n  var defaultCharset = options?.defaultCharset || 'utf-8'\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  return {\n    inflate,\n    limit,\n    verify,\n    defaultCharset,\n    shouldParse\n  }\n}\n\n/**\n * Passthrough function that returns input unchanged.\n * Used by parsers that don't need to transform the data.\n *\n * @param {*} value\n * @returns {*}\n * @private\n */\nfunction passthrough (value) {\n  return value\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,WAAW,GAAGD,OAAO,CAAC,cAAc,CAAC;AACzC,IAAIE,MAAM,GAAGF,OAAO,CAAC,SAAS,CAAC;;AAE/B;AACA;AACA;AACAG,MAAM,CAACC,OAAO,GAAG;EACfC,UAAU;EACVC,gBAAgB;EAChBC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,UAAUA,CAAEG,GAAG,EAAE;EACxB,IAAI;IACF,OAAO,CAACP,WAAW,CAACQ,KAAK,CAACD,GAAG,CAAC,CAACE,UAAU,CAACC,OAAO,IAAI,EAAE,EAAEC,WAAW,CAAC,CAAC;EACxE,CAAC,CAAC,MAAM;IACN,OAAOC,SAAS;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAAEC,IAAI,EAAE;EAC1B,OAAO,SAASC,SAASA,CAAER,GAAG,EAAE;IAC9B,OAAOS,OAAO,CAACf,MAAM,CAACM,GAAG,EAAEO,IAAI,CAAC,CAAC;EACnC,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAST,gBAAgBA,CAAEY,OAAO,EAAEC,WAAW,EAAE;EAC/C,IAAI,CAACA,WAAW,EAAE;IAChB;IACA,MAAM,IAAIC,SAAS,CAAC,8BAA8B,CAAC;EACrD;EAEA,IAAIC,OAAO,GAAGH,OAAO,EAAEG,OAAO,KAAK,KAAK;EACxC,IAAIC,KAAK,GAAG,OAAOJ,OAAO,EAAEI,KAAK,KAAK,QAAQ,GAC1CvB,KAAK,CAACU,KAAK,CAACS,OAAO,EAAEI,KAAK,IAAI,OAAO,CAAC,GACtCJ,OAAO,EAAEI,KAAK;EAClB,IAAIP,IAAI,GAAGG,OAAO,EAAEH,IAAI,IAAII,WAAW;EACvC,IAAII,MAAM,GAAGL,OAAO,EAAEK,MAAM,IAAI,KAAK;EACrC,IAAIC,cAAc,GAAGN,OAAO,EAAEM,cAAc,IAAI,OAAO;EAEvD,IAAID,MAAM,KAAK,KAAK,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;IACpD,MAAM,IAAIH,SAAS,CAAC,gCAAgC,CAAC;EACvD;;EAEA;EACA,IAAIK,WAAW,GAAG,OAAOV,IAAI,KAAK,UAAU,GACxCD,WAAW,CAACC,IAAI,CAAC,GACjBA,IAAI;EAER,OAAO;IACLM,OAAO;IACPC,KAAK;IACLC,MAAM;IACNC,cAAc;IACdC;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASlB,WAAWA,CAAEmB,KAAK,EAAE;EAC3B,OAAOA,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}