{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst Aggregate = require('./aggregate');\nconst ChangeStream = require('./cursor/changeStream');\nconst Document = require('./document');\nconst DocumentNotFoundError = require('./error/notFound');\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseBulkWriteError = require('./error/bulkWriteError');\nconst MongooseError = require('./error/index');\nconst ObjectParameterError = require('./error/objectParameter');\nconst OverwriteModelError = require('./error/overwriteModel');\nconst Query = require('./query');\nconst SaveOptions = require('./options/saveOptions');\nconst Schema = require('./schema');\nconst ValidationError = require('./error/validation');\nconst VersionError = require('./error/version');\nconst ParallelSaveError = require('./error/parallelSave');\nconst applyDefaultsHelper = require('./helpers/document/applyDefaults');\nconst isInPathsToSave = require('./helpers/document/isInPathsToSave');\nconst applyDefaultsToPOJO = require('./helpers/model/applyDefaultsToPOJO');\nconst applyEmbeddedDiscriminators = require('./helpers/discriminator/applyEmbeddedDiscriminators');\nconst applyHooks = require('./helpers/model/applyHooks');\nconst applyMethods = require('./helpers/model/applyMethods');\nconst applyProjection = require('./helpers/projection/applyProjection');\nconst applyReadConcern = require('./helpers/schema/applyReadConcern');\nconst applySchemaCollation = require('./helpers/indexes/applySchemaCollation');\nconst applyStaticHooks = require('./helpers/model/applyStaticHooks');\nconst applyStatics = require('./helpers/model/applyStatics');\nconst applyTimestampsHelper = require('./helpers/document/applyTimestamps');\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst applyVirtualsHelper = require('./helpers/document/applyVirtuals');\nconst assignVals = require('./helpers/populate/assignVals');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst clone = require('./helpers/clone');\nconst createPopulateQueryFilter = require('./helpers/populate/createPopulateQueryFilter');\nconst decorateUpdateWithVersionKey = require('./helpers/update/decorateUpdateWithVersionKey');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst discriminator = require('./helpers/model/discriminator');\nconst each = require('./helpers/each');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst getModelsMapForPopulate = require('./helpers/populate/getModelsMapForPopulate');\nconst immediate = require('./helpers/immediate');\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst isDefaultIdIndex = require('./helpers/indexes/isDefaultIdIndex');\nconst isIndexEqual = require('./helpers/indexes/isIndexEqual');\nconst isIndexSpecEqual = require('./helpers/indexes/isIndexSpecEqual');\nconst isTimeseriesIndex = require('./helpers/indexes/isTimeseriesIndex');\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = require('./helpers/indexes/getRelatedIndexes');\nconst decorateDiscriminatorIndexOptions = require('./helpers/indexes/decorateDiscriminatorIndexOptions');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\nconst leanPopulateMap = require('./helpers/populate/leanPopulateMap');\nconst parallelLimit = require('./helpers/parallelLimit');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst pushNestedArrayPaths = require('./helpers/model/pushNestedArrayPaths');\nconst removeDeselectedForeignField = require('./helpers/populate/removeDeselectedForeignField');\nconst setDottedPath = require('./helpers/path/setDottedPath');\nconst {\n  buildMiddlewareFilter\n} = require('./helpers/buildMiddlewareFilter');\nconst util = require('util');\nconst utils = require('./utils');\nconst minimize = require('./helpers/minimize');\nconst MongooseBulkSaveIncompleteError = require('./error/bulkSaveIncompleteError');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst {\n  arrayAtomicsBackupSymbol,\n  arrayAtomicsSymbol,\n  modelSymbol\n} = require('./helpers/symbols');\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\nconst {\n  VERSION_INC,\n  VERSION_WHERE,\n  VERSION_ALL\n} = Document;\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Object} [options] optional object containing the options for the document.\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @param {Boolean} [options.skipId=false] By default, Mongoose document if one is not provided and the document's schema does not override Mongoose's default `_id`. Set `skipId` to `true` to skip this generation step.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, options) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` constructor must be a POJO or string, ' + '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' + '`mongoose.Model()`.');\n  }\n  if (typeof doc === 'string') {\n    throw new TypeError('First argument to `Model` constructor must be an object, ' + '**not** a string. Make sure you\\'re calling `mongoose.model()`, not ' + '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, options);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * Changes the Connection instance this model uses to make requests to MongoDB.\n * This function is most useful for changing the Connection that a Model defined using `mongoose.model()` uses\n * after initialization.\n *\n * #### Example:\n *\n *     await mongoose.connect('mongodb://127.0.0.1:27017/db1');\n *     const UserModel = mongoose.model('User', mongoose.Schema({ name: String }));\n *     UserModel.connection === mongoose.connection; // true\n *\n *     const conn2 = await mongoose.createConnection('mongodb://127.0.0.1:27017/db2').asPromise();\n *     UserModel.useConnection(conn2); // `UserModel` now stores documents in `db2`, not `db1`\n *\n *     UserModel.connection === mongoose.connection; // false\n *     UserModel.connection === conn2; // true\n *\n *     conn2.model('User') === UserModel; // true\n *     mongoose.model('User'); // Throws 'MissingSchemaError'\n *\n * Note: `useConnection()` does **not** apply any [connection-level plugins](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.plugin()) from the new connection.\n * If you use `useConnection()` to switch a model's connection, the model will still have the old connection's plugins.\n *\n * @function useConnection\n * @param [Connection] connection The new connection to use\n * @return [Model] this\n * @api public\n */\n\nModel.useConnection = function useConnection(connection) {\n  if (!connection) {\n    throw new Error('Please provide a connection.');\n  }\n  if (this.db) {\n    delete this.db.models[this.modelName];\n    delete this.prototype.db;\n    delete this.prototype[modelDbSymbol];\n    delete this.prototype.collection;\n    delete this.prototype.$collection;\n    delete this.prototype[modelCollectionSymbol];\n  }\n  this.db = connection;\n  const collection = connection.collection(this.collection.collectionName, connection.options);\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n  this.prototype.db = connection;\n  this.prototype[modelDbSymbol] = connection;\n  this.collection = collection;\n  this.$__collection = collection;\n  connection.models[this.modelName] = this;\n  return this;\n};\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\nfunction _createSaveOptions(doc, options) {\n  const saveOptions = {};\n  applyWriteConcern(doc.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n  const session = doc.$session();\n  const asyncLocalStorage = doc[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();\n  if (session != null) {\n    saveOptions.session = session;\n  } else if (!Object.hasOwn(options, 'session') && asyncLocalStorage?.session != null) {\n    // Only set session from asyncLocalStorage if `session` option wasn't originally passed in options\n    saveOptions.session = asyncLocalStorage.session;\n  }\n  return saveOptions;\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = async function $__save(options) {\n  try {\n    await this._execDocumentPreHooks('save', options, [options]);\n  } catch (error) {\n    await this._execDocumentPostHooks('save', options, error);\n    return;\n  }\n  let result = null;\n  let where = null;\n  try {\n    const saveOptions = _createSaveOptions(this, options);\n    if (this.$isNew) {\n      // send entire doc\n      const obj = this.toObject(saveToObjectOptions);\n      if ((obj || {})._id === void 0) {\n        // documents must have an _id else mongoose won't know\n        // what to update later if more changes are made. the user\n        // wouldn't know what _id was generated by mongodb either\n        // nor would the ObjectId generated by mongodb necessarily\n        // match the schema definition.\n        throw new MongooseError('document must have an _id before saving');\n      }\n      this.$__version(true, obj);\n      this.$__reset();\n      _setIsNew(this, false);\n      // Make it possible to retry the insert\n      this.$__.inserting = true;\n      result = await this[modelCollectionSymbol].insertOne(obj, saveOptions).catch(err => {\n        _setIsNew(this, true);\n        throw err;\n      });\n    } else {\n      // Make sure we don't treat it as a new object on error,\n      // since it already exists\n      this.$__.inserting = false;\n      const pathsToSave = Array.isArray(options.pathsToSave) ? options.pathsToSave : null;\n      const pathsToSaveSet = pathsToSave != null ? new Set(pathsToSave) : null;\n      const delta = this.$__delta(pathsToSave, pathsToSaveSet);\n      const unsavedDirty = pathsToSave != null ? delta != null ? delta[2] : this.$__dirty() : null;\n      const unsavedDefaultPaths = pathsToSave != null ? Object.keys(this.$__.activePaths.getStatePaths('default')).filter(path => !isInPathsToSave(path, pathsToSaveSet, pathsToSave)) : null;\n      if (delta) {\n        where = this.$__where(delta[0]);\n        _applyCustomWhere(this, where);\n        const update = delta[1];\n        if (this.$__schema.options.minimize) {\n          for (const updateOp of Object.values(update)) {\n            if (updateOp == null) {\n              continue;\n            }\n            for (const key of Object.keys(updateOp)) {\n              if (updateOp[key] == null || typeof updateOp[key] !== 'object') {\n                continue;\n              }\n              if (!utils.isPOJO(updateOp[key])) {\n                continue;\n              }\n              minimize(updateOp[key]);\n              if (utils.hasOwnKeys(updateOp[key]) === false) {\n                delete updateOp[key];\n                update.$unset = update.$unset || {};\n                update.$unset[key] = 1;\n              }\n            }\n          }\n        }\n\n        // store the modified paths before the document is reset\n        this.$__.modifiedPaths = this.modifiedPaths();\n        this.$__reset();\n        restoreUnsavedState(this, unsavedDirty, unsavedDefaultPaths);\n        _setIsNew(this, false);\n        result = await this[modelCollectionSymbol].updateOne(where, update, saveOptions).catch(err => {\n          this.$__undoReset();\n          throw err;\n        });\n      } else {\n        where = this.$__where();\n        _applyCustomWhere(this, where);\n        if (this.$__.version) {\n          this.$__version(where, delta);\n        }\n        applyReadConcern(this.$__schema, saveOptions);\n        result = await this.constructor.collection.findOne(where, {\n          ...saveOptions,\n          projection: {\n            _id: 1\n          }\n        }).then(documentExists => ({\n          matchedCount: !documentExists ? 0 : 1\n        }));\n      }\n    }\n  } catch (err) {\n    const error = this.$__schema._transformDuplicateKeyError(err);\n    await this._execDocumentPostHooks('save', options, error);\n    return;\n  }\n  let numAffected = 0;\n  const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;\n  if (writeConcern !== 0) {\n    // Skip checking if write succeeded if writeConcern is set to\n    // unacknowledged writes, because otherwise `numAffected` will always be 0\n    if (result != null) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.matchedCount != null) {\n        numAffected = result.matchedCount;\n      } else {\n        numAffected = result;\n      }\n    }\n    const versionBump = this.$__.version;\n    // was this an update that required a version bump?\n    if (versionBump && !this.$__.inserting) {\n      const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n      this.$__.version = undefined;\n      const key = this.$__schema.options.versionKey;\n      const version = this.$__getValue(key) || 0;\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        this.$__undoReset();\n        const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);\n        await this._execDocumentPostHooks('save', options, err);\n        return;\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        this.$__setValue(key, version + 1);\n      }\n    }\n    if (result != null && numAffected <= 0) {\n      this.$__undoReset();\n      const error = new DocumentNotFoundError(where, this.constructor.modelName, numAffected, result);\n      await this._execDocumentPostHooks('save', options, error);\n      return;\n    }\n  }\n  this.$__.saving = undefined;\n  this.$__.savedState = {};\n  this.$emit('save', this, numAffected);\n  this.constructor.emit('save', this, numAffected);\n  await this._execDocumentPostHooks('save', options);\n};\n\n/*!\n * Restores $__.activePaths state and any atomics for paths that failed\n * to save.\n *\n * @param {Document} doc\n * @param {object[]} unsavedDirty\n * @param {string[]} unsavedDefaultPaths\n */\n\nfunction restoreUnsavedState(doc, unsavedDirty, unsavedDefaultPaths) {\n  if (unsavedDirty == null) {\n    return;\n  }\n  for (const dirty of unsavedDirty) {\n    doc.$__.activePaths.modify(dirty.path);\n    if (dirty.value?.[arrayAtomicsBackupSymbol]) {\n      dirty.value[arrayAtomicsSymbol] = dirty.value[arrayAtomicsBackupSymbol];\n      dirty.value[arrayAtomicsBackupSymbol] = null;\n    }\n  }\n  for (const path of unsavedDefaultPaths) {\n    doc.$__.activePaths.default(path);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths, defaultPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths.concat(defaultPaths));\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Array} [options.pathsToSave] An array of paths that tell mongoose to only validate and save the paths in `pathsToSave`.\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n  let parallelSave;\n  this.$op = 'save';\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n  options = new SaveOptions(options);\n  if (Object.hasOwn(options, 'session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths(), Object.keys(this.$__.activePaths.getStatePaths('default')));\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n  this.$__.saveOptions = options;\n  try {\n    await this.$__save(options);\n  } catch (error) {\n    this.$__handleReject(error);\n    throw error;\n  } finally {\n    this.$__.saving = null;\n    this.$__.saveOptions = null;\n    this.$__.$versionError = null;\n    this.$op = null;\n  }\n  return this;\n};\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function (where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n};\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n  if (this._doc._id === void 0) {\n    throw new MongooseError('No _id found on document!');\n  }\n  return where;\n};\n\n/**\n * Delete this document from the db. Returns a Query instance containing a `deleteOne` operation by this document's `_id`.\n *\n * #### Example:\n *\n *     await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * Since `deleteOne()` returns a Query, the `deleteOne()` will **not** execute unless you use either `await`, `.then()`, `.catch()`, or [`.exec()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.exec())\n *\n * #### Example:\n *\n *     product.deleteOne(); // Doesn't do anything\n *     product.deleteOne().exec(); // Deletes the document, returns a promise\n *\n * @return {Query} Query\n * @api public\n */\n\nModel.prototype.deleteOne = function deleteOne(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n  if (!options) {\n    options = {};\n  }\n  if (Object.hasOwn(options, 'session')) {\n    this.$session(options.session);\n  }\n  const self = this;\n  const where = this.$__where();\n  const query = self.constructor.deleteOne();\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n  query.pre(async function queryPreDeleteOne() {\n    const res = await self.constructor._middleware.execPre('deleteOne', self, [self, options], {\n      filter: preFilter\n    });\n    // `self` is passed to pre hooks as argument for backwards compatibility, but that\n    // isn't the actual arguments passed to the wrapped function.\n    if (res[0] !== self || res[1] !== options) {\n      throw new Error('Document deleteOne pre hooks cannot overwrite arguments');\n    }\n    query.deleteOne(where, options);\n    // Apply custom where conditions _after_ document deleteOne middleware for\n    // consistency with save() - sharding plugin needs to set $where\n    if (self.$where != null) {\n      this.where(self.$where);\n    }\n    return res;\n  });\n  query.pre(function callSubdocPreHooks() {\n    return Promise.all(self.$getAllSubdocs().map(subdoc => subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], {\n      filter: preFilter\n    })));\n  });\n  query.pre(function skipIfAlreadyDeleted() {\n    if (self.$__.isDeleted) {\n      throw new Kareem.skipWrappedFunction();\n    }\n  });\n  query.post(function callSubdocPostHooks() {\n    return Promise.all(self.$getAllSubdocs().map(subdoc => subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], {\n      filter: postFilter\n    })));\n  });\n  query.post(function queryPostDeleteOne() {\n    return self.constructor._middleware.execPost('deleteOne', self, [self], {\n      filter: postFilter\n    });\n  });\n  query.transform(function setIsDeleted(result) {\n    if (result?.deletedCount > 0) {\n      self.$isDeleted(true);\n    }\n    return result;\n  });\n  return query;\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n  const query = this.findOne(filter).select({\n    _id: 1\n  }).lean().setOptions(options);\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function (name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n  const overwriteModels = typeof options.overwriteModels === 'boolean' ? options.overwriteModels : false;\n  _checkContext(this, 'discriminator');\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks, overwriteModels);\n  if (this.db.models[name] && !schema.options.overwriteModels && !overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' + 'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' + 'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' + 'model as `this`. Make sure you are not calling ' + '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for initializing the underlying connection in MongoDB based on schema options.\n * This function performs the following operations:\n *\n * - `createCollection()` unless [`autoCreate`](https://mongoosejs.com/docs/guide.html#autoCreate) option is turned off\n * - `ensureIndexes()` unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) option is turned off\n * - `createSearchIndex()` on all schema search indexes if `autoSearchIndex` is enabled.\n *\n * Mongoose calls this function automatically when a model is a created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n  this.schema.emit('init', this);\n  if (this.$init != null) {\n    return this.$init;\n  }\n  const conn = this.db;\n  const _ensureIndexes = async () => {\n    const autoIndex = utils.getOption('autoIndex', this.schema.options, conn.config, conn.base.options);\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({\n      _automatic: true\n    });\n  };\n  const _createSearchIndexes = async () => {\n    const autoSearchIndex = utils.getOption('autoSearchIndex', this.schema.options, conn.config, conn.base.options);\n    if (!autoSearchIndex) {\n      return;\n    }\n    return await this.createSearchIndexes();\n  };\n  const _createCollection = async () => {\n    let autoCreate = utils.getOption('autoCreate', this.schema.options, conn.config\n    // No base.options here because we don't want to take the base value if the connection hasn't\n    // set it yet\n    );\n    if (autoCreate == null) {\n      // `autoCreate` may later be set when the connection is opened, so wait for connect before checking\n      await conn._waitForConnect(true);\n      autoCreate = utils.getOption('autoCreate', this.schema.options, conn.config, conn.base.options);\n    }\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n  this.$init = _createCollection().then(() => _ensureIndexes()).then(() => _createSearchIndexes());\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function () {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n  return this.$init;\n};\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n\n  // Remove middleware option before passing to MongoDB\n  if (options?.middleware != null) {\n    options = {\n      ...options\n    };\n    delete options.middleware;\n  }\n  [options] = await this.hooks.execPre('createCollection', this, [options], {\n    filter: preFilter\n  }).catch(err => {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      return [err];\n    }\n    throw err;\n  });\n  const collectionOptions = this?.schema?.options?.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n  const schemaCollation = this?.schema?.options?.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({\n      collation: schemaCollation\n    }, options);\n  }\n  const capped = this?.schema?.options?.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({\n        capped: true,\n        size: capped\n      }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({\n        capped: true\n      }, capped, options);\n    }\n  }\n  const timeseries = this?.schema?.options?.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({\n      timeseries\n    }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n  const clusteredIndex = this?.schema?.options?.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({\n      clusteredIndex: {\n        ...clusteredIndex,\n        unique: true\n      }\n    }, options);\n  }\n  try {\n    if (!(options instanceof Kareem.skipWrappedFunction)) {\n      await this.db.createCollection(this.$__collection.collectionName, options);\n    }\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      await this.hooks.execPost('createCollection', this, [null], {\n        error: err,\n        filter: postFilter\n      });\n    }\n  }\n  await this.hooks.execPost('createCollection', this, [this.$__collection], {\n    filter: postFilter\n  });\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.hideIndexes=false] set to `true` to hide indexes instead of dropping. Requires MongoDB server 4.4 or higher\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n  const autoCreate = options?.autoCreate ?? this.schema.options?.autoCreate ?? this.db.config.autoCreate ?? this.db.base?.options?.autoCreate ?? true;\n  if (autoCreate) {\n    try {\n      await this.createCollection();\n    } catch (err) {\n      if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n        throw err;\n      }\n    }\n  }\n  const diffIndexesResult = await this.diffIndexes({\n    indexOptionsToCreate: true\n  });\n  const dropped = await this.cleanIndexes({\n    ...options,\n    toDrop: diffIndexesResult.toDrop\n  });\n  await this.createIndexes({\n    ...options,\n    toCreate: diffIndexesResult.toCreate\n  });\n  return dropped;\n};\n\n/**\n * Create an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Promise}\n * @api public\n */\n\nModel.createSearchIndex = async function createSearchIndex(description) {\n  _checkContext(this, 'createSearchIndex');\n  return await this.$__collection.createSearchIndex(description);\n};\n\n/**\n * Update an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.updateSearchIndex('test', { mappings: { dynamic: true } });\n *\n * @param {String} name\n * @param {Object} definition\n * @return {Promise}\n * @api public\n */\n\nModel.updateSearchIndex = async function updateSearchIndex(name, definition) {\n  _checkContext(this, 'updateSearchIndex');\n  return await this.$__collection.updateSearchIndex(name, definition);\n};\n\n/**\n * Delete an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) by name.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.dropSearchIndex('test');\n *\n * @param {String} name\n * @return {Promise}\n * @api public\n */\n\nModel.dropSearchIndex = async function dropSearchIndex(name) {\n  _checkContext(this, 'dropSearchIndex');\n  return await this.$__collection.dropSearchIndex(name);\n};\n\n/**\n * List all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) on this model's collection.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *     const res = await Customer.listSearchIndexes(); // Includes `[{ name: 'test' }]`\n *\n * @param {Object} [options]\n * @return {Promise<Array>}\n * @api public\n */\n\nModel.listSearchIndexes = async function listSearchIndexes(options) {\n  _checkContext(this, 'listSearchIndexes');\n  const cursor = await this.$__collection.listSearchIndexes(options);\n  return await cursor.toArray();\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of index specs containing the keys of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @param {Boolean} [options.indexOptionsToCreate=false] If true, `toCreate` will include both the index spec and the index options, not just the index spec\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes(options) {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n  const model = this;\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options);\n  return {\n    toDrop,\n    toCreate\n  };\n};\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options) {\n  const toCreate = [];\n  const indexOptionsToCreate = options?.indexOptionsToCreate ?? false;\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (isIndexEqual(schemaIndexKeysObject, options, index) && !toDrop.includes(index.name)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      if (indexOptionsToCreate) {\n        toCreate.push([schemaIndexKeysObject, schemaIndexOptions]);\n      } else {\n        toCreate.push(schemaIndexKeysObject);\n      }\n    }\n  }\n  return toCreate;\n}\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n    // Timeseries collections have a default index on { timeField: 1, metaField: 1 }.\n    if (isTimeseriesIndex(dbIndex, schema.options)) {\n      continue;\n    }\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n    if (found) {\n      continue;\n    }\n    toDrop.push(dbIndex.name);\n  }\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Object} [options]\n * @param {Array<String>} [options.toDrop] if specified, contains a list of index names to drop\n * @param {Boolean} [options.hideIndexes=false] set to `true` to hide indexes instead of dropping. Requires MongoDB server 4.4 or higher\n * @return {Promise<Array<String>>} list of dropped or hidden index names\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n  if (Array.isArray(options?.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, model, options);\n    return res;\n  }\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, model, options);\n};\nasync function _dropIndexes(toDrop, model, options) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n  const collection = model.$__collection;\n  if (options?.hideIndexes) {\n    await Promise.all(toDrop.map(indexName => {\n      return model.db.db.command({\n        collMod: collection.collectionName,\n        index: {\n          name: indexName,\n          hidden: true\n        }\n      });\n    }));\n  } else {\n    await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  }\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     await Event.ensureIndexes();\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     });\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, err => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n  return this.ensureIndexes(options);\n};\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = Array.isArray(options?.toCreate) ? options.toCreate : model.schema.indexes();\n  let indexError;\n  options = options || {};\n  const done = function (err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' + 'model name \"' + model.modelName + '\", ' + 'MongoDB does not allow overwriting the default `_id` index. See ' + 'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  // Check for duplicate index definitions (gh-15056)\n  const seenIndexes = [];\n  for (const index of indexes) {\n    const fields = index[0];\n    const indexOptions = index[1];\n    if (indexOptions.name == null) {\n      for (const existingIndex of seenIndexes) {\n        if (existingIndex[1].name == null && isIndexSpecEqual(existingIndex[0], fields)) {\n          utils.warn('mongoose: Duplicate schema index on ' + JSON.stringify(fields) + ' for model \"' + model.modelName + '\". ' + 'This is often due to declaring an index using both \"index: true\" and \"schema.index()\". ' + 'Please remove the duplicate index definition.');\n          break;\n        }\n      }\n    }\n    seenIndexes.push(index);\n  }\n  if (!indexes.length) {\n    immediate(function () {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one\n\n  const indexSingleDone = function (err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function (fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n  immediate(function () {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {\n        return done();\n      }\n    }\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n    indexSingleStart(indexFields, options);\n\n    // Just in case `createIndex()` throws a sync error\n    let promise = null;\n    try {\n      promise = model.collection.createIndex(indexFields, indexOptions);\n    } catch (err) {\n      if (!indexError) {\n        indexError = err;\n      }\n      if (!model.$caught) {\n        model.emit('error', err);\n      }\n      indexSingleDone(err, indexFields, indexOptions);\n      create();\n      return;\n    }\n    promise.then(name => {\n      indexSingleDone(null, indexFields, indexOptions, name);\n      create();\n    }, err => {\n      if (!indexError) {\n        indexError = err;\n      }\n      if (!model.$caught) {\n        model.emit('error', err);\n      }\n      indexSingleDone(err, indexFields, indexOptions);\n      create();\n    });\n  }\n}\n\n/**\n * Creates all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) defined in this model's schema.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: String,\n *       description: String\n *     });\n *     schema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *     const Product = mongoose.model('Product', schema);\n *\n *     // Creates the search index defined in the schema\n *     await Product.createSearchIndexes();\n *\n * @api public\n * @return {Promise} resolves to the results of creating the search indexes\n */\n\nModel.createSearchIndexes = async function createSearchIndexes() {\n  _checkContext(this, 'createSearchIndexes');\n  const results = [];\n  for (const searchIndex of this.schema._searchIndexes) {\n    results.push(await this.createSearchIndex(searchIndex));\n  }\n  return results;\n};\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema?.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema?.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      } else currentSchema = null;\n    }\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map) fields.set(translatedKey, value);else fields[translatedKey] = value;\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is equivalent to `findOne({ _id: id })`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n  return this.findOne({\n    _id: id\n  }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     const count = await Adventure.countDocuments({ type: 'jungle' });\n *     console.log('there are %d jungle adventures', count);\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n  return mq.countDocuments(conditions);\n};\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @param {Object} [options] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions, options) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`. A Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(filter, update, options);  // returns Query\n *     A.findOneAndUpdate(filter, update);           // returns Query\n *     A.findOneAndUpdate(filter);                   // returns Query\n *     A.findOneAndUpdate();                         // returns Query\n *\n *     // Other supported syntaxes\n *     // Note that calling `Query#findOneAndUpdate()` with 1 arg will treat the arg as `update`, NOT `filter`\n *     A.find(filter).findOneAndUpdate(update);\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options);\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options);\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {'before'|'after'} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function (conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {'before'|'after'} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function (id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._doc._id;\n  }\n  return this.findOneAndUpdate.call(this, {\n    _id: id\n  }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function (conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndDelete https://mongoosejs.com/docs/api/model.html#Model.findOneAndDelete()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function (id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n  return this.findOneAndDelete({\n    _id: id\n  }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {'before'|'after'} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function (filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n  _checkContext(this, 'create');\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' || typeof options === 'function' || typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n    if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && last && getConstructorName(last.session) === 'ClientSession' && !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' + 'Mongoose, you **must** pass an array as the first argument. See: ' + 'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.session && !options.ordered && args.length > 1) {\n    throw new MongooseError('Cannot call `create()` with a session and multiple documents unless `ordered: true` is set');\n  }\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` + `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else if (!immediateError) {\n    res = await Promise.allSettled(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` + `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n      await toSave.$save(options);\n      return toSave;\n    }));\n    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);\n  } else {\n    let firstError = null;\n    res = await Promise.all(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` + `found for model \"${this.modelName}\"`);\n      }\n      try {\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n        await toSave.$save(options);\n        return toSave;\n      } catch (err) {\n        if (!firstError) {\n          firstError = err;\n        }\n      }\n    }));\n    if (firstError) {\n      throw firstError;\n    }\n  }\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n  return res;\n};\n\n/**\n * Shortcut for saving one document to the database.\n * `MyModel.insertOne(obj, options)` is almost equivalent to `new MyModel(obj).save(options)`.\n * The difference is that `insertOne()` checks if `obj` is already a document, and checks for discriminators.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     const character = await Character.insertOne({ name: 'Jean-Luc Picard' });\n *     character.name; // 'Jean-Luc Picard'\n *\n *     // Create a new character within a transaction.\n *     await Character.insertOne({ name: 'Jean-Luc Picard' }, { session });\n *\n * @param {Object|Document} doc Document to insert, as a POJO or Mongoose document\n * @param {Object} [options] Options passed down to `save()`.\n * @return {Promise<Document>} resolves to the saved document\n * @api public\n */\n\nModel.insertOne = async function insertOne(doc, options) {\n  _checkContext(this, 'insertOne');\n  const discriminatorKey = this.schema.options.discriminatorKey;\n  const Model = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;\n  if (Model == null) {\n    throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not found for model \"${this.modelName}\"`);\n  }\n  if (!(doc instanceof Model)) {\n    doc = new Model(doc);\n  }\n  return await doc.$save(options);\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.deleteOne();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function (pipeline, options) {\n  _checkContext(this, 'watch');\n  options = options || {};\n  const watchOptions = options?.hydrate !== undefined ? utils.omit(options, ['hydrate']) : {\n    ...options\n  };\n  options.model = this;\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, watchOptions);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, watchOptions);\n      cb(null, driverChangeStream);\n    }\n  };\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.deleteOne();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function () {\n  _checkContext(this, 'startSession');\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     const docs = await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *     docs[0].name; // 'Star Wars'\n *\n *     // Return raw result from MongoDB\n *     const result = await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ], { rawResult: true });\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating the documents. This means Mongoose will **not** cast, validate, or apply defaults to any of the documents passed to `insertMany()`. This option is useful if you need the extra performance, but comes with data integrity risk. Consider using with [`castObject()`](https://mongoosejs.com/docs/api/model.html#Model.castObject()) and [`applyDefaults()`](https://mongoosejs.com/docs/api/model.html#Model.applyDefaults()).\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n  options = options || {};\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n  try {\n    [arr] = await this._middleware.execPre('insertMany', this, [arr], {\n      filter: preFilter\n    });\n  } catch (error) {\n    await this._middleware.execPost('insertMany', this, [arr], {\n      error,\n      filter: postFilter\n    });\n  }\n  const ThisModel = this;\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !Object.hasOwn(options, 'session')) && asyncLocalStorage?.session != null) {\n    options = {\n      ...options,\n      session: asyncLocalStorage.session\n    };\n  }\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  async function validateDoc(doc, index) {\n    // If option `lean` is set to true bypass validation and hydration\n    if (lean) {\n      return doc;\n    }\n    let createdNewDoc = false;\n    if (!(doc instanceof ThisModel)) {\n      if (doc != null && typeof doc !== 'object') {\n        throw new ObjectParameterError(doc, 'arr.' + index, 'insertMany');\n      }\n      doc = new ThisModel(doc);\n      createdNewDoc = true;\n    }\n    if (options.session != null) {\n      doc.$session(options.session);\n    }\n    return doc.$validate(createdNewDoc ? {\n      _skipParallelValidateCheck: true\n    } : null).then(() => doc).catch(error => {\n      if (ordered === false) {\n        error.index = index;\n        validationErrors.push(error);\n        validationErrorsToOriginalOrder.set(error, index);\n        results[index] = error;\n        return;\n      }\n      throw error;\n    });\n  }\n  const docs = await parallelLimit(arr, validateDoc, limit);\n  const originalDocIndex = new Map();\n  const validDocIndexToOriginalIndex = new Map();\n  for (let i = 0; i < docs.length; ++i) {\n    originalDocIndex.set(docs[i], i);\n  }\n\n  // We filter all failed pre-validations by removing nulls\n  const docAttributes = docs.filter(function (doc) {\n    return doc != null;\n  });\n  for (let i = 0; i < docAttributes.length; ++i) {\n    validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n  }\n\n  // Make sure validation errors are in the same order as the\n  // original documents, so if both doc1 and doc2 both fail validation,\n  // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n  // error before doc2's. Re: gh-12791.\n  if (validationErrors.length > 0) {\n    validationErrors.sort((err1, err2) => {\n      return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n    });\n  }\n\n  // Quickly escape while there aren't any valid docAttributes\n  if (docAttributes.length === 0) {\n    if (throwOnValidationError) {\n      throw new MongooseBulkWriteError(validationErrors, results, null, 'insertMany');\n    }\n    if (rawResult) {\n      const res = {\n        acknowledged: true,\n        insertedCount: 0,\n        insertedIds: {}\n      };\n      decorateBulkWriteResult(res, validationErrors, validationErrors);\n      return res;\n    }\n    return [];\n  }\n  const docObjects = lean ? docAttributes : docAttributes.map(function (doc) {\n    if (doc.$__schema.options.versionKey) {\n      doc[doc.$__schema.options.versionKey] = 0;\n    }\n    const shouldSetTimestamps = options?.timestamps !== false && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n    if (shouldSetTimestamps) {\n      doc.initializeTimestamps(options?.timestamps);\n    }\n    if (doc.$__hasOnlyPrimitiveValues()) {\n      return doc.$__toObjectShallow();\n    }\n    return doc.toObject(internalToObjectOptions);\n  });\n  let res;\n  try {\n    res = await this.$__collection.insertMany(docObjects, options);\n  } catch (error) {\n    // `writeErrors` is a property reported by the MongoDB driver,\n    // just not if there's only 1 error.\n    if (error.writeErrors == null && error.result?.result?.writeErrors != null) {\n      error.writeErrors = error.result.result.writeErrors;\n    }\n\n    // `insertedDocs` is a Mongoose-specific property\n    const hasWriteErrors = error?.writeErrors;\n    const erroredIndexes = new Set((error?.writeErrors || []).map(err => err.index));\n    if (error.writeErrors != null) {\n      for (let i = 0; i < error.writeErrors.length; ++i) {\n        const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n        error.writeErrors[i] = {\n          ...error.writeErrors[i],\n          index: originalIndex\n        };\n        if (!ordered) {\n          results[originalIndex] = error.writeErrors[i];\n        }\n      }\n    }\n    if (!ordered) {\n      for (let i = 0; i < results.length; ++i) {\n        if (results[i] === void 0) {\n          results[i] = docs[i];\n        }\n      }\n      error.results = results;\n    }\n    let firstErroredIndex = -1;\n    error.insertedDocs = docAttributes.filter((doc, i) => {\n      const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n      if (ordered) {\n        if (firstErroredIndex > -1) {\n          return i < firstErroredIndex;\n        }\n        if (isErrored) {\n          firstErroredIndex = i;\n        }\n      }\n      return !isErrored;\n    }).map(function setIsNewForInsertedDoc(doc) {\n      if (lean) {\n        return doc;\n      }\n      doc.$__reset();\n      _setIsNew(doc, false);\n      return doc;\n    });\n    if (rawResult && ordered === false) {\n      decorateBulkWriteResult(error, validationErrors, results);\n    }\n    await this._middleware.execPost('insertMany', this, [arr], {\n      error,\n      filter: postFilter\n    });\n  }\n  if (!lean) {\n    for (const attribute of docAttributes) {\n      attribute.$__reset();\n      _setIsNew(attribute, false);\n    }\n  }\n  if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n    for (let i = 0; i < results.length; ++i) {\n      if (results[i] === void 0) {\n        results[i] = docs[i];\n      }\n    }\n    throw new MongooseBulkWriteError(validationErrors, results, res, 'insertMany');\n  }\n  if (rawResult) {\n    if (ordered === false) {\n      for (let i = 0; i < results.length; ++i) {\n        if (results[i] === void 0) {\n          results[i] = docs[i];\n        }\n      }\n\n      // Decorate with mongoose validation errors in case of unordered,\n      // because then still do `insertMany()`\n      decorateBulkWriteResult(res, validationErrors, results);\n    }\n    return res;\n  }\n  if (options.populate != null) {\n    return this.populate(docAttributes, options.populate).catch(err => {\n      if (err != null) {\n        err.insertedDocs = docAttributes;\n      }\n      throw err;\n    });\n  }\n  const [result] = await this._middleware.execPost('insertMany', this, [docAttributes], {\n    filter: postFilter\n  });\n  return result;\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n  const subdocs = doc.$getAllSubdocs({\n    useCache: true\n  });\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n * The only exception is [setting the `update` operator for `updateOne` or `updateMany` to a pipeline](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#updateone-and-updatemany): Mongoose does **not** cast update pipelines.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n *     // Mongoose does **not** cast update pipelines, so no casting for the `update` option below.\n *     // Mongoose does still cast `filter`\n *     await Character.bulkWrite([{\n *       updateOne: {\n *         filter: { name: 'Annika Hansen' },\n *         update: [{ $set: { name: 7 } }] // Array means update pipeline, so Mongoose skips casting\n *       }\n *     }]);\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.insertOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Boolean} [ops.updateOne.overwriteImmutable=false] Mongoose removes updated immutable properties from `update` by default (excluding $setOnInsert). Set `overwriteImmutable` to `true` to allow updating immutable properties using other update operators.\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Boolean} [ops.updateMany.overwriteImmutable=false] Mongoose removes updated immutable properties from `update` by default (excluding $setOnInsert). Set `overwriteImmutable` to `true` to allow updating immutable properties using other update operators.\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [ops.replaceOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {Boolean} [options.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to any operations. Can be overridden at the operation-level.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully. Note that Mongoose will still send all valid operations to the MongoDB server.\n * @param {Boolean|\"throw\"} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n  try {\n    [ops, options] = await this.hooks.execPre('bulkWrite', this, [ops, options], {\n      filter: preFilter\n    });\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      ops = err;\n    } else {\n      await this.hooks.execPost('bulkWrite', this, [null], {\n        error: err,\n        filter: postFilter\n      });\n    }\n  }\n  if (ops instanceof Kareem.skipWrappedFunction) {\n    return ops.args[0];\n  }\n  const ordered = options.ordered == null ? true : options.ordered;\n  if (ops.length === 0) {\n    const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n    const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n    bulkWriteResult.n = 0;\n    decorateBulkWriteResult(bulkWriteResult, [], []);\n    return bulkWriteResult;\n  }\n  const validations = options?._skipCastBulkWrite ? [] : ops.map(op => castBulkWrite(this, op, options));\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !Object.hasOwn(options, 'session')) && asyncLocalStorage?.session != null) {\n    options = {\n      ...options,\n      session: asyncLocalStorage.session\n    };\n  }\n  let res = null;\n  if (ordered) {\n    await new Promise((resolve, reject) => {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n        resolve();\n      });\n    });\n    try {\n      res = await this.$__collection.bulkWrite(ops, options);\n    } catch (error) {\n      await this.hooks.execPost('bulkWrite', this, [null], {\n        error,\n        filter: postFilter\n      });\n    }\n  } else {\n    let validOpIndexes = [];\n    let validationErrors = [];\n    const results = [];\n    if (validations.length > 0) {\n      validOpIndexes = await Promise.all(ops.map((op, i) => {\n        if (i >= validations.length) {\n          return i;\n        }\n        return new Promise(resolve => {\n          validations[i](err => {\n            if (err == null) {\n              resolve(i);\n            } else {\n              validationErrors.push({\n                index: i,\n                error: err\n              });\n              results[i] = err;\n            }\n            resolve();\n          });\n        });\n      }));\n      validOpIndexes = validOpIndexes.filter(index => index != null);\n    } else {\n      validOpIndexes = ops.map((op, i) => i);\n    }\n    validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map(v => v.error);\n    const validOps = validOpIndexes.sort().map(index => ops[index]);\n    if (validOps.length === 0) {\n      if (options.throwOnValidationError && validationErrors.length) {\n        throw new MongooseBulkWriteError(validationErrors, results, res, 'bulkWrite');\n      }\n      const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n      const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n      bulkWriteResult.result = getDefaultBulkwriteResult();\n      decorateBulkWriteResult(bulkWriteResult, validationErrors, results);\n      return bulkWriteResult;\n    }\n    let error;\n    [res, error] = await this.$__collection.bulkWrite(validOps, options).then(res => [res, null]).catch(error => [null, error]);\n    const writeErrorsByIndex = {};\n    if (error?.writeErrors) {\n      for (const writeError of error.writeErrors) {\n        writeErrorsByIndex[writeError.err.index] = writeError;\n      }\n    }\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = writeErrorsByIndex[i] ?? null;\n    }\n    if (error) {\n      if (validationErrors.length > 0) {\n        decorateBulkWriteResult(error, validationErrors, results);\n      }\n      await this.hooks.execPost('bulkWrite', this, [null], {\n        error,\n        filter: postFilter\n      });\n    }\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(validationErrors, results, res, 'bulkWrite');\n      } else {\n        decorateBulkWriteResult(res, validationErrors, results);\n      }\n    }\n  }\n  await this.hooks.execPost('bulkWrite', this, [res], {\n    filter: postFilter\n  });\n  return res;\n};\n\n/**\n * Takes an array of documents, gets the changes and inserts/updates documents in the database\n * according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * `bulkSave()` throws errors under the following conditions:\n *\n * - one of the provided documents fails validation. In this case, `bulkSave()` does not send a `bulkWrite()`, and throws the first validation error.\n * - `bulkWrite()` fails (for example, due to being unable to connect to MongoDB or due to duplicate key error)\n * - `bulkWrite()` did not insert or update **any** documents. In this case, `bulkSave()` will throw a DocumentNotFound error.\n *\n * Note that `bulkSave()` will **not** throw an error if only some of the `save()` calls succeeded.\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.validateBeforeSave=true] set to `false` to skip Mongoose validation on all documents\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @return {BulkWriteResult} the return value from `bulkWrite()`\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n  await Promise.all(documents.map(doc => buildPreSavePromise(doc, options)));\n  const writeOperations = this.buildBulkWriteOperations(documents, options);\n  const opts = {\n    skipValidation: true,\n    _skipCastBulkWrite: true,\n    ...options\n  };\n  const {\n    bulkWriteResult,\n    bulkWriteError\n  } = await this.bulkWrite(writeOperations, opts).then(res => ({\n    bulkWriteResult: res,\n    bulkWriteError: null\n  }), err => ({\n    bulkWriteResult: null,\n    bulkWriteError: err\n  }));\n  // If not a MongoBulkWriteError, treat this as all documents failed to save.\n  if (bulkWriteError != null && bulkWriteError.name !== 'MongoBulkWriteError') {\n    throw bulkWriteError;\n  }\n  const matchedCount = bulkWriteResult?.matchedCount ?? 0;\n  const insertedCount = bulkWriteResult?.insertedCount ?? 0;\n  if (writeOperations.length > 0 && matchedCount + insertedCount < writeOperations.length && !bulkWriteError) {\n    throw new MongooseBulkSaveIncompleteError(this.modelName, documents, bulkWriteResult);\n  }\n  const successfulDocuments = [];\n  for (let i = 0; i < documents.length; i++) {\n    const document = documents[i];\n    const documentError = bulkWriteError?.writeErrors.find(writeError => {\n      const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n      return writeErrorDocumentId.toString() === document._doc._id.toString();\n    });\n    if (documentError == null) {\n      successfulDocuments.push(document);\n    }\n  }\n  await Promise.all(successfulDocuments.map(document => handleSuccessfulWrite(document, options)));\n  if (bulkWriteError != null) {\n    throw bulkWriteError;\n  }\n  return bulkWriteResult;\n};\nasync function buildPreSavePromise(document, options) {\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const [newOptions] = await document.schema.s.hooks.execPre('save', document, [options], {\n    filter: preFilter\n  });\n  if (newOptions !== options) {\n    throw new Error('Cannot overwrite options in pre(\"save\") hook on bulkSave()');\n  }\n}\nasync function handleSuccessfulWrite(document, options) {\n  if (document.$isNew) {\n    _setIsNew(document, false);\n  }\n  document.$__reset();\n  document._applyVersionIncrement();\n  const postFilter = buildMiddlewareFilter(options, 'post');\n  return document.schema.s.hooks.execPost('save', document, [document], {\n    filter: postFilter\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc == null) {\n    return doc;\n  }\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n    return doc;\n  }\n  applyDefaultsToPOJO(doc, this.schema);\n  return doc;\n};\n\n/**\n * Apply this model's virtuals to a given POJO. Virtuals execute with the POJO as the context `this`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     userSchema.virtual('upper').get(function() { return this.name.toUpperCase(); });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const obj = { name: 'John' };\n *     User.applyVirtuals(obj);\n *     obj.name; // 'John'\n *     obj.upper; // 'JOHN', Mongoose applied the return value of the virtual to the given object\n *\n * @param {Object} obj object or document to apply virtuals on\n * @param {Array<string>} [virtualsToApply] optional whitelist of virtuals to apply\n * @returns {Object} obj\n * @api public\n */\n\nModel.applyVirtuals = function applyVirtuals(obj, virtualsToApply) {\n  if (obj == null) {\n    return obj;\n  }\n  // Nothing to do if this is already a hydrated document - it should already have virtuals\n  if (obj.$__ != null) {\n    return obj;\n  }\n  applyVirtualsHelper(this.schema, obj, virtualsToApply);\n  return obj;\n};\n\n/**\n * Apply this model's timestamps to a given POJO, including subdocument timestamps\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String }, { timestamps: true });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const obj = { name: 'John' };\n *     User.applyTimestamps(obj);\n *     obj.createdAt; // 2024-06-01T18:00:00.000Z\n *     obj.updatedAt; // 2024-06-01T18:00:00.000Z\n *\n * @param {Object} obj object or document to apply virtuals on\n * @param {Object} [options]\n * @param {Boolean} [options.isUpdate=false] if true, treat this as an update: just set updatedAt, skip setting createdAt. If false, set both createdAt and updatedAt\n * @param {Function} [options.currentTime] if set, Mongoose will call this function to get the current time.\n * @returns {Object} obj\n * @api public\n */\n\nModel.applyTimestamps = function applyTimestamps(obj, options) {\n  if (obj == null) {\n    return obj;\n  }\n  // Nothing to do if this is already a hydrated document - it should already have timestamps\n  if (obj.$__ != null) {\n    return obj;\n  }\n  applyTimestampsHelper(this.schema, obj, options);\n  return obj;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(schema.paths);\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType?.$isMongooseArray) {\n      continue;\n    }\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n  let error = null;\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n    let val = get(obj, path, void 0);\n    if (val == null) {\n      continue;\n    }\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n    if (schemaType.$isMongooseDocumentArray) {\n      const castNonArraysOption = schemaType.options?.castNonArrays ?? schemaType.constructor.options.castNonArrays;\n      if (!Array.isArray(val)) {\n        if (!castNonArraysOption) {\n          if (!options.ignoreCastErrors) {\n            error = error || new ValidationError();\n            error.addError(path, new ObjectExpectedError(path, val));\n          }\n        } else {\n          cur[pieces[pieces.length - 1]] = [Model.castObject.call(schemaType.Constructor, val)];\n        }\n        continue;\n      }\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.Constructor, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n      continue;\n    }\n  }\n  if (error != null) {\n    throw error;\n  }\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n  setDefaultOptions();\n  const writeOperations = documents.map((document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      if (options.validateBeforeSave == null || options.validateBeforeSave) {\n        const err = document.validateSync();\n        if (err != null) {\n          throw err;\n        }\n      }\n    }\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = {\n        insertOne: {\n          document\n        }\n      };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      return writeOperation;\n    }\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n      _applyCustomWhere(document, where);\n\n      // If shard key is set, add shard keys to _filter_ condition to right shard is targeted\n      const shardKey = this.schema.options.shardKey;\n      if (shardKey) {\n        const paths = Object.keys(shardKey);\n        const len = paths.length;\n        for (let i = 0; i < len; ++i) {\n          where[paths[i]] = document[paths[i]];\n        }\n      }\n      document.$__version(where, delta);\n      const writeOperation = {\n        updateOne: {\n          filter: where,\n          update: changes\n        }\n      };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      return writeOperation;\n    }\n    return null;\n  }).filter(op => op !== null);\n  return writeOperations;\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @param {Boolean} [options.hydratedPopulatedDocs=false] if true, populates the docs if passing pre-populated data\n * @param {Boolean} [options.virtuals=false] if true, sets any virtuals present on `obj`\n * @param {Boolean|'throw'} [options.strict=false] configure strict mode for the hydrated document. In particular, if strict is false, fields not in the schema won't be stripped out; if strict is 'throw', `hydrate()` will throw an error if there are any fields that are not in the schema. Defaults to true (silently strip out fields not in the schema).\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function (obj, projection, options) {\n  _checkContext(this, 'hydrate');\n  if (options?.virtuals && options?.hydratedPopulatedDocs === false) {\n    throw new MongooseError('Cannot set `hydratedPopulatedDocs` option to false if `virtuals` option is truthy because `virtuals: true` also sets populated virtuals');\n  }\n  if (projection != null) {\n    if (obj?.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n  const document = require('./queryHelpers').createModel(this, obj, projection, projection, options);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation. This may be false if Mongoose did not send an update to the server because the update was empty.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n *     // Other supported syntaxes\n *     await Person.find({ name: /Stark$/ }).updateMany({ isDeleted: true }); // Using chaining syntax\n *     await Person.find().updateMany({ isDeleted: true }); // Set `isDeleted` on _all_ Person documents\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, update, options) {\n  _checkContext(this, 'updateMany');\n  if (update == null) {\n    throw new MongooseError('updateMany `update` parameter cannot be nullish');\n  }\n  return _update(this, 'updateMany', conditions, update, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation. This may be false if Mongoose did not send an update to the server because the update was empty.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n *     // Other supported syntaxes\n *     await Person.findOne({ name: 'Jean-Luc Picard' }).updateOne({ ship: 'USS Enterprise' }); // Using chaining syntax\n *     await Person.updateOne({ ship: 'USS Enterprise' }); // Updates first doc's `ship` property\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n  const versionKey = this?.schema?.options?.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n  const versionKey = model?.schema?.options?.versionKey ?? null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * The `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise<Object>} casted and validated copy of `obj` if validation succeeded\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === 'function') {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n      return _pathsToValidate.has(p);\n    });\n  }\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType?.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n  let error = null;\n  paths = new Set(paths);\n  try {\n    obj = this.castObject(obj);\n  } catch (err) {\n    error = err;\n    for (const key of Object.keys(error.errors || {})) {\n      paths.delete(key);\n    }\n  }\n  const promises = [];\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = obj;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      cur = cur[pieces[i]];\n    }\n    const val = get(obj, path, void 0);\n    promises.push(schemaType.doValidate(val, context, {\n      path: path\n    }).catch(err => {\n      error = error || new ValidationError();\n      error.addError(path, err);\n    }));\n  }\n  await Promise.all(promises);\n  if (error != null) {\n    throw error;\n  }\n  return obj;\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n * - forceRepopulate: optional boolean, defaults to `true`. Set to `false` to prevent Mongoose from repopulating paths that are already populated\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Boolean} [options.forceRepopulate=true] Set to `false` to prevent Mongoose from repopulating paths that are already populated\n * @param {Boolean} [options.ordered=false] Set to `true` to execute any populate queries one at a time, as opposed to in parallel. Set this option to `true` if populating multiple paths or paths with multiple models in transactions.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  // normalized paths\n  paths = utils.populate(paths);\n  if (paths.length === 0) {\n    return docs;\n  }\n\n  // each path has its own query options and must be executed separately\n  if (paths.find(p => p.ordered)) {\n    // Populate in series, primarily for transactions because MongoDB doesn't support multiple operations on\n    // one transaction in parallel.\n    // Note that if _any_ path has `ordered`, we make the top-level populate `ordered` as well.\n    for (const path of paths) {\n      await _populatePath(this, docs, path);\n    }\n  } else {\n    // By default, populate in parallel\n    const promises = [];\n    for (const path of paths) {\n      promises.push(_populatePath(this, docs, path));\n    }\n    await Promise.all(promises);\n  }\n  return docs;\n};\n\n/*!\n * Populates `docs` for a single `populateOptions` instance.\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\nasync function _populatePath(model, docs, populateOptions) {\n  if (populateOptions.strictPopulate == null) {\n    if (populateOptions._localModel?.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = populateOptions._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (populateOptions._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return;\n  }\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n  if (modelsMap instanceof MongooseError) {\n    throw modelsMap;\n  }\n  const len = modelsMap.length;\n  let vals = [];\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else if (Array.isArray(select)) {\n        select = select.filter(field => field !== '-_id');\n      } else {\n        // preserve original select conditions by copying\n        select = {\n          ...select\n        };\n        delete select._id;\n      }\n    }\n    if (mod.options.options?.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return;\n    }\n    // If no models and no docs to populate but we have a nested populate,\n    // probably a case of unnecessarily populating a non-ref path re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      return model.populate(docs, opts);\n    }\n    return;\n  }\n\n  // Track deferred populates per-param (per model) to avoid mixing them\n  const deferredPopulatesPerParam = new Map();\n  if (populateOptions.ordered) {\n    // Populate in series, primarily for transactions because MongoDB doesn't support multiple operations on\n    // one transaction in parallel.\n    for (let i = 0; i < params.length; i++) {\n      const arr = params[i];\n      const {\n        docs,\n        deferredPopulates\n      } = await _execPopulateQuery.apply(null, arr);\n      vals = vals.concat(docs);\n      if (deferredPopulates.length > 0) {\n        deferredPopulatesPerParam.set(i, deferredPopulates);\n      }\n    }\n  } else {\n    // By default, populate in parallel\n    const promises = [];\n    for (const arr of params) {\n      promises.push(_execPopulateQuery.apply(null, arr));\n    }\n    const results = await Promise.all(promises);\n    for (let i = 0; i < results.length; i++) {\n      const {\n        docs,\n        deferredPopulates\n      } = results[i];\n      vals = vals.concat(docs);\n      if (deferredPopulates.length > 0) {\n        deferredPopulatesPerParam.set(i, deferredPopulates);\n      }\n    }\n  }\n  for (const arr of params) {\n    const mod = arr[0];\n    const assignmentOpts = arr[3];\n    for (const val of vals) {\n      mod.options._childDocs.push(val);\n    }\n    _assign(model, vals, mod, assignmentOpts);\n  }\n\n  // Handle deferred populate for cases with per-document match functions.\n  // We defer populate so sift filtering can compare ObjectIds (not populated docs).\n  // This handles both explicit sub-populate and populate added by pre('find') hooks.\n  // Each param's deferred populates are tracked separately to avoid mixing them\n  // between different models (e.g., when using refPath with multiple model types).\n  if (deferredPopulatesPerParam.size > 0) {\n    for (let i = 0; i < params.length; i++) {\n      const arr = params[i];\n      const mod = arr[0];\n      if (!Array.isArray(mod.match)) {\n        continue;\n      }\n      const paramDeferredPopulates = deferredPopulatesPerParam.get(i);\n      if (!paramDeferredPopulates || paramDeferredPopulates.length === 0) {\n        continue;\n      }\n\n      // Get the assigned (filtered) children from parent docs\n      const childDocsToPopulate = [];\n      for (const doc of mod.docs) {\n        const childVal = doc.$__ != null ? doc.get(mod.options.path) : doc[mod.options.path];\n        if (Array.isArray(childVal)) {\n          childDocsToPopulate.push(...childVal);\n        } else if (childVal != null) {\n          childDocsToPopulate.push(childVal);\n        }\n      }\n      if (childDocsToPopulate.length > 0) {\n        for (const pop of paramDeferredPopulates) {\n          await mod.model.populate(childDocsToPopulate, pop);\n        }\n      }\n    }\n  }\n  for (const arr of params) {\n    removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n  }\n  for (const arr of params) {\n    const mod = arr[0];\n    if (mod.options?.options?._leanTransform) {\n      for (const doc of vals) {\n        mod.options.options._leanTransform(doc);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = {};\n  if (mod.options.skip !== undefined) {\n    queryOptions.skip = mod.options.skip;\n  }\n  if (mod.options.limit !== undefined) {\n    queryOptions.limit = mod.options.limit;\n  }\n  if (mod.options.perDocumentLimit !== undefined) {\n    queryOptions.perDocumentLimit = mod.options.perDocumentLimit;\n  }\n  Object.assign(queryOptions, mod.options.options);\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  // When there's a per-document match function, defer any populate (including from hooks)\n  // until after sift filtering, otherwise sift compares ObjectIds against populated docs.\n  if (Array.isArray(mod.match)) {\n    queryOptions._deferPopulate = true;\n  }\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively.\n  // However, if we have a per-document match function (Array.isArray(mod.match)),\n  // defer sub-populate until after sift filtering, otherwise sift compares\n  // ObjectIds against already-populated docs and fails to match.\n  const shouldDeferSubPopulate = subPopulate && Array.isArray(mod.match);\n\n  // Prepare sub-populate options with necessary metadata (_fullPath, strictPopulate, _localModel).\n  // This must be done for both immediate and deferred sub-populate cases.\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => {\n          pop.strictPopulate = false;\n        });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = {\n          path: subPopulate,\n          strictPopulate: false\n        };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n        // Set _localModel for deferred populates so strictPopulate works correctly\n        if (shouldDeferSubPopulate && pop._localModel == null) {\n          pop._localModel = mod.model;\n        }\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n      // Set _localModel for deferred populates so strictPopulate works correctly\n      if (shouldDeferSubPopulate && subPopulate._localModel == null) {\n        subPopulate._localModel = mod.model;\n      }\n    }\n  }\n  if (subPopulate && !shouldDeferSubPopulate) {\n    query.populate(subPopulate);\n  }\n  return query.exec().then(docs => {\n    for (const val of docs) {\n      leanPopulateMap.set(val, mod.model);\n    }\n    // Return both docs and any deferred populates (from hooks or explicit sub-populate)\n    const deferredPopulates = [];\n    if (query._deferredPopulate) {\n      deferredPopulates.push(...query._deferredPopulate);\n      delete query._deferredPopulate;\n    }\n    if (shouldDeferSubPopulate) {\n      deferredPopulates.push(subPopulate);\n    }\n    return {\n      docs,\n      deferredPopulates\n    };\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options && options.options && options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._doc._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._doc._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual || rawDocs[key].constructor !== val.constructor || (rawDocs[key] instanceof Document ? String(rawDocs[key]._doc._id) : String(rawDocs[key]._id)) !== (val instanceof Document ? String(val._doc._id) : String(val._id))) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || {\n          value: _val\n        };\n      }\n    }\n  }\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n  schema._preCompile();\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n  const collection = connection.collection(collectionName, collectionOptions);\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function () {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  model._applyQueryMiddleware();\n  applyQueryMethods(model, schema.query);\n  return model;\n};\n\n/**\n * If auto encryption is enabled, returns a ClientEncryption instance that is configured with the same settings that\n * Mongoose's underlying MongoClient is using.  If the client has not yet been configured, returns null.\n *\n * @returns {ClientEncryption | null}\n */\nModel.clientEncryption = function clientEncryption() {\n  const ClientEncryption = this.base.driver.get().ClientEncryption;\n  if (!ClientEncryption) {\n    throw new Error('The mongodb driver must be used to obtain a ClientEncryption object.');\n  }\n  const client = this.collection?.conn?.client;\n  if (!client) return null;\n  const autoEncryptionOptions = client.options.autoEncryption;\n  if (!autoEncryptionOptions) return null;\n  const {\n    keyVaultNamespace,\n    keyVaultClient,\n    kmsProviders,\n    credentialProviders,\n    proxyOptions,\n    tlsOptions\n  } = autoEncryptionOptions;\n  return new ClientEncryption(keyVaultClient ?? client, {\n    keyVaultNamespace,\n    kmsProviders,\n    credentialProviders,\n    proxyOptions,\n    tlsOptions\n  });\n};\n\n/**\n * Update this model to use the new connection, including updating all internal\n * references and creating a new `Collection` instance using the new connection.\n * Not for external use, only used by `setDriver()` to ensure that you can still\n * call `setDriver()` after creating a model using `mongoose.model()`.\n *\n * @param {Connection} newConnection the new connection to use\n * @api private\n */\n\nModel.$__updateConnection = function $__updateConnection(newConnection) {\n  this.db = newConnection;\n  this.prototype.db = newConnection;\n  this.prototype[modelDbSymbol] = newConnection;\n  const collection = newConnection.collection(this.collection.collectionName, this.collection.opts);\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n  this.collection = collection;\n  this.$__collection = collection;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n  const s = schema && typeof schema !== 'string' ? schema : _this.prototype.$__schema;\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') || utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Apply changes made to this model's schema after this model was compiled.\n * By default, adding virtuals and other properties to a schema after the model is compiled does nothing.\n * Call this function to apply virtuals and properties that were added later.\n *\n * #### Example:\n *\n *     const schema = new mongoose.Schema({ field: String });\n *     const TestModel = mongoose.model('Test', schema);\n *     TestModel.schema.virtual('myVirtual').get(function() {\n *       return this.field + ' from myVirtual';\n *     });\n *     const doc = new TestModel({ field: 'Hello' });\n *     doc.myVirtual; // undefined\n *\n *     TestModel.recompileSchema();\n *     doc.myVirtual; // 'Hello from myVirtual'\n *\n * @return {undefined}\n * @api public\n * @memberOf Model\n * @static\n * @method recompileSchema\n */\n\nModel.recompileSchema = function recompileSchema() {\n  this.prototype.$__setSchema(this.schema);\n  if (this.schema._applyDiscriminators != null) {\n    for (const disc of this.schema._applyDiscriminators.keys()) {\n      this.discriminator(disc, this.schema._applyDiscriminators.get(disc));\n    }\n  }\n  delete this.schema._defaultToObjectOptionsMap;\n  applyEmbeddedDiscriminators(this.schema, new WeakSet(), true);\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function () {\n  return `Model { ${this.modelName} }`;\n};\n\n/**\n * Return the MongoDB namespace for this model as a string. The namespace is the database name, followed by '.', followed by the collection name.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     const TestModel = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     TestModel.namespace(); // 'mydb.tests'\n *\n * @api public\n */\n\nModel.namespace = function namespace() {\n  return this.db.name + '.' + this.collection.collectionName;\n};\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Applies query middleware from this model's schema to this model's\n * Query constructor.\n */\n\nModel._applyQueryMiddleware = function _applyQueryMiddleware() {\n  const Query = this.Query;\n  const queryMiddleware = this.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || utils.hasOwnKeys(contexts) === false;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n  Query.prototype._queryMiddleware = queryMiddleware;\n};\nfunction _getContexts(hook) {\n  const ret = {};\n  if (Object.hasOwn(hook, 'query')) {\n    ret.query = hook.query;\n  }\n  if (Object.hasOwn(hook, 'document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;","map":{"version":3,"names":["Aggregate","require","ChangeStream","Document","DocumentNotFoundError","EventEmitter","Kareem","MongooseBulkWriteError","MongooseError","ObjectParameterError","OverwriteModelError","Query","SaveOptions","Schema","ValidationError","VersionError","ParallelSaveError","applyDefaultsHelper","isInPathsToSave","applyDefaultsToPOJO","applyEmbeddedDiscriminators","applyHooks","applyMethods","applyProjection","applyReadConcern","applySchemaCollation","applyStaticHooks","applyStatics","applyTimestampsHelper","applyWriteConcern","applyVirtualsHelper","assignVals","castBulkWrite","clone","createPopulateQueryFilter","decorateUpdateWithVersionKey","getDefaultBulkwriteResult","getSchemaDiscriminatorByValue","discriminator","each","get","getConstructorName","getDiscriminatorByValue","getModelsMapForPopulate","immediate","internalToObjectOptions","isDefaultIdIndex","isIndexEqual","isIndexSpecEqual","isTimeseriesIndex","getRelatedDBIndexes","getRelatedSchemaIndexes","decorateDiscriminatorIndexOptions","isPathSelectedInclusive","leanPopulateMap","parallelLimit","prepareDiscriminatorPipeline","pushNestedArrayPaths","removeDeselectedForeignField","setDottedPath","buildMiddlewareFilter","util","utils","minimize","MongooseBulkSaveIncompleteError","ObjectExpectedError","decorateBulkWriteResult","modelCollectionSymbol","Symbol","modelDbSymbol","arrayAtomicsBackupSymbol","arrayAtomicsSymbol","modelSymbol","subclassedSymbol","VERSION_INC","VERSION_WHERE","VERSION_ALL","saveToObjectOptions","Object","assign","bson","Model","doc","fields","options","TypeError","call","setPrototypeOf","prototype","$isMongooseModelPrototype","db","useConnection","connection","Error","models","modelName","collection","$collection","collectionName","$__collection","$where","baseModelName","events","_middleware","_applyCustomWhere","where","key","keys","_createSaveOptions","saveOptions","$__schema","writeConcern","w","j","wtimeout","checkKeys","session","$session","asyncLocalStorage","base","transactionAsyncLocalStorage","getStore","hasOwn","$__save","_execDocumentPreHooks","error","_execDocumentPostHooks","result","$isNew","obj","toObject","_id","$__version","$__reset","_setIsNew","$__","inserting","insertOne","catch","err","pathsToSave","Array","isArray","pathsToSaveSet","Set","delta","$__delta","unsavedDirty","$__dirty","unsavedDefaultPaths","activePaths","getStatePaths","filter","path","$__where","update","updateOp","values","isPOJO","hasOwnKeys","$unset","modifiedPaths","restoreUnsavedState","updateOne","$__undoReset","version","constructor","findOne","projection","then","documentExists","matchedCount","_transformDuplicateKeyError","numAffected","length","versionBump","doIncrement","undefined","versionKey","$__getValue","$versionError","$__setValue","saving","savedState","$emit","emit","dirty","modify","value","default","generateVersionError","defaultPaths","concat","save","arguments","parallelSave","$op","timestamps","$__handleReject","$save","$__isSelected","$set","$inc","increment","_where","_doc","deleteOne","self","query","preFilter","postFilter","pre","queryPreDeleteOne","res","execPre","callSubdocPreHooks","Promise","all","$getAllSubdocs","map","subdoc","skipIfAlreadyDeleted","isDeleted","skipWrappedFunction","post","callSubdocPostHooks","execPost","queryPostDeleteOne","transform","setIsDeleted","deletedCount","$isDeleted","$model","name","model","exists","_checkContext","select","lean","setOptions","schema","getFunctionName","mergePlugins","overwriteModels","isObject","instanceOfSchema","mergeHooks","$isRootDiscriminator","$globalPluginsApplied","discriminators","d","defineProperty","configurable","writable","submodel","__subclass","ctx","fnName","global","i","init","$init","conn","_ensureIndexes","autoIndex","getOption","config","ensureIndexes","_automatic","_createSearchIndexes","autoSearchIndex","createSearchIndexes","_createCollection","autoCreate","_waitForConnect","createCollection","_catch","_this","$caught","apply","middleware","hooks","collectionOptions","schemaCollation","collation","capped","size","timeseries","expireAfterSeconds","expires","clusteredIndex","unique","code","syncIndexes","diffIndexesResult","diffIndexes","indexOptionsToCreate","dropped","cleanIndexes","toDrop","createIndexes","toCreate","createSearchIndex","description","updateSearchIndex","definition","dropSearchIndex","listSearchIndexes","cursor","toArray","dbIndexes","listIndexes","codeName","schemaIndexes","indexes","getIndexesToDrop","getIndexesToCreate","schemaIndexKeysObject","schemaIndexOptions","found","index","includes","push","dbIndex","_dropIndexes","hideIndexes","indexName","command","collMod","hidden","dropIndex","buffer","resolve","addQueue","reject","callback","indexError","done","warn","seenIndexes","indexOptions","existingIndex","JSON","stringify","indexSingleDone","indexSingleStart","baseSchema","_baseSchema","baseSchemaIndexes","create","shift","_autoIndex","find","deepEqual","indexFields","promise","createIndex","results","searchIndex","_searchIndexes","translateAliases","errorOnDuplicates","translate","alias","translated","fieldKeys","split","currentSchema","aliases","paths","translatedKey","join","Map","set","delete","field","conditions","mq","deleteMany","findById","id","estimatedDocumentCount","countDocuments","distinct","val","findOneAndUpdate","depopulate","_isNested","findByIdAndUpdate","findOneAndDelete","findByIdAndDelete","findOneAndReplace","replacement","args","discriminatorKey","last","hasCallback","pop","immediateError","aggregateErrors","ordered","toSave","allSettled","status","reason","firstError","watch","pipeline","watchOptions","hydrate","omit","changeStreamThunk","cb","closed","driverChangeStream","startSession","insertMany","arr","ThisModel","limit","rawResult","throwOnValidationError","validationErrors","validationErrorsToOriginalOrder","validateDoc","createdNewDoc","$validate","_skipParallelValidateCheck","docs","originalDocIndex","validDocIndexToOriginalIndex","docAttributes","sort","err1","err2","acknowledged","insertedCount","insertedIds","docObjects","shouldSetTimestamps","initializeTimestamps","$__hasOnlyPrimitiveValues","$__toObjectShallow","writeErrors","hasWriteErrors","erroredIndexes","originalIndex","firstErroredIndex","insertedDocs","isErrored","has","setIsNewForInsertedDoc","attribute","populate","subdocs","useCache","bulkWrite","ops","BulkWriteResult","driver","bulkWriteResult","n","validations","_skipCastBulkWrite","op","fn","validOpIndexes","v1","v2","v","validOps","writeErrorsByIndex","writeError","bulkSave","documents","document","buildPreSavePromise","writeOperations","buildBulkWriteOperations","opts","skipValidation","bulkWriteError","successfulDocuments","documentError","writeErrorDocumentId","q","toString","handleSuccessfulWrite","newOptions","s","_applyVersionIncrement","applyDefaults","exclude","applyVirtuals","virtualsToApply","applyTimestamps","castObject","ret","schemaType","$isMongooseArray","pieces","indexOf","cur","isNaN","$isMongooseDocumentArray","castNonArraysOption","castNonArrays","ignoreCastErrors","addError","Constructor","$isSingleNested","$isMongooseDocumentArrayElement","cast","setDefaultOptions","validateBeforeSave","validateSync","isANewDocument","isNew","writeOperation","injectTimestampsOption","isDocumentWithChanges","isEmptyObject","changes","shardKey","len","virtuals","hydratedPopulatedDocs","createModel","updateMany","_update","replaceOne","aggregate","option","validate","pathsOrOptions","context","_pathsToValidate","p","pathsToSkip","x","piece","errors","promises","doValidate","_populatePath","excludeIdReg","excludeIdRegGlobal","populateOptions","strictPopulate","_localModel","_userProvidedOptions","every","isNullOrUndefined","modelsMap","vals","flatten","item","hasOne","params","mod","ids","array","assignmentOpts","excludeId","test","_leanTransform","_assign","foreignField","clear","add","match","skipInvalidIds","replace","originalLimit","deferredPopulatesPerParam","deferredPopulates","_execPopulateQuery","_childDocs","paramDeferredPopulates","childDocsToPopulate","childVal","subPopulate","queryOptions","skip","perDocumentLimit","count","_deferPopulate","selectedInclusively","_fields","shouldDeferSubPopulate","forEach","basePath","_fullPath","exec","_deferredPopulate","isVirtual","justOne","_val","rawOrder","rawDocs","allIds","getValue","__val","String","wasPopulated","originalModel","rawIds","unpopulatedValues","allOptions","populatedModel","virtual","compile","versioningEnabled","o","Number","loadClass","skipId","execPreSync","Discriminator","_preCompile","schemaUserProvidedOptions","$__setSchema","statics","_applyQueryMiddleware","applyQueryMethods","clientEncryption","ClientEncryption","client","autoEncryptionOptions","autoEncryption","keyVaultNamespace","keyVaultClient","kmsProviders","credentialProviders","proxyOptions","tlsOptions","$__updateConnection","newConnection","methods","subclass","toCollectionName","pluralize","recompileSchema","_applyDiscriminators","disc","_defaultToObjectOptionsMap","WeakSet","inspect","namespace","custom","queryMiddleware","hook","contexts","_getContexts","_queryMiddleware","module","exports"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/mongoose/lib/model.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = require('./aggregate');\nconst ChangeStream = require('./cursor/changeStream');\nconst Document = require('./document');\nconst DocumentNotFoundError = require('./error/notFound');\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseBulkWriteError = require('./error/bulkWriteError');\nconst MongooseError = require('./error/index');\nconst ObjectParameterError = require('./error/objectParameter');\nconst OverwriteModelError = require('./error/overwriteModel');\nconst Query = require('./query');\nconst SaveOptions = require('./options/saveOptions');\nconst Schema = require('./schema');\nconst ValidationError = require('./error/validation');\nconst VersionError = require('./error/version');\nconst ParallelSaveError = require('./error/parallelSave');\nconst applyDefaultsHelper = require('./helpers/document/applyDefaults');\nconst isInPathsToSave = require('./helpers/document/isInPathsToSave');\nconst applyDefaultsToPOJO = require('./helpers/model/applyDefaultsToPOJO');\nconst applyEmbeddedDiscriminators = require('./helpers/discriminator/applyEmbeddedDiscriminators');\nconst applyHooks = require('./helpers/model/applyHooks');\nconst applyMethods = require('./helpers/model/applyMethods');\nconst applyProjection = require('./helpers/projection/applyProjection');\nconst applyReadConcern = require('./helpers/schema/applyReadConcern');\nconst applySchemaCollation = require('./helpers/indexes/applySchemaCollation');\nconst applyStaticHooks = require('./helpers/model/applyStaticHooks');\nconst applyStatics = require('./helpers/model/applyStatics');\nconst applyTimestampsHelper = require('./helpers/document/applyTimestamps');\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst applyVirtualsHelper = require('./helpers/document/applyVirtuals');\nconst assignVals = require('./helpers/populate/assignVals');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst clone = require('./helpers/clone');\nconst createPopulateQueryFilter = require('./helpers/populate/createPopulateQueryFilter');\nconst decorateUpdateWithVersionKey = require('./helpers/update/decorateUpdateWithVersionKey');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst discriminator = require('./helpers/model/discriminator');\nconst each = require('./helpers/each');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst getModelsMapForPopulate = require('./helpers/populate/getModelsMapForPopulate');\nconst immediate = require('./helpers/immediate');\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst isDefaultIdIndex = require('./helpers/indexes/isDefaultIdIndex');\nconst isIndexEqual = require('./helpers/indexes/isIndexEqual');\nconst isIndexSpecEqual = require('./helpers/indexes/isIndexSpecEqual');\nconst isTimeseriesIndex = require('./helpers/indexes/isTimeseriesIndex');\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = require('./helpers/indexes/getRelatedIndexes');\nconst decorateDiscriminatorIndexOptions = require('./helpers/indexes/decorateDiscriminatorIndexOptions');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\nconst leanPopulateMap = require('./helpers/populate/leanPopulateMap');\nconst parallelLimit = require('./helpers/parallelLimit');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst pushNestedArrayPaths = require('./helpers/model/pushNestedArrayPaths');\nconst removeDeselectedForeignField = require('./helpers/populate/removeDeselectedForeignField');\nconst setDottedPath = require('./helpers/path/setDottedPath');\nconst { buildMiddlewareFilter } = require('./helpers/buildMiddlewareFilter');\nconst util = require('util');\nconst utils = require('./utils');\nconst minimize = require('./helpers/minimize');\nconst MongooseBulkSaveIncompleteError = require('./error/bulkSaveIncompleteError');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst {\n  arrayAtomicsBackupSymbol,\n  arrayAtomicsSymbol,\n  modelSymbol\n} = require('./helpers/symbols');\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst { VERSION_INC, VERSION_WHERE, VERSION_ALL } = Document;\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Object} [options] optional object containing the options for the document.\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @param {Boolean} [options.skipId=false] By default, Mongoose document if one is not provided and the document's schema does not override Mongoose's default `_id`. Set `skipId` to `true` to skip this generation step.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, options) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` constructor must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  if (typeof doc === 'string') {\n    throw new TypeError('First argument to `Model` constructor must be an object, ' +\n      '**not** a string. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, options);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * Changes the Connection instance this model uses to make requests to MongoDB.\n * This function is most useful for changing the Connection that a Model defined using `mongoose.model()` uses\n * after initialization.\n *\n * #### Example:\n *\n *     await mongoose.connect('mongodb://127.0.0.1:27017/db1');\n *     const UserModel = mongoose.model('User', mongoose.Schema({ name: String }));\n *     UserModel.connection === mongoose.connection; // true\n *\n *     const conn2 = await mongoose.createConnection('mongodb://127.0.0.1:27017/db2').asPromise();\n *     UserModel.useConnection(conn2); // `UserModel` now stores documents in `db2`, not `db1`\n *\n *     UserModel.connection === mongoose.connection; // false\n *     UserModel.connection === conn2; // true\n *\n *     conn2.model('User') === UserModel; // true\n *     mongoose.model('User'); // Throws 'MissingSchemaError'\n *\n * Note: `useConnection()` does **not** apply any [connection-level plugins](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.plugin()) from the new connection.\n * If you use `useConnection()` to switch a model's connection, the model will still have the old connection's plugins.\n *\n * @function useConnection\n * @param [Connection] connection The new connection to use\n * @return [Model] this\n * @api public\n */\n\nModel.useConnection = function useConnection(connection) {\n  if (!connection) {\n    throw new Error('Please provide a connection.');\n  }\n  if (this.db) {\n    delete this.db.models[this.modelName];\n    delete this.prototype.db;\n    delete this.prototype[modelDbSymbol];\n    delete this.prototype.collection;\n    delete this.prototype.$collection;\n    delete this.prototype[modelCollectionSymbol];\n  }\n\n  this.db = connection;\n  const collection = connection.collection(this.collection.collectionName, connection.options);\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n  this.prototype.db = connection;\n  this.prototype[modelDbSymbol] = connection;\n  this.collection = collection;\n  this.$__collection = collection;\n  connection.models[this.modelName] = this;\n\n  return this;\n};\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\nfunction _createSaveOptions(doc, options) {\n  const saveOptions = {};\n\n  applyWriteConcern(doc.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = doc.$session();\n  const asyncLocalStorage = doc[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();\n  if (session != null) {\n    saveOptions.session = session;\n  } else if (!Object.hasOwn(options, 'session') && asyncLocalStorage?.session != null) {\n    // Only set session from asyncLocalStorage if `session` option wasn't originally passed in options\n    saveOptions.session = asyncLocalStorage.session;\n  }\n\n  return saveOptions;\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = async function $__save(options) {\n  try {\n    await this._execDocumentPreHooks('save', options, [options]);\n  } catch (error) {\n    await this._execDocumentPostHooks('save', options, error);\n    return;\n  }\n\n\n  let result = null;\n  let where = null;\n  try {\n    const saveOptions = _createSaveOptions(this, options);\n\n    if (this.$isNew) {\n      // send entire doc\n      const obj = this.toObject(saveToObjectOptions);\n      if ((obj || {})._id === void 0) {\n        // documents must have an _id else mongoose won't know\n        // what to update later if more changes are made. the user\n        // wouldn't know what _id was generated by mongodb either\n        // nor would the ObjectId generated by mongodb necessarily\n        // match the schema definition.\n        throw new MongooseError('document must have an _id before saving');\n      }\n\n      this.$__version(true, obj);\n      this.$__reset();\n      _setIsNew(this, false);\n      // Make it possible to retry the insert\n      this.$__.inserting = true;\n      result = await this[modelCollectionSymbol].insertOne(obj, saveOptions).catch(err => {\n        _setIsNew(this, true);\n        throw err;\n      });\n    } else {\n      // Make sure we don't treat it as a new object on error,\n      // since it already exists\n      this.$__.inserting = false;\n      const pathsToSave = Array.isArray(options.pathsToSave) ? options.pathsToSave : null;\n      const pathsToSaveSet = pathsToSave != null ? new Set(pathsToSave) : null;\n      const delta = this.$__delta(pathsToSave, pathsToSaveSet);\n      const unsavedDirty = pathsToSave != null ? (delta != null ? delta[2] : this.$__dirty()) : null;\n      const unsavedDefaultPaths = pathsToSave != null\n        ? Object.keys(this.$__.activePaths.getStatePaths('default')).filter(path => !isInPathsToSave(path, pathsToSaveSet, pathsToSave))\n        : null;\n\n      if (delta) {\n        where = this.$__where(delta[0]);\n        _applyCustomWhere(this, where);\n\n        const update = delta[1];\n        if (this.$__schema.options.minimize) {\n          for (const updateOp of Object.values(update)) {\n            if (updateOp == null) {\n              continue;\n            }\n            for (const key of Object.keys(updateOp)) {\n              if (updateOp[key] == null || typeof updateOp[key] !== 'object') {\n                continue;\n              }\n              if (!utils.isPOJO(updateOp[key])) {\n                continue;\n              }\n              minimize(updateOp[key]);\n              if (utils.hasOwnKeys(updateOp[key]) === false) {\n                delete updateOp[key];\n                update.$unset = update.$unset || {};\n                update.$unset[key] = 1;\n              }\n            }\n          }\n        }\n\n        // store the modified paths before the document is reset\n        this.$__.modifiedPaths = this.modifiedPaths();\n        this.$__reset();\n        restoreUnsavedState(this, unsavedDirty, unsavedDefaultPaths);\n\n        _setIsNew(this, false);\n        result = await this[modelCollectionSymbol].updateOne(where, update, saveOptions).catch(err => {\n          this.$__undoReset();\n          throw err;\n        });\n      } else {\n        where = this.$__where();\n        _applyCustomWhere(this, where);\n        if (this.$__.version) {\n          this.$__version(where, delta);\n        }\n\n        applyReadConcern(this.$__schema, saveOptions);\n        result = await this.constructor.collection.findOne(where, { ...saveOptions, projection: { _id: 1 } })\n          .then(documentExists => ({ matchedCount: !documentExists ? 0 : 1 }));\n      }\n    }\n  } catch (err) {\n    const error = this.$__schema._transformDuplicateKeyError(err);\n    await this._execDocumentPostHooks('save', options, error);\n    return;\n  }\n\n  let numAffected = 0;\n  const writeConcern = options != null ?\n    options.writeConcern != null ?\n      options.writeConcern.w :\n      options.w :\n    0;\n  if (writeConcern !== 0) {\n    // Skip checking if write succeeded if writeConcern is set to\n    // unacknowledged writes, because otherwise `numAffected` will always be 0\n    if (result != null) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.matchedCount != null) {\n        numAffected = result.matchedCount;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    const versionBump = this.$__.version;\n    // was this an update that required a version bump?\n    if (versionBump && !this.$__.inserting) {\n      const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n      this.$__.version = undefined;\n      const key = this.$__schema.options.versionKey;\n      const version = this.$__getValue(key) || 0;\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        this.$__undoReset();\n        const err = this.$__.$versionError ||\n          new VersionError(this, version, this.$__.modifiedPaths);\n        await this._execDocumentPostHooks('save', options, err);\n        return;\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        this.$__setValue(key, version + 1);\n      }\n    }\n    if (result != null && numAffected <= 0) {\n      this.$__undoReset();\n      const error = new DocumentNotFoundError(where, this.constructor.modelName, numAffected, result);\n      await this._execDocumentPostHooks('save', options, error);\n      return;\n    }\n  }\n  this.$__.saving = undefined;\n  this.$__.savedState = {};\n  this.$emit('save', this, numAffected);\n  this.constructor.emit('save', this, numAffected);\n  await this._execDocumentPostHooks('save', options);\n};\n\n/*!\n * Restores $__.activePaths state and any atomics for paths that failed\n * to save.\n *\n * @param {Document} doc\n * @param {object[]} unsavedDirty\n * @param {string[]} unsavedDefaultPaths\n */\n\nfunction restoreUnsavedState(doc, unsavedDirty, unsavedDefaultPaths) {\n  if (unsavedDirty == null) {\n    return;\n  }\n\n  for (const dirty of unsavedDirty) {\n    doc.$__.activePaths.modify(dirty.path);\n    if (dirty.value?.[arrayAtomicsBackupSymbol]) {\n      dirty.value[arrayAtomicsSymbol] = dirty.value[arrayAtomicsBackupSymbol];\n      dirty.value[arrayAtomicsBackupSymbol] = null;\n    }\n  }\n\n  for (const path of unsavedDefaultPaths) {\n    doc.$__.activePaths.default(path);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths, defaultPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths.concat(defaultPaths));\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Array} [options.pathsToSave] An array of paths that tell mongoose to only validate and save the paths in `pathsToSave`.\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (Object.hasOwn(options, 'session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(\n    this,\n    this.modifiedPaths(),\n    Object.keys(this.$__.activePaths.getStatePaths('default'))\n  );\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  try {\n    await this.$__save(options);\n  } catch (error) {\n    this.$__handleReject(error);\n    throw error;\n  } finally {\n    this.$__.saving = null;\n    this.$__.saveOptions = null;\n    this.$__.$versionError = null;\n    this.$op = null;\n  }\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n};\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    throw new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Delete this document from the db. Returns a Query instance containing a `deleteOne` operation by this document's `_id`.\n *\n * #### Example:\n *\n *     await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * Since `deleteOne()` returns a Query, the `deleteOne()` will **not** execute unless you use either `await`, `.then()`, `.catch()`, or [`.exec()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.exec())\n *\n * #### Example:\n *\n *     product.deleteOne(); // Doesn't do anything\n *     product.deleteOne().exec(); // Deletes the document, returns a promise\n *\n * @return {Query} Query\n * @api public\n */\n\nModel.prototype.deleteOne = function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (Object.hasOwn(options, 'session')) {\n    this.$session(options.session);\n  }\n\n  const self = this;\n  const where = this.$__where();\n  const query = self.constructor.deleteOne();\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n\n  query.pre(async function queryPreDeleteOne() {\n    const res = await self.constructor._middleware.execPre('deleteOne', self, [self, options], { filter: preFilter });\n    // `self` is passed to pre hooks as argument for backwards compatibility, but that\n    // isn't the actual arguments passed to the wrapped function.\n    if (res[0] !== self || res[1] !== options) {\n      throw new Error('Document deleteOne pre hooks cannot overwrite arguments');\n    }\n    query.deleteOne(where, options);\n    // Apply custom where conditions _after_ document deleteOne middleware for\n    // consistency with save() - sharding plugin needs to set $where\n    if (self.$where != null) {\n      this.where(self.$where);\n    }\n    return res;\n  });\n  query.pre(function callSubdocPreHooks() {\n    return Promise.all(self.$getAllSubdocs().map(subdoc => subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], { filter: preFilter })));\n  });\n  query.pre(function skipIfAlreadyDeleted() {\n    if (self.$__.isDeleted) {\n      throw new Kareem.skipWrappedFunction();\n    }\n  });\n  query.post(function callSubdocPostHooks() {\n    return Promise.all(self.$getAllSubdocs().map(subdoc => subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], { filter: postFilter })));\n  });\n  query.post(function queryPostDeleteOne() {\n    return self.constructor._middleware.execPost('deleteOne', self, [self], { filter: postFilter });\n  });\n  query.transform(function setIsDeleted(result) {\n    if (result?.deletedCount > 0) {\n      self.$isDeleted(true);\n    }\n    return result;\n  });\n\n  return query;\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n  const overwriteModels = typeof options.overwriteModels === 'boolean' ? options.overwriteModels : false;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks, overwriteModels);\n  if (this.db.models[name] && !schema.options.overwriteModels && !overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for initializing the underlying connection in MongoDB based on schema options.\n * This function performs the following operations:\n *\n * - `createCollection()` unless [`autoCreate`](https://mongoosejs.com/docs/guide.html#autoCreate) option is turned off\n * - `ensureIndexes()` unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) option is turned off\n * - `createSearchIndex()` on all schema search indexes if `autoSearchIndex` is enabled.\n *\n * Mongoose calls this function automatically when a model is a created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createSearchIndexes = async() => {\n    const autoSearchIndex = utils.getOption(\n      'autoSearchIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoSearchIndex) {\n      return;\n    }\n\n    return await this.createSearchIndexes();\n  };\n  const _createCollection = async() => {\n    let autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config\n      // No base.options here because we don't want to take the base value if the connection hasn't\n      // set it yet\n    );\n    if (autoCreate == null) {\n      // `autoCreate` may later be set when the connection is opened, so wait for connect before checking\n      await conn._waitForConnect(true);\n      autoCreate = utils.getOption(\n        'autoCreate',\n        this.schema.options,\n        conn.config,\n        conn.base.options\n      );\n    }\n\n    if (!autoCreate) {\n      return;\n    }\n\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().\n    then(() => _ensureIndexes()).\n    then(() => _createSearchIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n\n  // Remove middleware option before passing to MongoDB\n  if (options?.middleware != null) {\n    options = { ...options };\n    delete options.middleware;\n  }\n\n  [options] = await this.hooks.execPre('createCollection', this, [options], { filter: preFilter }).catch(err => {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      return [err];\n    }\n    throw err;\n  });\n\n  const collectionOptions = this?.schema?.options?.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n\n  const schemaCollation = this?.schema?.options?.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this?.schema?.options?.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this?.schema?.options?.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this?.schema?.options?.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    if (!(options instanceof Kareem.skipWrappedFunction)) {\n      await this.db.createCollection(this.$__collection.collectionName, options);\n    }\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      await this.hooks.execPost('createCollection', this, [null], { error: err, filter: postFilter });\n    }\n  }\n\n  await this.hooks.execPost('createCollection', this, [this.$__collection], { filter: postFilter });\n\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.hideIndexes=false] set to `true` to hide indexes instead of dropping. Requires MongoDB server 4.4 or higher\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const autoCreate = options?.autoCreate ??\n    this.schema.options?.autoCreate ??\n    this.db.config.autoCreate ??\n    this.db.base?.options?.autoCreate ??\n    true;\n\n  if (autoCreate) {\n    try {\n      await this.createCollection();\n    } catch (err) {\n      if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n        throw err;\n      }\n    }\n  }\n\n  const diffIndexesResult = await this.diffIndexes({ indexOptionsToCreate: true });\n  const dropped = await this.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await this.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Create an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Promise}\n * @api public\n */\n\nModel.createSearchIndex = async function createSearchIndex(description) {\n  _checkContext(this, 'createSearchIndex');\n\n  return await this.$__collection.createSearchIndex(description);\n};\n\n/**\n * Update an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.updateSearchIndex('test', { mappings: { dynamic: true } });\n *\n * @param {String} name\n * @param {Object} definition\n * @return {Promise}\n * @api public\n */\n\nModel.updateSearchIndex = async function updateSearchIndex(name, definition) {\n  _checkContext(this, 'updateSearchIndex');\n\n  return await this.$__collection.updateSearchIndex(name, definition);\n};\n\n/**\n * Delete an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) by name.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.dropSearchIndex('test');\n *\n * @param {String} name\n * @return {Promise}\n * @api public\n */\n\nModel.dropSearchIndex = async function dropSearchIndex(name) {\n  _checkContext(this, 'dropSearchIndex');\n\n  return await this.$__collection.dropSearchIndex(name);\n};\n\n/**\n * List all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) on this model's collection.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *     const res = await Customer.listSearchIndexes(); // Includes `[{ name: 'test' }]`\n *\n * @param {Object} [options]\n * @return {Promise<Array>}\n * @api public\n */\n\nModel.listSearchIndexes = async function listSearchIndexes(options) {\n  _checkContext(this, 'listSearchIndexes');\n\n  const cursor = await this.$__collection.listSearchIndexes(options);\n\n  return await cursor.toArray();\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of index specs containing the keys of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @param {Boolean} [options.indexOptionsToCreate=false] If true, `toCreate` will include both the index spec and the index options, not just the index spec\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes(options) {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options) {\n  const toCreate = [];\n  const indexOptionsToCreate = options?.indexOptionsToCreate ?? false;\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      if (indexOptionsToCreate) {\n        toCreate.push([schemaIndexKeysObject, schemaIndexOptions]);\n      } else {\n        toCreate.push(schemaIndexKeysObject);\n      }\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n    // Timeseries collections have a default index on { timeField: 1, metaField: 1 }.\n    if (isTimeseriesIndex(dbIndex, schema.options)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (found) {\n      continue;\n    }\n\n    toDrop.push(dbIndex.name);\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Object} [options]\n * @param {Array<String>} [options.toDrop] if specified, contains a list of index names to drop\n * @param {Boolean} [options.hideIndexes=false] set to `true` to hide indexes instead of dropping. Requires MongoDB server 4.4 or higher\n * @return {Promise<Array<String>>} list of dropped or hidden index names\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  if (Array.isArray(options?.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, model, options);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, model, options);\n};\n\nasync function _dropIndexes(toDrop, model, options) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  const collection = model.$__collection;\n  if (options?.hideIndexes) {\n    await Promise.all(toDrop.map(indexName => {\n      return model.db.db.command({\n        collMod: collection.collectionName,\n        index: { name: indexName, hidden: true }\n      });\n    }));\n  } else {\n    await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  }\n\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     await Event.ensureIndexes();\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     });\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = Array.isArray(options?.toCreate) ? options.toCreate : model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  // Check for duplicate index definitions (gh-15056)\n  const seenIndexes = [];\n  for (const index of indexes) {\n    const fields = index[0];\n    const indexOptions = index[1];\n    if (indexOptions.name == null) {\n      for (const existingIndex of seenIndexes) {\n        if (existingIndex[1].name == null && isIndexSpecEqual(existingIndex[0], fields)) {\n          utils.warn('mongoose: Duplicate schema index on ' + JSON.stringify(fields) +\n            ' for model \"' + model.modelName + '\". ' +\n            'This is often due to declaring an index using both \"index: true\" and \"schema.index()\". ' +\n            'Please remove the duplicate index definition.');\n          break;\n        }\n      }\n    }\n    seenIndexes.push(index);\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    // Just in case `createIndex()` throws a sync error\n    let promise = null;\n    try {\n      promise = model.collection.createIndex(indexFields, indexOptions);\n    } catch (err) {\n      if (!indexError) {\n        indexError = err;\n      }\n      if (!model.$caught) {\n        model.emit('error', err);\n      }\n\n      indexSingleDone(err, indexFields, indexOptions);\n      create();\n      return;\n    }\n\n    promise.then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Creates all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) defined in this model's schema.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: String,\n *       description: String\n *     });\n *     schema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *     const Product = mongoose.model('Product', schema);\n *\n *     // Creates the search index defined in the schema\n *     await Product.createSearchIndexes();\n *\n * @api public\n * @return {Promise} resolves to the results of creating the search indexes\n */\n\nModel.createSearchIndexes = async function createSearchIndexes() {\n  _checkContext(this, 'createSearchIndexes');\n  const results = [];\n  for (const searchIndex of this.schema._searchIndexes) {\n    results.push(await this.createSearchIndex(searchIndex));\n  }\n  return results;\n};\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema?.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema?.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is equivalent to `findOne({ _id: id })`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     const count = await Adventure.countDocuments({ type: 'jungle' });\n *     console.log('there are %d jungle adventures', count);\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @param {Object} [options] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions, options) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`. A Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(filter, update, options);  // returns Query\n *     A.findOneAndUpdate(filter, update);           // returns Query\n *     A.findOneAndUpdate(filter);                   // returns Query\n *     A.findOneAndUpdate();                         // returns Query\n *\n *     // Other supported syntaxes\n *     // Note that calling `Query#findOneAndUpdate()` with 1 arg will treat the arg as `update`, NOT `filter`\n *     A.find(filter).findOneAndUpdate(update);\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options);\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options);\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {'before'|'after'} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {'before'|'after'} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._doc._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndDelete https://mongoosejs.com/docs/api/model.html#Model.findOneAndDelete()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {'before'|'after'} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        last &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.session && !options.ordered && args.length > 1) {\n    throw new MongooseError('Cannot call `create()` with a session and multiple documents unless `ordered: true` is set');\n  }\n\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else if (!immediateError) {\n    res = await Promise.allSettled(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n\n      await toSave.$save(options);\n\n      return toSave;\n    }));\n    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);\n  } else {\n    let firstError = null;\n    res = await Promise.all(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      try {\n        let toSave = doc;\n\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n\n        return toSave;\n      } catch (err) {\n        if (!firstError) {\n          firstError = err;\n        }\n      }\n    }));\n    if (firstError) {\n      throw firstError;\n    }\n  }\n\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * Shortcut for saving one document to the database.\n * `MyModel.insertOne(obj, options)` is almost equivalent to `new MyModel(obj).save(options)`.\n * The difference is that `insertOne()` checks if `obj` is already a document, and checks for discriminators.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     const character = await Character.insertOne({ name: 'Jean-Luc Picard' });\n *     character.name; // 'Jean-Luc Picard'\n *\n *     // Create a new character within a transaction.\n *     await Character.insertOne({ name: 'Jean-Luc Picard' }, { session });\n *\n * @param {Object|Document} doc Document to insert, as a POJO or Mongoose document\n * @param {Object} [options] Options passed down to `save()`.\n * @return {Promise<Document>} resolves to the saved document\n * @api public\n */\n\nModel.insertOne = async function insertOne(doc, options) {\n  _checkContext(this, 'insertOne');\n\n  const discriminatorKey = this.schema.options.discriminatorKey;\n  const Model = this.discriminators && doc[discriminatorKey] != null ?\n    this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n    this;\n  if (Model == null) {\n    throw new MongooseError(\n      `Discriminator \"${doc[discriminatorKey]}\" not found for model \"${this.modelName}\"`\n    );\n  }\n  if (!(doc instanceof Model)) {\n    doc = new Model(doc);\n  }\n\n  return await doc.$save(options);\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.deleteOne();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  options = options || {};\n  const watchOptions = options?.hydrate !== undefined ?\n    utils.omit(options, ['hydrate']) :\n    { ...options };\n  options.model = this;\n\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, watchOptions);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, watchOptions);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.deleteOne();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     const docs = await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *     docs[0].name; // 'Star Wars'\n *\n *     // Return raw result from MongoDB\n *     const result = await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ], { rawResult: true });\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating the documents. This means Mongoose will **not** cast, validate, or apply defaults to any of the documents passed to `insertMany()`. This option is useful if you need the extra performance, but comes with data integrity risk. Consider using with [`castObject()`](https://mongoosejs.com/docs/api/model.html#Model.castObject()) and [`applyDefaults()`](https://mongoosejs.com/docs/api/model.html#Model.applyDefaults()).\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  options = options || {};\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n\n  try {\n    [arr] = await this._middleware.execPre('insertMany', this, [arr], { filter: preFilter });\n  } catch (error) {\n    await this._middleware.execPost('insertMany', this, [arr], { error, filter: postFilter });\n  }\n  const ThisModel = this;\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !Object.hasOwn(options, 'session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  async function validateDoc(doc, index) {\n    // If option `lean` is set to true bypass validation and hydration\n    if (lean) {\n      return doc;\n    }\n    let createdNewDoc = false;\n    if (!(doc instanceof ThisModel)) {\n      if (doc != null && typeof doc !== 'object') {\n        throw new ObjectParameterError(doc, 'arr.' + index, 'insertMany');\n      }\n      doc = new ThisModel(doc);\n      createdNewDoc = true;\n    }\n\n    if (options.session != null) {\n      doc.$session(options.session);\n    }\n    return doc.$validate(createdNewDoc ? { _skipParallelValidateCheck: true } : null)\n      .then(() => doc)\n      .catch(error => {\n        if (ordered === false) {\n          error.index = index;\n          validationErrors.push(error);\n          validationErrorsToOriginalOrder.set(error, index);\n          results[index] = error;\n          return;\n        }\n        throw error;\n      });\n  }\n\n  const docs = await parallelLimit(arr, validateDoc, limit);\n\n  const originalDocIndex = new Map();\n  const validDocIndexToOriginalIndex = new Map();\n  for (let i = 0; i < docs.length; ++i) {\n    originalDocIndex.set(docs[i], i);\n  }\n\n  // We filter all failed pre-validations by removing nulls\n  const docAttributes = docs.filter(function(doc) {\n    return doc != null;\n  });\n  for (let i = 0; i < docAttributes.length; ++i) {\n    validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n  }\n\n  // Make sure validation errors are in the same order as the\n  // original documents, so if both doc1 and doc2 both fail validation,\n  // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n  // error before doc2's. Re: gh-12791.\n  if (validationErrors.length > 0) {\n    validationErrors.sort((err1, err2) => {\n      return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n    });\n  }\n\n  // Quickly escape while there aren't any valid docAttributes\n  if (docAttributes.length === 0) {\n    if (throwOnValidationError) {\n      throw new MongooseBulkWriteError(\n        validationErrors,\n        results,\n        null,\n        'insertMany'\n      );\n    }\n    if (rawResult) {\n      const res = {\n        acknowledged: true,\n        insertedCount: 0,\n        insertedIds: {}\n      };\n      decorateBulkWriteResult(res, validationErrors, validationErrors);\n      return res;\n    }\n    return [];\n  }\n  const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {\n    if (doc.$__schema.options.versionKey) {\n      doc[doc.$__schema.options.versionKey] = 0;\n    }\n    const shouldSetTimestamps = options?.timestamps !== false && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n    if (shouldSetTimestamps) {\n      doc.initializeTimestamps(options?.timestamps);\n    }\n    if (doc.$__hasOnlyPrimitiveValues()) {\n      return doc.$__toObjectShallow();\n    }\n    return doc.toObject(internalToObjectOptions);\n  });\n\n  let res;\n  try {\n    res = await this.$__collection.insertMany(docObjects, options);\n  } catch (error) {\n    // `writeErrors` is a property reported by the MongoDB driver,\n    // just not if there's only 1 error.\n    if (error.writeErrors == null &&\n        error.result?.result?.writeErrors != null) {\n      error.writeErrors = error.result.result.writeErrors;\n    }\n\n    // `insertedDocs` is a Mongoose-specific property\n    const hasWriteErrors = error?.writeErrors;\n    const erroredIndexes = new Set((error?.writeErrors || []).map(err => err.index));\n\n    if (error.writeErrors != null) {\n      for (let i = 0; i < error.writeErrors.length; ++i) {\n        const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n        error.writeErrors[i] = { ...error.writeErrors[i], index: originalIndex };\n        if (!ordered) {\n          results[originalIndex] = error.writeErrors[i];\n        }\n      }\n    }\n\n    if (!ordered) {\n      for (let i = 0; i < results.length; ++i) {\n        if (results[i] === void 0) {\n          results[i] = docs[i];\n        }\n      }\n\n      error.results = results;\n    }\n\n    let firstErroredIndex = -1;\n    error.insertedDocs = docAttributes.\n      filter((doc, i) => {\n        const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n\n        if (ordered) {\n          if (firstErroredIndex > -1) {\n            return i < firstErroredIndex;\n          }\n\n          if (isErrored) {\n            firstErroredIndex = i;\n          }\n        }\n\n        return !isErrored;\n      }).\n      map(function setIsNewForInsertedDoc(doc) {\n        if (lean) {\n          return doc;\n        }\n        doc.$__reset();\n        _setIsNew(doc, false);\n        return doc;\n      });\n\n    if (rawResult && ordered === false) {\n      decorateBulkWriteResult(error, validationErrors, results);\n    }\n\n    await this._middleware.execPost('insertMany', this, [arr], { error, filter: postFilter });\n  }\n\n  if (!lean) {\n    for (const attribute of docAttributes) {\n      attribute.$__reset();\n      _setIsNew(attribute, false);\n    }\n  }\n\n  if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n    for (let i = 0; i < results.length; ++i) {\n      if (results[i] === void 0) {\n        results[i] = docs[i];\n      }\n    }\n    throw new MongooseBulkWriteError(\n      validationErrors,\n      results,\n      res,\n      'insertMany'\n    );\n  }\n\n  if (rawResult) {\n    if (ordered === false) {\n      for (let i = 0; i < results.length; ++i) {\n        if (results[i] === void 0) {\n          results[i] = docs[i];\n        }\n      }\n\n      // Decorate with mongoose validation errors in case of unordered,\n      // because then still do `insertMany()`\n      decorateBulkWriteResult(res, validationErrors, results);\n    }\n    return res;\n  }\n\n  if (options.populate != null) {\n    return this.populate(docAttributes, options.populate).catch(err => {\n      if (err != null) {\n        err.insertedDocs = docAttributes;\n      }\n      throw err;\n    });\n  }\n\n  const [result] = await this._middleware.execPost('insertMany', this, [docAttributes], { filter: postFilter });\n  return result;\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs({ useCache: true });\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n * The only exception is [setting the `update` operator for `updateOne` or `updateMany` to a pipeline](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#updateone-and-updatemany): Mongoose does **not** cast update pipelines.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n *     // Mongoose does **not** cast update pipelines, so no casting for the `update` option below.\n *     // Mongoose does still cast `filter`\n *     await Character.bulkWrite([{\n *       updateOne: {\n *         filter: { name: 'Annika Hansen' },\n *         update: [{ $set: { name: 7 } }] // Array means update pipeline, so Mongoose skips casting\n *       }\n *     }]);\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.insertOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Boolean} [ops.updateOne.overwriteImmutable=false] Mongoose removes updated immutable properties from `update` by default (excluding $setOnInsert). Set `overwriteImmutable` to `true` to allow updating immutable properties using other update operators.\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Boolean} [ops.updateMany.overwriteImmutable=false] Mongoose removes updated immutable properties from `update` by default (excluding $setOnInsert). Set `overwriteImmutable` to `true` to allow updating immutable properties using other update operators.\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [ops.replaceOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {Boolean} [options.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to any operations. Can be overridden at the operation-level.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully. Note that Mongoose will still send all valid operations to the MongoDB server.\n * @param {Boolean|\"throw\"} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const postFilter = buildMiddlewareFilter(options, 'post');\n\n  try {\n    [ops, options] = await this.hooks.execPre('bulkWrite', this, [ops, options], { filter: preFilter });\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      ops = err;\n    } else {\n      await this.hooks.execPost('bulkWrite', this, [null], { error: err, filter: postFilter });\n    }\n  }\n\n  if (ops instanceof Kareem.skipWrappedFunction) {\n    return ops.args[0];\n  }\n\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  if (ops.length === 0) {\n    const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n    const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n    bulkWriteResult.n = 0;\n    decorateBulkWriteResult(bulkWriteResult, [], []);\n    return bulkWriteResult;\n  }\n\n  const validations = options?._skipCastBulkWrite ? [] : ops.map(op => castBulkWrite(this, op, options));\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !Object.hasOwn(options, 'session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  let res = null;\n  if (ordered) {\n    await new Promise((resolve, reject) => {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n\n    try {\n      res = await this.$__collection.bulkWrite(ops, options);\n    } catch (error) {\n      await this.hooks.execPost('bulkWrite', this, [null], { error, filter: postFilter });\n    }\n  } else {\n    let validOpIndexes = [];\n    let validationErrors = [];\n    const results = [];\n    if (validations.length > 0) {\n      validOpIndexes = await Promise.all(ops.map((op, i) => {\n        if (i >= validations.length) {\n          return i;\n        }\n        return new Promise((resolve) => {\n          validations[i]((err) => {\n            if (err == null) {\n              resolve(i);\n            } else {\n              validationErrors.push({ index: i, error: err });\n              results[i] = err;\n            }\n            resolve();\n          });\n        });\n      }));\n      validOpIndexes = validOpIndexes.filter(index => index != null);\n    } else {\n      validOpIndexes = ops.map((op, i) => i);\n    }\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    const validOps = validOpIndexes.sort().map(index => ops[index]);\n\n    if (validOps.length === 0) {\n      if (options.throwOnValidationError && validationErrors.length) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      }\n      const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n      const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n      bulkWriteResult.result = getDefaultBulkwriteResult();\n      decorateBulkWriteResult(bulkWriteResult, validationErrors, results);\n      return bulkWriteResult;\n    }\n\n    let error;\n    [res, error] = await this.$__collection.bulkWrite(validOps, options).\n      then(res => ([res, null])).\n      catch(error => ([null, error]));\n\n    const writeErrorsByIndex = {};\n    if (error?.writeErrors) {\n      for (const writeError of error.writeErrors) {\n        writeErrorsByIndex[writeError.err.index] = writeError;\n      }\n    }\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = writeErrorsByIndex[i] ?? null;\n    }\n    if (error) {\n      if (validationErrors.length > 0) {\n        decorateBulkWriteResult(error, validationErrors, results);\n      }\n\n      await this.hooks.execPost('bulkWrite', this, [null], { error, filter: postFilter });\n    }\n\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      } else {\n        decorateBulkWriteResult(res, validationErrors, results);\n      }\n    }\n  }\n\n  await this.hooks.execPost('bulkWrite', this, [res], { filter: postFilter });\n\n  return res;\n};\n\n/**\n * Takes an array of documents, gets the changes and inserts/updates documents in the database\n * according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * `bulkSave()` throws errors under the following conditions:\n *\n * - one of the provided documents fails validation. In this case, `bulkSave()` does not send a `bulkWrite()`, and throws the first validation error.\n * - `bulkWrite()` fails (for example, due to being unable to connect to MongoDB or due to duplicate key error)\n * - `bulkWrite()` did not insert or update **any** documents. In this case, `bulkSave()` will throw a DocumentNotFound error.\n *\n * Note that `bulkSave()` will **not** throw an error if only some of the `save()` calls succeeded.\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.validateBeforeSave=true] set to `false` to skip Mongoose validation on all documents\n * @param {Boolean|Object} [options.middleware=true] set to `false` to skip all user-defined middleware\n * @param {Boolean} [options.middleware.pre=true] set to `false` to skip only pre hooks\n * @param {Boolean} [options.middleware.post=true] set to `false` to skip only post hooks\n * @return {BulkWriteResult} the return value from `bulkWrite()`\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(doc => buildPreSavePromise(doc, options)));\n\n  const writeOperations = this.buildBulkWriteOperations(documents, options);\n  const opts = { skipValidation: true, _skipCastBulkWrite: true, ...options };\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, opts).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n  // If not a MongoBulkWriteError, treat this as all documents failed to save.\n  if (bulkWriteError != null && bulkWriteError.name !== 'MongoBulkWriteError') {\n    throw bulkWriteError;\n  }\n\n  const matchedCount = bulkWriteResult?.matchedCount ?? 0;\n  const insertedCount = bulkWriteResult?.insertedCount ?? 0;\n  if (writeOperations.length > 0 && matchedCount + insertedCount < writeOperations.length && !bulkWriteError) {\n    throw new MongooseBulkSaveIncompleteError(\n      this.modelName,\n      documents,\n      bulkWriteResult\n    );\n  }\n\n  const successfulDocuments = [];\n  for (let i = 0; i < documents.length; i++) {\n    const document = documents[i];\n    const documentError = bulkWriteError?.writeErrors.find(writeError => {\n      const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n      return writeErrorDocumentId.toString() === document._doc._id.toString();\n    });\n\n    if (documentError == null) {\n      successfulDocuments.push(document);\n    }\n  }\n  await Promise.all(successfulDocuments.map(document => handleSuccessfulWrite(document, options)));\n\n  if (bulkWriteError != null) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nasync function buildPreSavePromise(document, options) {\n  const preFilter = buildMiddlewareFilter(options, 'pre');\n  const [newOptions] = await document.schema.s.hooks.execPre('save', document, [options], { filter: preFilter });\n  if (newOptions !== options) {\n    throw new Error('Cannot overwrite options in pre(\"save\") hook on bulkSave()');\n  }\n}\n\nasync function handleSuccessfulWrite(document, options) {\n  if (document.$isNew) {\n    _setIsNew(document, false);\n  }\n\n  document.$__reset();\n  document._applyVersionIncrement();\n  const postFilter = buildMiddlewareFilter(options, 'post');\n  return document.schema.s.hooks.execPost('save', document, [document], { filter: postFilter });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc == null) {\n    return doc;\n  }\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Apply this model's virtuals to a given POJO. Virtuals execute with the POJO as the context `this`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     userSchema.virtual('upper').get(function() { return this.name.toUpperCase(); });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const obj = { name: 'John' };\n *     User.applyVirtuals(obj);\n *     obj.name; // 'John'\n *     obj.upper; // 'JOHN', Mongoose applied the return value of the virtual to the given object\n *\n * @param {Object} obj object or document to apply virtuals on\n * @param {Array<string>} [virtualsToApply] optional whitelist of virtuals to apply\n * @returns {Object} obj\n * @api public\n */\n\nModel.applyVirtuals = function applyVirtuals(obj, virtualsToApply) {\n  if (obj == null) {\n    return obj;\n  }\n  // Nothing to do if this is already a hydrated document - it should already have virtuals\n  if (obj.$__ != null) {\n    return obj;\n  }\n\n  applyVirtualsHelper(this.schema, obj, virtualsToApply);\n\n  return obj;\n};\n\n/**\n * Apply this model's timestamps to a given POJO, including subdocument timestamps\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String }, { timestamps: true });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const obj = { name: 'John' };\n *     User.applyTimestamps(obj);\n *     obj.createdAt; // 2024-06-01T18:00:00.000Z\n *     obj.updatedAt; // 2024-06-01T18:00:00.000Z\n *\n * @param {Object} obj object or document to apply virtuals on\n * @param {Object} [options]\n * @param {Boolean} [options.isUpdate=false] if true, treat this as an update: just set updatedAt, skip setting createdAt. If false, set both createdAt and updatedAt\n * @param {Function} [options.currentTime] if set, Mongoose will call this function to get the current time.\n * @returns {Object} obj\n * @api public\n */\n\nModel.applyTimestamps = function applyTimestamps(obj, options) {\n  if (obj == null) {\n    return obj;\n  }\n  // Nothing to do if this is already a hydrated document - it should already have timestamps\n  if (obj.$__ != null) {\n    return obj;\n  }\n\n  applyTimestampsHelper(this.schema, obj, options);\n\n  return obj;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType?.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      const castNonArraysOption = schemaType.options?.castNonArrays ?? schemaType.constructor.options.castNonArrays;\n      if (!Array.isArray(val)) {\n        if (!castNonArraysOption) {\n          if (!options.ignoreCastErrors) {\n            error = error || new ValidationError();\n            error.addError(path, new ObjectExpectedError(path, val));\n          }\n        } else {\n          cur[pieces[pieces.length - 1]] = [\n            Model.castObject.call(schemaType.Constructor, val)\n          ];\n        }\n\n        continue;\n      }\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.Constructor, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n\n  const writeOperations = documents.map((document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      if (options.validateBeforeSave == null || options.validateBeforeSave) {\n        const err = document.validateSync();\n        if (err != null) {\n          throw err;\n        }\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      return writeOperation;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      // If shard key is set, add shard keys to _filter_ condition to right shard is targeted\n      const shardKey = this.schema.options.shardKey;\n      if (shardKey) {\n        const paths = Object.keys(shardKey);\n        const len = paths.length;\n\n        for (let i = 0; i < len; ++i) {\n          where[paths[i]] = document[paths[i]];\n        }\n      }\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      return writeOperation;\n    }\n\n    return null;\n  }).filter(op => op !== null);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @param {Boolean} [options.hydratedPopulatedDocs=false] if true, populates the docs if passing pre-populated data\n * @param {Boolean} [options.virtuals=false] if true, sets any virtuals present on `obj`\n * @param {Boolean|'throw'} [options.strict=false] configure strict mode for the hydrated document. In particular, if strict is false, fields not in the schema won't be stripped out; if strict is 'throw', `hydrate()` will throw an error if there are any fields that are not in the schema. Defaults to true (silently strip out fields not in the schema).\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (options?.virtuals && options?.hydratedPopulatedDocs === false) {\n    throw new MongooseError('Cannot set `hydratedPopulatedDocs` option to false if `virtuals` option is truthy because `virtuals: true` also sets populated virtuals');\n  }\n\n  if (projection != null) {\n    if (obj?.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n  const document = require('./queryHelpers').createModel(this, obj, projection, projection, options);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation. This may be false if Mongoose did not send an update to the server because the update was empty.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n *     // Other supported syntaxes\n *     await Person.find({ name: /Stark$/ }).updateMany({ isDeleted: true }); // Using chaining syntax\n *     await Person.find().updateMany({ isDeleted: true }); // Set `isDeleted` on _all_ Person documents\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, update, options) {\n  _checkContext(this, 'updateMany');\n\n  if (update == null) {\n    throw new MongooseError('updateMany `update` parameter cannot be nullish');\n  }\n\n  return _update(this, 'updateMany', conditions, update, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation. This may be false if Mongoose did not send an update to the server because the update was empty.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n *     // Other supported syntaxes\n *     await Person.findOne({ name: 'Jean-Luc Picard' }).updateOne({ ship: 'USS Enterprise' }); // Using chaining syntax\n *     await Person.updateOne({ ship: 'USS Enterprise' }); // Updates first doc's `ship` property\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|'throw'} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this?.schema?.options?.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model?.schema?.options?.versionKey ?? null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * The `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise<Object>} casted and validated copy of `obj` if validation succeeded\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType?.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n  paths = new Set(paths);\n\n  try {\n    obj = this.castObject(obj);\n  } catch (err) {\n    error = err;\n    for (const key of Object.keys(error.errors || {})) {\n      paths.delete(key);\n    }\n  }\n\n  const promises = [];\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = obj;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      cur = cur[pieces[i]];\n    }\n\n    const val = get(obj, path, void 0);\n    promises.push(\n      schemaType.doValidate(val, context, { path: path }).catch(err => {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      })\n    );\n  }\n\n  await Promise.all(promises);\n  if (error != null) {\n    throw error;\n  }\n\n  return obj;\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n * - forceRepopulate: optional boolean, defaults to `true`. Set to `false` to prevent Mongoose from repopulating paths that are already populated\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Boolean} [options.forceRepopulate=true] Set to `false` to prevent Mongoose from repopulating paths that are already populated\n * @param {Boolean} [options.ordered=false] Set to `true` to execute any populate queries one at a time, as opposed to in parallel. Set this option to `true` if populating multiple paths or paths with multiple models in transactions.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  // normalized paths\n  paths = utils.populate(paths);\n\n  if (paths.length === 0) {\n    return docs;\n  }\n\n  // each path has its own query options and must be executed separately\n  if (paths.find(p => p.ordered)) {\n    // Populate in series, primarily for transactions because MongoDB doesn't support multiple operations on\n    // one transaction in parallel.\n    // Note that if _any_ path has `ordered`, we make the top-level populate `ordered` as well.\n    for (const path of paths) {\n      await _populatePath(this, docs, path);\n    }\n  } else {\n    // By default, populate in parallel\n    const promises = [];\n    for (const path of paths) {\n      promises.push(_populatePath(this, docs, path));\n    }\n    await Promise.all(promises);\n  }\n\n  return docs;\n};\n\n/*!\n * Populates `docs` for a single `populateOptions` instance.\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nasync function _populatePath(model, docs, populateOptions) {\n  if (populateOptions.strictPopulate == null) {\n    if (populateOptions._localModel?.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = populateOptions._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (populateOptions._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return;\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n  if (modelsMap instanceof MongooseError) {\n    throw modelsMap;\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else if (Array.isArray(select)) {\n        select = select.filter(field => field !== '-_id');\n      } else {\n        // preserve original select conditions by copying\n        select = { ...select };\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options?.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return;\n    }\n    // If no models and no docs to populate but we have a nested populate,\n    // probably a case of unnecessarily populating a non-ref path re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      return model.populate(docs, opts);\n    }\n    return;\n  }\n\n  // Track deferred populates per-param (per model) to avoid mixing them\n  const deferredPopulatesPerParam = new Map();\n\n  if (populateOptions.ordered) {\n    // Populate in series, primarily for transactions because MongoDB doesn't support multiple operations on\n    // one transaction in parallel.\n    for (let i = 0; i < params.length; i++) {\n      const arr = params[i];\n      const { docs, deferredPopulates } = await _execPopulateQuery.apply(null, arr);\n      vals = vals.concat(docs);\n      if (deferredPopulates.length > 0) {\n        deferredPopulatesPerParam.set(i, deferredPopulates);\n      }\n    }\n  } else {\n    // By default, populate in parallel\n    const promises = [];\n    for (const arr of params) {\n      promises.push(_execPopulateQuery.apply(null, arr));\n    }\n\n    const results = await Promise.all(promises);\n    for (let i = 0; i < results.length; i++) {\n      const { docs, deferredPopulates } = results[i];\n      vals = vals.concat(docs);\n      if (deferredPopulates.length > 0) {\n        deferredPopulatesPerParam.set(i, deferredPopulates);\n      }\n    }\n  }\n\n\n  for (const arr of params) {\n    const mod = arr[0];\n    const assignmentOpts = arr[3];\n    for (const val of vals) {\n      mod.options._childDocs.push(val);\n    }\n    _assign(model, vals, mod, assignmentOpts);\n  }\n\n  // Handle deferred populate for cases with per-document match functions.\n  // We defer populate so sift filtering can compare ObjectIds (not populated docs).\n  // This handles both explicit sub-populate and populate added by pre('find') hooks.\n  // Each param's deferred populates are tracked separately to avoid mixing them\n  // between different models (e.g., when using refPath with multiple model types).\n  if (deferredPopulatesPerParam.size > 0) {\n    for (let i = 0; i < params.length; i++) {\n      const arr = params[i];\n      const mod = arr[0];\n      if (!Array.isArray(mod.match)) {\n        continue;\n      }\n\n      const paramDeferredPopulates = deferredPopulatesPerParam.get(i);\n      if (!paramDeferredPopulates || paramDeferredPopulates.length === 0) {\n        continue;\n      }\n\n      // Get the assigned (filtered) children from parent docs\n      const childDocsToPopulate = [];\n      for (const doc of mod.docs) {\n        const childVal = doc.$__ != null ? doc.get(mod.options.path) : doc[mod.options.path];\n        if (Array.isArray(childVal)) {\n          childDocsToPopulate.push(...childVal);\n        } else if (childVal != null) {\n          childDocsToPopulate.push(childVal);\n        }\n      }\n\n      if (childDocsToPopulate.length > 0) {\n        for (const pop of paramDeferredPopulates) {\n          await mod.model.populate(childDocsToPopulate, pop);\n        }\n      }\n    }\n  }\n\n  for (const arr of params) {\n    removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n  }\n  for (const arr of params) {\n    const mod = arr[0];\n    if (mod.options?.options?._leanTransform) {\n      for (const doc of vals) {\n        mod.options.options._leanTransform(doc);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = {};\n  if (mod.options.skip !== undefined) {\n    queryOptions.skip = mod.options.skip;\n  }\n  if (mod.options.limit !== undefined) {\n    queryOptions.limit = mod.options.limit;\n  }\n  if (mod.options.perDocumentLimit !== undefined) {\n    queryOptions.perDocumentLimit = mod.options.perDocumentLimit;\n  }\n  Object.assign(queryOptions, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  // When there's a per-document match function, defer any populate (including from hooks)\n  // until after sift filtering, otherwise sift compares ObjectIds against populated docs.\n  if (Array.isArray(mod.match)) {\n    queryOptions._deferPopulate = true;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively.\n  // However, if we have a per-document match function (Array.isArray(mod.match)),\n  // defer sub-populate until after sift filtering, otherwise sift compares\n  // ObjectIds against already-populated docs and fails to match.\n  const shouldDeferSubPopulate = subPopulate && Array.isArray(mod.match);\n\n  // Prepare sub-populate options with necessary metadata (_fullPath, strictPopulate, _localModel).\n  // This must be done for both immediate and deferred sub-populate cases.\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n        // Set _localModel for deferred populates so strictPopulate works correctly\n        if (shouldDeferSubPopulate && pop._localModel == null) {\n          pop._localModel = mod.model;\n        }\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n      // Set _localModel for deferred populates so strictPopulate works correctly\n      if (shouldDeferSubPopulate && subPopulate._localModel == null) {\n        subPopulate._localModel = mod.model;\n      }\n    }\n  }\n\n  if (subPopulate && !shouldDeferSubPopulate) {\n    query.populate(subPopulate);\n  }\n\n  return query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      // Return both docs and any deferred populates (from hooks or explicit sub-populate)\n      const deferredPopulates = [];\n      if (query._deferredPopulate) {\n        deferredPopulates.push(...query._deferredPopulate);\n        delete query._deferredPopulate;\n      }\n      if (shouldDeferSubPopulate) {\n        deferredPopulates.push(subPopulate);\n      }\n      return { docs, deferredPopulates };\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._doc._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._doc._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            (rawDocs[key] instanceof Document ? String(rawDocs[key]._doc._id) : String(rawDocs[key]._id)) !== (val instanceof Document ? String(val._doc._id) : String(val._id))) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  const collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  model._applyQueryMiddleware();\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * If auto encryption is enabled, returns a ClientEncryption instance that is configured with the same settings that\n * Mongoose's underlying MongoClient is using.  If the client has not yet been configured, returns null.\n *\n * @returns {ClientEncryption | null}\n */\nModel.clientEncryption = function clientEncryption() {\n  const ClientEncryption = this.base.driver.get().ClientEncryption;\n  if (!ClientEncryption) {\n    throw new Error('The mongodb driver must be used to obtain a ClientEncryption object.');\n  }\n\n  const client = this.collection?.conn?.client;\n\n  if (!client) return null;\n\n  const autoEncryptionOptions = client.options.autoEncryption;\n\n  if (!autoEncryptionOptions) return null;\n\n  const {\n    keyVaultNamespace,\n    keyVaultClient,\n    kmsProviders,\n    credentialProviders,\n    proxyOptions,\n    tlsOptions\n  } = autoEncryptionOptions;\n  return new ClientEncryption(keyVaultClient ?? client,\n    { keyVaultNamespace, kmsProviders, credentialProviders, proxyOptions, tlsOptions }\n  );\n};\n\n/**\n * Update this model to use the new connection, including updating all internal\n * references and creating a new `Collection` instance using the new connection.\n * Not for external use, only used by `setDriver()` to ensure that you can still\n * call `setDriver()` after creating a model using `mongoose.model()`.\n *\n * @param {Connection} newConnection the new connection to use\n * @api private\n */\n\nModel.$__updateConnection = function $__updateConnection(newConnection) {\n  this.db = newConnection;\n  this.prototype.db = newConnection;\n  this.prototype[modelDbSymbol] = newConnection;\n\n  const collection = newConnection.collection(\n    this.collection.collectionName,\n    this.collection.opts\n  );\n\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n\n  this.collection = collection;\n  this.$__collection = collection;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Apply changes made to this model's schema after this model was compiled.\n * By default, adding virtuals and other properties to a schema after the model is compiled does nothing.\n * Call this function to apply virtuals and properties that were added later.\n *\n * #### Example:\n *\n *     const schema = new mongoose.Schema({ field: String });\n *     const TestModel = mongoose.model('Test', schema);\n *     TestModel.schema.virtual('myVirtual').get(function() {\n *       return this.field + ' from myVirtual';\n *     });\n *     const doc = new TestModel({ field: 'Hello' });\n *     doc.myVirtual; // undefined\n *\n *     TestModel.recompileSchema();\n *     doc.myVirtual; // 'Hello from myVirtual'\n *\n * @return {undefined}\n * @api public\n * @memberOf Model\n * @static\n * @method recompileSchema\n */\n\nModel.recompileSchema = function recompileSchema() {\n  this.prototype.$__setSchema(this.schema);\n\n  if (this.schema._applyDiscriminators != null) {\n    for (const disc of this.schema._applyDiscriminators.keys()) {\n      this.discriminator(disc, this.schema._applyDiscriminators.get(disc));\n    }\n  }\n\n  delete this.schema._defaultToObjectOptionsMap;\n\n  applyEmbeddedDiscriminators(this.schema, new WeakSet(), true);\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\n/**\n * Return the MongoDB namespace for this model as a string. The namespace is the database name, followed by '.', followed by the collection name.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     const TestModel = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     TestModel.namespace(); // 'mydb.tests'\n *\n * @api public\n */\n\nModel.namespace = function namespace() {\n  return this.db.name + '.' + this.collection.collectionName;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Applies query middleware from this model's schema to this model's\n * Query constructor.\n */\n\nModel._applyQueryMiddleware = function _applyQueryMiddleware() {\n  const Query = this.Query;\n  const queryMiddleware = this.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || utils.hasOwnKeys(contexts) === false;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n\n  Query.prototype._queryMiddleware = queryMiddleware;\n};\n\nfunction _getContexts(hook) {\n  const ret = {};\n  if (Object.hasOwn(hook, 'query')) {\n    ret.query = hook.query;\n  }\n  if (Object.hasOwn(hook, 'document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMC,YAAY,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACrD,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMG,qBAAqB,GAAGH,OAAO,CAAC,kBAAkB,CAAC;AACzD,MAAMI,YAAY,GAAGJ,OAAO,CAAC,QAAQ,CAAC,CAACI,YAAY;AACnD,MAAMC,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMM,sBAAsB,GAAGN,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMO,aAAa,GAAGP,OAAO,CAAC,eAAe,CAAC;AAC9C,MAAMQ,oBAAoB,GAAGR,OAAO,CAAC,yBAAyB,CAAC;AAC/D,MAAMS,mBAAmB,GAAGT,OAAO,CAAC,wBAAwB,CAAC;AAC7D,MAAMU,KAAK,GAAGV,OAAO,CAAC,SAAS,CAAC;AAChC,MAAMW,WAAW,GAAGX,OAAO,CAAC,uBAAuB,CAAC;AACpD,MAAMY,MAAM,GAAGZ,OAAO,CAAC,UAAU,CAAC;AAClC,MAAMa,eAAe,GAAGb,OAAO,CAAC,oBAAoB,CAAC;AACrD,MAAMc,YAAY,GAAGd,OAAO,CAAC,iBAAiB,CAAC;AAC/C,MAAMe,iBAAiB,GAAGf,OAAO,CAAC,sBAAsB,CAAC;AACzD,MAAMgB,mBAAmB,GAAGhB,OAAO,CAAC,kCAAkC,CAAC;AACvE,MAAMiB,eAAe,GAAGjB,OAAO,CAAC,oCAAoC,CAAC;AACrE,MAAMkB,mBAAmB,GAAGlB,OAAO,CAAC,qCAAqC,CAAC;AAC1E,MAAMmB,2BAA2B,GAAGnB,OAAO,CAAC,qDAAqD,CAAC;AAClG,MAAMoB,UAAU,GAAGpB,OAAO,CAAC,4BAA4B,CAAC;AACxD,MAAMqB,YAAY,GAAGrB,OAAO,CAAC,8BAA8B,CAAC;AAC5D,MAAMsB,eAAe,GAAGtB,OAAO,CAAC,sCAAsC,CAAC;AACvE,MAAMuB,gBAAgB,GAAGvB,OAAO,CAAC,mCAAmC,CAAC;AACrE,MAAMwB,oBAAoB,GAAGxB,OAAO,CAAC,wCAAwC,CAAC;AAC9E,MAAMyB,gBAAgB,GAAGzB,OAAO,CAAC,kCAAkC,CAAC;AACpE,MAAM0B,YAAY,GAAG1B,OAAO,CAAC,8BAA8B,CAAC;AAC5D,MAAM2B,qBAAqB,GAAG3B,OAAO,CAAC,oCAAoC,CAAC;AAC3E,MAAM4B,iBAAiB,GAAG5B,OAAO,CAAC,oCAAoC,CAAC;AACvE,MAAM6B,mBAAmB,GAAG7B,OAAO,CAAC,kCAAkC,CAAC;AACvE,MAAM8B,UAAU,GAAG9B,OAAO,CAAC,+BAA+B,CAAC;AAC3D,MAAM+B,aAAa,GAAG/B,OAAO,CAAC,+BAA+B,CAAC;AAC9D,MAAMgC,KAAK,GAAGhC,OAAO,CAAC,iBAAiB,CAAC;AACxC,MAAMiC,yBAAyB,GAAGjC,OAAO,CAAC,8CAA8C,CAAC;AACzF,MAAMkC,4BAA4B,GAAGlC,OAAO,CAAC,+CAA+C,CAAC;AAC7F,MAAMmC,yBAAyB,GAAGnC,OAAO,CAAC,qCAAqC,CAAC;AAChF,MAAMoC,6BAA6B,GAAGpC,OAAO,CAAC,uDAAuD,CAAC;AACtG,MAAMqC,aAAa,GAAGrC,OAAO,CAAC,+BAA+B,CAAC;AAC9D,MAAMsC,IAAI,GAAGtC,OAAO,CAAC,gBAAgB,CAAC;AACtC,MAAMuC,GAAG,GAAGvC,OAAO,CAAC,eAAe,CAAC;AACpC,MAAMwC,kBAAkB,GAAGxC,OAAO,CAAC,8BAA8B,CAAC;AAClE,MAAMyC,uBAAuB,GAAGzC,OAAO,CAAC,iDAAiD,CAAC;AAC1F,MAAM0C,uBAAuB,GAAG1C,OAAO,CAAC,4CAA4C,CAAC;AACrF,MAAM2C,SAAS,GAAG3C,OAAO,CAAC,qBAAqB,CAAC;AAChD,MAAM4C,uBAAuB,GAAG5C,OAAO,CAAC,WAAW,CAAC,CAAC4C,uBAAuB;AAC5E,MAAMC,gBAAgB,GAAG7C,OAAO,CAAC,oCAAoC,CAAC;AACtE,MAAM8C,YAAY,GAAG9C,OAAO,CAAC,gCAAgC,CAAC;AAC9D,MAAM+C,gBAAgB,GAAG/C,OAAO,CAAC,oCAAoC,CAAC;AACtE,MAAMgD,iBAAiB,GAAGhD,OAAO,CAAC,qCAAqC,CAAC;AACxE,MAAM;EACJiD,mBAAmB;EACnBC;AACF,CAAC,GAAGlD,OAAO,CAAC,qCAAqC,CAAC;AAClD,MAAMmD,iCAAiC,GAAGnD,OAAO,CAAC,qDAAqD,CAAC;AACxG,MAAMoD,uBAAuB,GAAGpD,OAAO,CAAC,8CAA8C,CAAC;AACvF,MAAMqD,eAAe,GAAGrD,OAAO,CAAC,oCAAoC,CAAC;AACrE,MAAMsD,aAAa,GAAGtD,OAAO,CAAC,yBAAyB,CAAC;AACxD,MAAMuD,4BAA4B,GAAGvD,OAAO,CAAC,kDAAkD,CAAC;AAChG,MAAMwD,oBAAoB,GAAGxD,OAAO,CAAC,sCAAsC,CAAC;AAC5E,MAAMyD,4BAA4B,GAAGzD,OAAO,CAAC,iDAAiD,CAAC;AAC/F,MAAM0D,aAAa,GAAG1D,OAAO,CAAC,8BAA8B,CAAC;AAC7D,MAAM;EAAE2D;AAAsB,CAAC,GAAG3D,OAAO,CAAC,iCAAiC,CAAC;AAC5E,MAAM4D,IAAI,GAAG5D,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAM6D,KAAK,GAAG7D,OAAO,CAAC,SAAS,CAAC;AAChC,MAAM8D,QAAQ,GAAG9D,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAM+D,+BAA+B,GAAG/D,OAAO,CAAC,iCAAiC,CAAC;AAClF,MAAMgE,mBAAmB,GAAGhE,OAAO,CAAC,wBAAwB,CAAC;AAC7D,MAAMiE,uBAAuB,GAAGjE,OAAO,CAAC,yCAAyC,CAAC;AAClF,MAAMkE,qBAAqB,GAAGC,MAAM,CAAC,2BAA2B,CAAC;AACjE,MAAMC,aAAa,GAAGD,MAAM,CAAC,mBAAmB,CAAC;AACjD,MAAM;EACJE,wBAAwB;EACxBC,kBAAkB;EAClBC;AACF,CAAC,GAAGvE,OAAO,CAAC,mBAAmB,CAAC;AAChC,MAAMwE,gBAAgB,GAAGL,MAAM,CAAC,2BAA2B,CAAC;AAE5D,MAAM;EAAEM,WAAW;EAAEC,aAAa;EAAEC;AAAY,CAAC,GAAGzE,QAAQ;AAE5D,MAAM0E,mBAAmB,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAElC,uBAAuB,EAAE;EACrEmC,IAAI,EAAE;AACR,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,KAAKA,CAACC,GAAG,EAAEC,MAAM,EAAEC,OAAO,EAAE;EACnC,IAAID,MAAM,YAAYtE,MAAM,EAAE;IAC5B,MAAM,IAAIwE,SAAS,CAAC,gEAAgE,GAClF,sEAAsE,GACtE,qBAAqB,CAAC;EAC1B;EACA,IAAI,OAAOH,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAIG,SAAS,CAAC,2DAA2D,GAC7E,sEAAsE,GACtE,qBAAqB,CAAC;EAC1B;EACAlF,QAAQ,CAACmF,IAAI,CAAC,IAAI,EAAEJ,GAAG,EAAEC,MAAM,EAAEC,OAAO,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAN,MAAM,CAACS,cAAc,CAACN,KAAK,CAACO,SAAS,EAAErF,QAAQ,CAACqF,SAAS,CAAC;AAC1DP,KAAK,CAACO,SAAS,CAACC,yBAAyB,GAAG,IAAI;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAR,KAAK,CAACO,SAAS,CAACE,EAAE;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAT,KAAK,CAACU,aAAa,GAAG,SAASA,aAAaA,CAACC,UAAU,EAAE;EACvD,IAAI,CAACA,UAAU,EAAE;IACf,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;EACjD;EACA,IAAI,IAAI,CAACH,EAAE,EAAE;IACX,OAAO,IAAI,CAACA,EAAE,CAACI,MAAM,CAAC,IAAI,CAACC,SAAS,CAAC;IACrC,OAAO,IAAI,CAACP,SAAS,CAACE,EAAE;IACxB,OAAO,IAAI,CAACF,SAAS,CAACnB,aAAa,CAAC;IACpC,OAAO,IAAI,CAACmB,SAAS,CAACQ,UAAU;IAChC,OAAO,IAAI,CAACR,SAAS,CAACS,WAAW;IACjC,OAAO,IAAI,CAACT,SAAS,CAACrB,qBAAqB,CAAC;EAC9C;EAEA,IAAI,CAACuB,EAAE,GAAGE,UAAU;EACpB,MAAMI,UAAU,GAAGJ,UAAU,CAACI,UAAU,CAAC,IAAI,CAACA,UAAU,CAACE,cAAc,EAAEN,UAAU,CAACR,OAAO,CAAC;EAC5F,IAAI,CAACI,SAAS,CAACQ,UAAU,GAAGA,UAAU;EACtC,IAAI,CAACR,SAAS,CAACS,WAAW,GAAGD,UAAU;EACvC,IAAI,CAACR,SAAS,CAACrB,qBAAqB,CAAC,GAAG6B,UAAU;EAClD,IAAI,CAACR,SAAS,CAACE,EAAE,GAAGE,UAAU;EAC9B,IAAI,CAACJ,SAAS,CAACnB,aAAa,CAAC,GAAGuB,UAAU;EAC1C,IAAI,CAACI,UAAU,GAAGA,UAAU;EAC5B,IAAI,CAACG,aAAa,GAAGH,UAAU;EAC/BJ,UAAU,CAACE,MAAM,CAAC,IAAI,CAACC,SAAS,CAAC,GAAG,IAAI;EAExC,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAd,KAAK,CAACO,SAAS,CAACQ,UAAU;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGAf,KAAK,CAACO,SAAS,CAACW,aAAa;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAlB,KAAK,CAACO,SAAS,CAACO,SAAS;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAd,KAAK,CAACO,SAAS,CAACY,MAAM;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAnB,KAAK,CAACO,SAAS,CAACa,aAAa;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEApB,KAAK,CAACqB,MAAM;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEArB,KAAK,CAACsB,WAAW;;AAEjB;AACA;AACA;;AAEA,SAASC,iBAAiBA,CAACtB,GAAG,EAAEuB,KAAK,EAAE;EACrC,IAAIvB,GAAG,CAACkB,MAAM,IAAI,IAAI,EAAE;IACtB;EACF;EACA,KAAK,MAAMM,GAAG,IAAI5B,MAAM,CAAC6B,IAAI,CAACzB,GAAG,CAACkB,MAAM,CAAC,EAAE;IACzCK,KAAK,CAACC,GAAG,CAAC,GAAGxB,GAAG,CAACkB,MAAM,CAACM,GAAG,CAAC;EAC9B;AACF;;AAEA;AACA;AACA;AACA,SAASE,kBAAkBA,CAAC1B,GAAG,EAAEE,OAAO,EAAE;EACxC,MAAMyB,WAAW,GAAG,CAAC,CAAC;EAEtBhF,iBAAiB,CAACqD,GAAG,CAAC4B,SAAS,EAAE1B,OAAO,CAAC;EACzC,IAAI,OAAOA,OAAO,CAAC2B,YAAY,KAAK,WAAW,EAAE;IAC/CF,WAAW,CAACE,YAAY,GAAG,CAAC,CAAC;IAC7B,IAAI,GAAG,IAAI3B,OAAO,CAAC2B,YAAY,EAAE;MAC/BF,WAAW,CAACE,YAAY,CAACC,CAAC,GAAG5B,OAAO,CAAC2B,YAAY,CAACC,CAAC;IACrD;IACA,IAAI,GAAG,IAAI5B,OAAO,CAAC2B,YAAY,EAAE;MAC/BF,WAAW,CAACE,YAAY,CAACE,CAAC,GAAG7B,OAAO,CAAC2B,YAAY,CAACE,CAAC;IACrD;IACA,IAAI,UAAU,IAAI7B,OAAO,CAAC2B,YAAY,EAAE;MACtCF,WAAW,CAACE,YAAY,CAACG,QAAQ,GAAG9B,OAAO,CAAC2B,YAAY,CAACG,QAAQ;IACnE;EACF,CAAC,MAAM;IACL,IAAI,GAAG,IAAI9B,OAAO,EAAE;MAClByB,WAAW,CAACG,CAAC,GAAG5B,OAAO,CAAC4B,CAAC;IAC3B;IACA,IAAI,GAAG,IAAI5B,OAAO,EAAE;MAClByB,WAAW,CAACI,CAAC,GAAG7B,OAAO,CAAC6B,CAAC;IAC3B;IACA,IAAI,UAAU,IAAI7B,OAAO,EAAE;MACzByB,WAAW,CAACK,QAAQ,GAAG9B,OAAO,CAAC8B,QAAQ;IACzC;EACF;EACA,IAAI,WAAW,IAAI9B,OAAO,EAAE;IAC1ByB,WAAW,CAACM,SAAS,GAAG/B,OAAO,CAAC+B,SAAS;EAC3C;EAEA,MAAMC,OAAO,GAAGlC,GAAG,CAACmC,QAAQ,CAAC,CAAC;EAC9B,MAAMC,iBAAiB,GAAGpC,GAAG,CAACb,aAAa,CAAC,CAACkD,IAAI,CAACC,4BAA4B,EAAEC,QAAQ,CAAC,CAAC;EAC1F,IAAIL,OAAO,IAAI,IAAI,EAAE;IACnBP,WAAW,CAACO,OAAO,GAAGA,OAAO;EAC/B,CAAC,MAAM,IAAI,CAACtC,MAAM,CAAC4C,MAAM,CAACtC,OAAO,EAAE,SAAS,CAAC,IAAIkC,iBAAiB,EAAEF,OAAO,IAAI,IAAI,EAAE;IACnF;IACAP,WAAW,CAACO,OAAO,GAAGE,iBAAiB,CAACF,OAAO;EACjD;EAEA,OAAOP,WAAW;AACpB;;AAEA;AACA;AACA;;AAEA5B,KAAK,CAACO,SAAS,CAACmC,OAAO,GAAG,eAAeA,OAAOA,CAACvC,OAAO,EAAE;EACxD,IAAI;IACF,MAAM,IAAI,CAACwC,qBAAqB,CAAC,MAAM,EAAExC,OAAO,EAAE,CAACA,OAAO,CAAC,CAAC;EAC9D,CAAC,CAAC,OAAOyC,KAAK,EAAE;IACd,MAAM,IAAI,CAACC,sBAAsB,CAAC,MAAM,EAAE1C,OAAO,EAAEyC,KAAK,CAAC;IACzD;EACF;EAGA,IAAIE,MAAM,GAAG,IAAI;EACjB,IAAItB,KAAK,GAAG,IAAI;EAChB,IAAI;IACF,MAAMI,WAAW,GAAGD,kBAAkB,CAAC,IAAI,EAAExB,OAAO,CAAC;IAErD,IAAI,IAAI,CAAC4C,MAAM,EAAE;MACf;MACA,MAAMC,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACrD,mBAAmB,CAAC;MAC9C,IAAI,CAACoD,GAAG,IAAI,CAAC,CAAC,EAAEE,GAAG,KAAK,KAAK,CAAC,EAAE;QAC9B;QACA;QACA;QACA;QACA;QACA,MAAM,IAAI3H,aAAa,CAAC,yCAAyC,CAAC;MACpE;MAEA,IAAI,CAAC4H,UAAU,CAAC,IAAI,EAAEH,GAAG,CAAC;MAC1B,IAAI,CAACI,QAAQ,CAAC,CAAC;MACfC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC;MACtB;MACA,IAAI,CAACC,GAAG,CAACC,SAAS,GAAG,IAAI;MACzBT,MAAM,GAAG,MAAM,IAAI,CAAC5D,qBAAqB,CAAC,CAACsE,SAAS,CAACR,GAAG,EAAEpB,WAAW,CAAC,CAAC6B,KAAK,CAACC,GAAG,IAAI;QAClFL,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC;QACrB,MAAMK,GAAG;MACX,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA;MACA,IAAI,CAACJ,GAAG,CAACC,SAAS,GAAG,KAAK;MAC1B,MAAMI,WAAW,GAAGC,KAAK,CAACC,OAAO,CAAC1D,OAAO,CAACwD,WAAW,CAAC,GAAGxD,OAAO,CAACwD,WAAW,GAAG,IAAI;MACnF,MAAMG,cAAc,GAAGH,WAAW,IAAI,IAAI,GAAG,IAAII,GAAG,CAACJ,WAAW,CAAC,GAAG,IAAI;MACxE,MAAMK,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACN,WAAW,EAAEG,cAAc,CAAC;MACxD,MAAMI,YAAY,GAAGP,WAAW,IAAI,IAAI,GAAIK,KAAK,IAAI,IAAI,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAACG,QAAQ,CAAC,CAAC,GAAI,IAAI;MAC9F,MAAMC,mBAAmB,GAAGT,WAAW,IAAI,IAAI,GAC3C9D,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAAC4B,GAAG,CAACe,WAAW,CAACC,aAAa,CAAC,SAAS,CAAC,CAAC,CAACC,MAAM,CAACC,IAAI,IAAI,CAACvI,eAAe,CAACuI,IAAI,EAAEV,cAAc,EAAEH,WAAW,CAAC,CAAC,GAC9H,IAAI;MAER,IAAIK,KAAK,EAAE;QACTxC,KAAK,GAAG,IAAI,CAACiD,QAAQ,CAACT,KAAK,CAAC,CAAC,CAAC,CAAC;QAC/BzC,iBAAiB,CAAC,IAAI,EAAEC,KAAK,CAAC;QAE9B,MAAMkD,MAAM,GAAGV,KAAK,CAAC,CAAC,CAAC;QACvB,IAAI,IAAI,CAACnC,SAAS,CAAC1B,OAAO,CAACrB,QAAQ,EAAE;UACnC,KAAK,MAAM6F,QAAQ,IAAI9E,MAAM,CAAC+E,MAAM,CAACF,MAAM,CAAC,EAAE;YAC5C,IAAIC,QAAQ,IAAI,IAAI,EAAE;cACpB;YACF;YACA,KAAK,MAAMlD,GAAG,IAAI5B,MAAM,CAAC6B,IAAI,CAACiD,QAAQ,CAAC,EAAE;cACvC,IAAIA,QAAQ,CAAClD,GAAG,CAAC,IAAI,IAAI,IAAI,OAAOkD,QAAQ,CAAClD,GAAG,CAAC,KAAK,QAAQ,EAAE;gBAC9D;cACF;cACA,IAAI,CAAC5C,KAAK,CAACgG,MAAM,CAACF,QAAQ,CAAClD,GAAG,CAAC,CAAC,EAAE;gBAChC;cACF;cACA3C,QAAQ,CAAC6F,QAAQ,CAAClD,GAAG,CAAC,CAAC;cACvB,IAAI5C,KAAK,CAACiG,UAAU,CAACH,QAAQ,CAAClD,GAAG,CAAC,CAAC,KAAK,KAAK,EAAE;gBAC7C,OAAOkD,QAAQ,CAAClD,GAAG,CAAC;gBACpBiD,MAAM,CAACK,MAAM,GAAGL,MAAM,CAACK,MAAM,IAAI,CAAC,CAAC;gBACnCL,MAAM,CAACK,MAAM,CAACtD,GAAG,CAAC,GAAG,CAAC;cACxB;YACF;UACF;QACF;;QAEA;QACA,IAAI,CAAC6B,GAAG,CAAC0B,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC,CAAC;QAC7C,IAAI,CAAC5B,QAAQ,CAAC,CAAC;QACf6B,mBAAmB,CAAC,IAAI,EAAEf,YAAY,EAAEE,mBAAmB,CAAC;QAE5Df,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC;QACtBP,MAAM,GAAG,MAAM,IAAI,CAAC5D,qBAAqB,CAAC,CAACgG,SAAS,CAAC1D,KAAK,EAAEkD,MAAM,EAAE9C,WAAW,CAAC,CAAC6B,KAAK,CAACC,GAAG,IAAI;UAC5F,IAAI,CAACyB,YAAY,CAAC,CAAC;UACnB,MAAMzB,GAAG;QACX,CAAC,CAAC;MACJ,CAAC,MAAM;QACLlC,KAAK,GAAG,IAAI,CAACiD,QAAQ,CAAC,CAAC;QACvBlD,iBAAiB,CAAC,IAAI,EAAEC,KAAK,CAAC;QAC9B,IAAI,IAAI,CAAC8B,GAAG,CAAC8B,OAAO,EAAE;UACpB,IAAI,CAACjC,UAAU,CAAC3B,KAAK,EAAEwC,KAAK,CAAC;QAC/B;QAEAzH,gBAAgB,CAAC,IAAI,CAACsF,SAAS,EAAED,WAAW,CAAC;QAC7CkB,MAAM,GAAG,MAAM,IAAI,CAACuC,WAAW,CAACtE,UAAU,CAACuE,OAAO,CAAC9D,KAAK,EAAE;UAAE,GAAGI,WAAW;UAAE2D,UAAU,EAAE;YAAErC,GAAG,EAAE;UAAE;QAAE,CAAC,CAAC,CAClGsC,IAAI,CAACC,cAAc,KAAK;UAAEC,YAAY,EAAE,CAACD,cAAc,GAAG,CAAC,GAAG;QAAE,CAAC,CAAC,CAAC;MACxE;IACF;EACF,CAAC,CAAC,OAAO/B,GAAG,EAAE;IACZ,MAAMd,KAAK,GAAG,IAAI,CAACf,SAAS,CAAC8D,2BAA2B,CAACjC,GAAG,CAAC;IAC7D,MAAM,IAAI,CAACb,sBAAsB,CAAC,MAAM,EAAE1C,OAAO,EAAEyC,KAAK,CAAC;IACzD;EACF;EAEA,IAAIgD,WAAW,GAAG,CAAC;EACnB,MAAM9D,YAAY,GAAG3B,OAAO,IAAI,IAAI,GAClCA,OAAO,CAAC2B,YAAY,IAAI,IAAI,GAC1B3B,OAAO,CAAC2B,YAAY,CAACC,CAAC,GACtB5B,OAAO,CAAC4B,CAAC,GACX,CAAC;EACH,IAAID,YAAY,KAAK,CAAC,EAAE;IACtB;IACA;IACA,IAAIgB,MAAM,IAAI,IAAI,EAAE;MAClB,IAAIc,KAAK,CAACC,OAAO,CAACf,MAAM,CAAC,EAAE;QACzB8C,WAAW,GAAG9C,MAAM,CAAC+C,MAAM;MAC7B,CAAC,MAAM,IAAI/C,MAAM,CAAC4C,YAAY,IAAI,IAAI,EAAE;QACtCE,WAAW,GAAG9C,MAAM,CAAC4C,YAAY;MACnC,CAAC,MAAM;QACLE,WAAW,GAAG9C,MAAM;MACtB;IACF;IAEA,MAAMgD,WAAW,GAAG,IAAI,CAACxC,GAAG,CAAC8B,OAAO;IACpC;IACA,IAAIU,WAAW,IAAI,CAAC,IAAI,CAACxC,GAAG,CAACC,SAAS,EAAE;MACtC,MAAMwC,WAAW,GAAGtG,WAAW,MAAMA,WAAW,GAAG,IAAI,CAAC6D,GAAG,CAAC8B,OAAO,CAAC;MACpE,IAAI,CAAC9B,GAAG,CAAC8B,OAAO,GAAGY,SAAS;MAC5B,MAAMvE,GAAG,GAAG,IAAI,CAACI,SAAS,CAAC1B,OAAO,CAAC8F,UAAU;MAC7C,MAAMb,OAAO,GAAG,IAAI,CAACc,WAAW,CAACzE,GAAG,CAAC,IAAI,CAAC;MAC1C,IAAImE,WAAW,IAAI,CAAC,EAAE;QACpB;QACA,IAAI,CAACT,YAAY,CAAC,CAAC;QACnB,MAAMzB,GAAG,GAAG,IAAI,CAACJ,GAAG,CAAC6C,aAAa,IAChC,IAAIrK,YAAY,CAAC,IAAI,EAAEsJ,OAAO,EAAE,IAAI,CAAC9B,GAAG,CAAC0B,aAAa,CAAC;QACzD,MAAM,IAAI,CAACnC,sBAAsB,CAAC,MAAM,EAAE1C,OAAO,EAAEuD,GAAG,CAAC;QACvD;MACF;;MAEA;MACA,IAAIqC,WAAW,EAAE;QACf,IAAI,CAACK,WAAW,CAAC3E,GAAG,EAAE2D,OAAO,GAAG,CAAC,CAAC;MACpC;IACF;IACA,IAAItC,MAAM,IAAI,IAAI,IAAI8C,WAAW,IAAI,CAAC,EAAE;MACtC,IAAI,CAACT,YAAY,CAAC,CAAC;MACnB,MAAMvC,KAAK,GAAG,IAAIzH,qBAAqB,CAACqG,KAAK,EAAE,IAAI,CAAC6D,WAAW,CAACvE,SAAS,EAAE8E,WAAW,EAAE9C,MAAM,CAAC;MAC/F,MAAM,IAAI,CAACD,sBAAsB,CAAC,MAAM,EAAE1C,OAAO,EAAEyC,KAAK,CAAC;MACzD;IACF;EACF;EACA,IAAI,CAACU,GAAG,CAAC+C,MAAM,GAAGL,SAAS;EAC3B,IAAI,CAAC1C,GAAG,CAACgD,UAAU,GAAG,CAAC,CAAC;EACxB,IAAI,CAACC,KAAK,CAAC,MAAM,EAAE,IAAI,EAAEX,WAAW,CAAC;EACrC,IAAI,CAACP,WAAW,CAACmB,IAAI,CAAC,MAAM,EAAE,IAAI,EAAEZ,WAAW,CAAC;EAChD,MAAM,IAAI,CAAC/C,sBAAsB,CAAC,MAAM,EAAE1C,OAAO,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS8E,mBAAmBA,CAAChF,GAAG,EAAEiE,YAAY,EAAEE,mBAAmB,EAAE;EACnE,IAAIF,YAAY,IAAI,IAAI,EAAE;IACxB;EACF;EAEA,KAAK,MAAMuC,KAAK,IAAIvC,YAAY,EAAE;IAChCjE,GAAG,CAACqD,GAAG,CAACe,WAAW,CAACqC,MAAM,CAACD,KAAK,CAACjC,IAAI,CAAC;IACtC,IAAIiC,KAAK,CAACE,KAAK,GAAGtH,wBAAwB,CAAC,EAAE;MAC3CoH,KAAK,CAACE,KAAK,CAACrH,kBAAkB,CAAC,GAAGmH,KAAK,CAACE,KAAK,CAACtH,wBAAwB,CAAC;MACvEoH,KAAK,CAACE,KAAK,CAACtH,wBAAwB,CAAC,GAAG,IAAI;IAC9C;EACF;EAEA,KAAK,MAAMmF,IAAI,IAAIJ,mBAAmB,EAAE;IACtCnE,GAAG,CAACqD,GAAG,CAACe,WAAW,CAACuC,OAAO,CAACpC,IAAI,CAAC;EACnC;AACF;;AAEA;AACA;AACA;;AAEA,SAASqC,oBAAoBA,CAAC5G,GAAG,EAAE+E,aAAa,EAAE8B,YAAY,EAAE;EAC9D,MAAMrF,GAAG,GAAGxB,GAAG,CAAC4B,SAAS,CAAC1B,OAAO,CAAC8F,UAAU;EAC5C,IAAI,CAACxE,GAAG,EAAE;IACR,OAAO,IAAI;EACb;EACA,MAAM2D,OAAO,GAAGnF,GAAG,CAACiG,WAAW,CAACzE,GAAG,CAAC,IAAI,CAAC;EACzC,OAAO,IAAI3F,YAAY,CAACmE,GAAG,EAAEmF,OAAO,EAAEJ,aAAa,CAAC+B,MAAM,CAACD,YAAY,CAAC,CAAC;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9G,KAAK,CAACO,SAAS,CAACyG,IAAI,GAAG,eAAeA,IAAIA,CAAC7G,OAAO,EAAE;EAClD,IAAI,OAAOA,OAAO,KAAK,UAAU,IAAI,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACvE,MAAM,IAAI1L,aAAa,CAAC,qDAAqD,CAAC;EAChF;EAEA,IAAI2L,YAAY;EAChB,IAAI,CAACC,GAAG,GAAG,MAAM;EAEjB,IAAI,IAAI,CAAC7D,GAAG,CAAC+C,MAAM,EAAE;IACnBa,YAAY,GAAG,IAAInL,iBAAiB,CAAC,IAAI,CAAC;EAC5C,CAAC,MAAM;IACL,IAAI,CAACuH,GAAG,CAAC+C,MAAM,GAAG,IAAItK,iBAAiB,CAAC,IAAI,CAAC;EAC/C;EAEAoE,OAAO,GAAG,IAAIxE,WAAW,CAACwE,OAAO,CAAC;EAClC,IAAIN,MAAM,CAAC4C,MAAM,CAACtC,OAAO,EAAE,SAAS,CAAC,EAAE;IACrC,IAAI,CAACiC,QAAQ,CAACjC,OAAO,CAACgC,OAAO,CAAC;EAChC;EACA,IAAI,IAAI,CAACmB,GAAG,CAAC8D,UAAU,IAAI,IAAI,EAAE;IAC/BjH,OAAO,CAACiH,UAAU,GAAG,IAAI,CAAC9D,GAAG,CAAC8D,UAAU;EAC1C;EACA,IAAI,CAAC9D,GAAG,CAAC6C,aAAa,GAAGU,oBAAoB,CAC3C,IAAI,EACJ,IAAI,CAAC7B,aAAa,CAAC,CAAC,EACpBnF,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAAC4B,GAAG,CAACe,WAAW,CAACC,aAAa,CAAC,SAAS,CAAC,CAC3D,CAAC;EAED,IAAI4C,YAAY,EAAE;IAChB,IAAI,CAACG,eAAe,CAACH,YAAY,CAAC;IAClC,MAAMA,YAAY;EACpB;EAEA,IAAI,CAAC5D,GAAG,CAAC1B,WAAW,GAAGzB,OAAO;EAE9B,IAAI;IACF,MAAM,IAAI,CAACuC,OAAO,CAACvC,OAAO,CAAC;EAC7B,CAAC,CAAC,OAAOyC,KAAK,EAAE;IACd,IAAI,CAACyE,eAAe,CAACzE,KAAK,CAAC;IAC3B,MAAMA,KAAK;EACb,CAAC,SAAS;IACR,IAAI,CAACU,GAAG,CAAC+C,MAAM,GAAG,IAAI;IACtB,IAAI,CAAC/C,GAAG,CAAC1B,WAAW,GAAG,IAAI;IAC3B,IAAI,CAAC0B,GAAG,CAAC6C,aAAa,GAAG,IAAI;IAC7B,IAAI,CAACgB,GAAG,GAAG,IAAI;EACjB;EAEA,OAAO,IAAI;AACb,CAAC;AAEDnH,KAAK,CAACO,SAAS,CAAC+G,KAAK,GAAGtH,KAAK,CAACO,SAAS,CAACyG,IAAI;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAhH,KAAK,CAACO,SAAS,CAAC4C,UAAU,GAAG,UAAS3B,KAAK,EAAEwC,KAAK,EAAE;EAClD,MAAMvC,GAAG,GAAG,IAAI,CAACI,SAAS,CAAC1B,OAAO,CAAC8F,UAAU;EAC7C,IAAIzE,KAAK,KAAK,IAAI,EAAE;IAClB;IACA,IAAIC,GAAG,EAAE;MACP/C,aAAa,CAACsF,KAAK,EAAEvC,GAAG,EAAE,CAAC,CAAC;MAC5B,IAAI,CAAC2E,WAAW,CAAC3E,GAAG,EAAE,CAAC,CAAC;IAC1B;IACA;EACF;EAEA,IAAIA,GAAG,KAAK,KAAK,EAAE;IACjB;EACF;;EAEA;;EAEA;EACA;EACA;EACA;;EAEA,IAAI,CAAC,IAAI,CAAC8F,aAAa,CAAC9F,GAAG,CAAC,EAAE;IAC5B;EACF;;EAEA;EACA,IAAI/B,aAAa,MAAMA,aAAa,GAAG,IAAI,CAAC4D,GAAG,CAAC8B,OAAO,CAAC,EAAE;IACxD,MAAMuB,KAAK,GAAG,IAAI,CAACT,WAAW,CAACzE,GAAG,CAAC;IACnC,IAAIkF,KAAK,IAAI,IAAI,EAAEnF,KAAK,CAACC,GAAG,CAAC,GAAGkF,KAAK;EACvC;EAEA,IAAIlH,WAAW,MAAMA,WAAW,GAAG,IAAI,CAAC6D,GAAG,CAAC8B,OAAO,CAAC,EAAE;IACpD,IAAI7H,GAAG,CAACyG,KAAK,CAACwD,IAAI,EAAE/F,GAAG,EAAE,IAAI,CAAC,IAAI,IAAI,EAAE;MACtC;MACA;MACA;MACA,EAAEuC,KAAK,CAACwD,IAAI,CAAC/F,GAAG,CAAC;IACnB,CAAC,MAAM;MACLuC,KAAK,CAACyD,IAAI,GAAGzD,KAAK,CAACyD,IAAI,IAAI,CAAC,CAAC;MAC7BzD,KAAK,CAACyD,IAAI,CAAChG,GAAG,CAAC,GAAG,CAAC;IACrB;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAzB,KAAK,CAACO,SAAS,CAACmH,SAAS,GAAG,SAASA,SAASA,CAAA,EAAG;EAC/C,IAAI,CAACpE,GAAG,CAAC8B,OAAO,GAAGzF,WAAW;EAC9B,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAK,KAAK,CAACO,SAAS,CAACkE,QAAQ,GAAG,SAASkD,MAAMA,CAACnG,KAAK,EAAE;EAChDA,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC;EAErB,IAAI,CAACA,KAAK,CAAC0B,GAAG,EAAE;IACd1B,KAAK,CAAC0B,GAAG,GAAG,IAAI,CAAC0E,IAAI,CAAC1E,GAAG;EAC3B;EAEA,IAAI,IAAI,CAAC0E,IAAI,CAAC1E,GAAG,KAAK,KAAK,CAAC,EAAE;IAC5B,MAAM,IAAI3H,aAAa,CAAC,2BAA2B,CAAC;EACtD;EAEA,OAAOiG,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAxB,KAAK,CAACO,SAAS,CAACsH,SAAS,GAAG,SAASA,SAASA,CAAC1H,OAAO,EAAE;EACtD,IAAI,OAAOA,OAAO,KAAK,UAAU,IAC7B,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACtC,MAAM,IAAI1L,aAAa,CAAC,0DAA0D,CAAC;EACrF;EAEA,IAAI,CAAC4E,OAAO,EAAE;IACZA,OAAO,GAAG,CAAC,CAAC;EACd;EAEA,IAAIN,MAAM,CAAC4C,MAAM,CAACtC,OAAO,EAAE,SAAS,CAAC,EAAE;IACrC,IAAI,CAACiC,QAAQ,CAACjC,OAAO,CAACgC,OAAO,CAAC;EAChC;EAEA,MAAM2F,IAAI,GAAG,IAAI;EACjB,MAAMtG,KAAK,GAAG,IAAI,CAACiD,QAAQ,CAAC,CAAC;EAC7B,MAAMsD,KAAK,GAAGD,IAAI,CAACzC,WAAW,CAACwC,SAAS,CAAC,CAAC;EAE1C,IAAI,IAAI,CAACzF,QAAQ,CAAC,CAAC,IAAI,IAAI,EAAE;IAC3B,IAAI,EAAE,SAAS,IAAI2F,KAAK,CAAC5H,OAAO,CAAC,EAAE;MACjC4H,KAAK,CAAC5H,OAAO,CAACgC,OAAO,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;IACzC;EACF;EAEA,MAAM4F,SAAS,GAAGrJ,qBAAqB,CAACwB,OAAO,EAAE,KAAK,CAAC;EACvD,MAAM8H,UAAU,GAAGtJ,qBAAqB,CAACwB,OAAO,EAAE,MAAM,CAAC;EAEzD4H,KAAK,CAACG,GAAG,CAAC,eAAeC,iBAAiBA,CAAA,EAAG;IAC3C,MAAMC,GAAG,GAAG,MAAMN,IAAI,CAACzC,WAAW,CAAC/D,WAAW,CAAC+G,OAAO,CAAC,WAAW,EAAEP,IAAI,EAAE,CAACA,IAAI,EAAE3H,OAAO,CAAC,EAAE;MAAEoE,MAAM,EAAEyD;IAAU,CAAC,CAAC;IACjH;IACA;IACA,IAAII,GAAG,CAAC,CAAC,CAAC,KAAKN,IAAI,IAAIM,GAAG,CAAC,CAAC,CAAC,KAAKjI,OAAO,EAAE;MACzC,MAAM,IAAIS,KAAK,CAAC,yDAAyD,CAAC;IAC5E;IACAmH,KAAK,CAACF,SAAS,CAACrG,KAAK,EAAErB,OAAO,CAAC;IAC/B;IACA;IACA,IAAI2H,IAAI,CAAC3G,MAAM,IAAI,IAAI,EAAE;MACvB,IAAI,CAACK,KAAK,CAACsG,IAAI,CAAC3G,MAAM,CAAC;IACzB;IACA,OAAOiH,GAAG;EACZ,CAAC,CAAC;EACFL,KAAK,CAACG,GAAG,CAAC,SAASI,kBAAkBA,CAAA,EAAG;IACtC,OAAOC,OAAO,CAACC,GAAG,CAACV,IAAI,CAACW,cAAc,CAAC,CAAC,CAACC,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACtD,WAAW,CAAC/D,WAAW,CAAC+G,OAAO,CAAC,WAAW,EAAEM,MAAM,EAAE,CAACA,MAAM,CAAC,EAAE;MAAEpE,MAAM,EAAEyD;IAAU,CAAC,CAAC,CAAC,CAAC;EACvJ,CAAC,CAAC;EACFD,KAAK,CAACG,GAAG,CAAC,SAASU,oBAAoBA,CAAA,EAAG;IACxC,IAAId,IAAI,CAACxE,GAAG,CAACuF,SAAS,EAAE;MACtB,MAAM,IAAIxN,MAAM,CAACyN,mBAAmB,CAAC,CAAC;IACxC;EACF,CAAC,CAAC;EACFf,KAAK,CAACgB,IAAI,CAAC,SAASC,mBAAmBA,CAAA,EAAG;IACxC,OAAOT,OAAO,CAACC,GAAG,CAACV,IAAI,CAACW,cAAc,CAAC,CAAC,CAACC,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACtD,WAAW,CAAC/D,WAAW,CAAC2H,QAAQ,CAAC,WAAW,EAAEN,MAAM,EAAE,CAACA,MAAM,CAAC,EAAE;MAAEpE,MAAM,EAAE0D;IAAW,CAAC,CAAC,CAAC,CAAC;EACzJ,CAAC,CAAC;EACFF,KAAK,CAACgB,IAAI,CAAC,SAASG,kBAAkBA,CAAA,EAAG;IACvC,OAAOpB,IAAI,CAACzC,WAAW,CAAC/D,WAAW,CAAC2H,QAAQ,CAAC,WAAW,EAAEnB,IAAI,EAAE,CAACA,IAAI,CAAC,EAAE;MAAEvD,MAAM,EAAE0D;IAAW,CAAC,CAAC;EACjG,CAAC,CAAC;EACFF,KAAK,CAACoB,SAAS,CAAC,SAASC,YAAYA,CAACtG,MAAM,EAAE;IAC5C,IAAIA,MAAM,EAAEuG,YAAY,GAAG,CAAC,EAAE;MAC5BvB,IAAI,CAACwB,UAAU,CAAC,IAAI,CAAC;IACvB;IACA,OAAOxG,MAAM;EACf,CAAC,CAAC;EAEF,OAAOiF,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/H,KAAK,CAACO,SAAS,CAACgJ,MAAM,GAAG,SAASA,MAAMA,CAACC,IAAI,EAAE;EAC7C,IAAIvC,SAAS,CAACpB,MAAM,KAAK,CAAC,EAAE;IAC1B,OAAO,IAAI,CAACR,WAAW;EACzB;EACA,OAAO,IAAI,CAACjG,aAAa,CAAC,CAACqK,KAAK,CAACD,IAAI,CAAC;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAxJ,KAAK,CAACO,SAAS,CAACkJ,KAAK,GAAGzJ,KAAK,CAACO,SAAS,CAACgJ,MAAM;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvJ,KAAK,CAAC0J,MAAM,GAAG,SAASA,MAAMA,CAACnF,MAAM,EAAEpE,OAAO,EAAE;EAC9CwJ,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC;EAC7B,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACtC,MAAM,IAAI1L,aAAa,CAAC,6CAA6C,CAAC;EACxE;EAEA,MAAMwM,KAAK,GAAG,IAAI,CAACzC,OAAO,CAACf,MAAM,CAAC,CAChCqF,MAAM,CAAC;IAAE1G,GAAG,EAAE;EAAE,CAAC,CAAC,CAClB2G,IAAI,CAAC,CAAC,CACNC,UAAU,CAAC3J,OAAO,CAAC;EAErB,OAAO4H,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/H,KAAK,CAAC3C,aAAa,GAAG,UAASmM,IAAI,EAAEO,MAAM,EAAE5J,OAAO,EAAE;EACpD,IAAIsJ,KAAK;EACT,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,KAAK,GAAGD,IAAI;IACZA,IAAI,GAAG3K,KAAK,CAACmL,eAAe,CAACP,KAAK,CAAC;IACnC,IAAI,EAAEA,KAAK,CAAClJ,SAAS,YAAYP,KAAK,CAAC,EAAE;MACvC,MAAM,IAAIzE,aAAa,CAAC,qBAAqB,GAAGiO,IAAI,GAAG,oBAAoB,CAAC;IAC9E;EACF;EAEArJ,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMwG,KAAK,GAAG9H,KAAK,CAACgG,MAAM,CAAC1E,OAAO,CAAC,GAAGA,OAAO,CAACwG,KAAK,GAAGxG,OAAO;EAC7D,MAAMnD,KAAK,GAAG,OAAOmD,OAAO,CAACnD,KAAK,KAAK,SAAS,GAAGmD,OAAO,CAACnD,KAAK,GAAG,IAAI;EACvE,MAAMiN,YAAY,GAAG,OAAO9J,OAAO,CAAC8J,YAAY,KAAK,SAAS,GAAG9J,OAAO,CAAC8J,YAAY,GAAG,IAAI;EAC5F,MAAMC,eAAe,GAAG,OAAO/J,OAAO,CAAC+J,eAAe,KAAK,SAAS,GAAG/J,OAAO,CAAC+J,eAAe,GAAG,KAAK;EAEtGP,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC;EAEpC,IAAI9K,KAAK,CAACsL,QAAQ,CAACJ,MAAM,CAAC,IAAI,CAACA,MAAM,CAACK,gBAAgB,EAAE;IACtDL,MAAM,GAAG,IAAInO,MAAM,CAACmO,MAAM,CAAC;EAC7B;EACA,IAAIA,MAAM,YAAYnO,MAAM,IAAIoB,KAAK,EAAE;IACrC+M,MAAM,GAAGA,MAAM,CAAC/M,KAAK,CAAC,CAAC;EACzB;EAEA+M,MAAM,GAAG1M,aAAa,CAAC,IAAI,EAAEmM,IAAI,EAAEO,MAAM,EAAEpD,KAAK,EAAEsD,YAAY,EAAE9J,OAAO,CAACkK,UAAU,EAAEH,eAAe,CAAC;EACpG,IAAI,IAAI,CAACzJ,EAAE,CAACI,MAAM,CAAC2I,IAAI,CAAC,IAAI,CAACO,MAAM,CAAC5J,OAAO,CAAC+J,eAAe,IAAI,CAACA,eAAe,EAAE;IAC/E,MAAM,IAAIzO,mBAAmB,CAAC+N,IAAI,CAAC;EACrC;EAEAO,MAAM,CAACO,oBAAoB,GAAG,IAAI;EAClCP,MAAM,CAACQ,qBAAqB,GAAG,IAAI;EAEnCd,KAAK,GAAG,IAAI,CAAChJ,EAAE,CAACgJ,KAAK,CAACA,KAAK,IAAID,IAAI,EAAEO,MAAM,EAAE,IAAI,CAAC7I,aAAa,CAACsI,IAAI,CAAC;EACrE,IAAI,CAACgB,cAAc,CAAChB,IAAI,CAAC,GAAGC,KAAK;EACjC,MAAMgB,CAAC,GAAG,IAAI,CAACD,cAAc,CAAChB,IAAI,CAAC;EACnC3J,MAAM,CAACS,cAAc,CAACmK,CAAC,CAAClK,SAAS,EAAE,IAAI,CAACA,SAAS,CAAC;EAClDV,MAAM,CAAC6K,cAAc,CAACD,CAAC,EAAE,eAAe,EAAE;IACxC9D,KAAK,EAAE,IAAI,CAAC7F,SAAS;IACrB6J,YAAY,EAAE,IAAI;IAClBC,QAAQ,EAAE;EACZ,CAAC,CAAC;;EAEF;EACAvO,YAAY,CAACoO,CAAC,EAAEV,MAAM,CAAC;EACvBrN,YAAY,CAAC+N,CAAC,EAAEV,MAAM,CAAC;EAEvB,IAAI,IAAI,CAACvK,gBAAgB,CAAC,IAAI,IAAI,EAAE;IAClC,KAAK,MAAMqL,QAAQ,IAAI,IAAI,CAACrL,gBAAgB,CAAC,EAAE;MAC7CqL,QAAQ,CAACL,cAAc,GAAGK,QAAQ,CAACL,cAAc,IAAI,CAAC,CAAC;MACvDK,QAAQ,CAACL,cAAc,CAAChB,IAAI,CAAC,GAC3BC,KAAK,CAACqB,UAAU,CAACrB,KAAK,CAAChJ,EAAE,EAAEsJ,MAAM,EAAEc,QAAQ,CAAC9J,UAAU,CAACyI,IAAI,CAAC;IAChE;EACF;EAEA,OAAOiB,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;;AAEA,SAASd,aAAaA,CAACoB,GAAG,EAAEC,MAAM,EAAE;EAClC;EACA;EACA,IAAID,GAAG,IAAI,IAAI,IAAIA,GAAG,KAAKE,MAAM,EAAE;IACjC,MAAM,IAAI1P,aAAa,CAAC,SAAS,GAAGyP,MAAM,GAAG,2BAA2B,GACtE,sDAAsD,GAAGA,MAAM,GAAG,MAAM,GACxE,sCAAsC,CAAC;EAC3C,CAAC,MAAM,IAAID,GAAG,CAACxL,WAAW,CAAC,IAAI,IAAI,EAAE;IACnC,MAAM,IAAIhE,aAAa,CAAC,SAAS,GAAGyP,MAAM,GAAG,2BAA2B,GACtE,iDAAiD,GACjD,aAAa,GAAGA,MAAM,GAAG,KAAK,CAAC;EACnC;AACF;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK,MAAME,CAAC,IAAI9P,YAAY,CAACmF,SAAS,EAAE;EACtCP,KAAK,CAACkL,CAAC,CAAC,GAAG9P,YAAY,CAACmF,SAAS,CAAC2K,CAAC,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAlL,KAAK,CAACmL,IAAI,GAAG,SAASA,IAAIA,CAAA,EAAG;EAC3BxB,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;EAC3B,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACtC,MAAM,IAAI1L,aAAa,CAAC,2CAA2C,CAAC;EACtE;EAEA,IAAI,CAACwO,MAAM,CAACvD,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;EAE9B,IAAI,IAAI,CAAC4E,KAAK,IAAI,IAAI,EAAE;IACtB,OAAO,IAAI,CAACA,KAAK;EACnB;EAEA,MAAMC,IAAI,GAAG,IAAI,CAAC5K,EAAE;EACpB,MAAM6K,cAAc,GAAG,MAAAA,CAAA,KAAW;IAChC,MAAMC,SAAS,GAAG1M,KAAK,CAAC2M,SAAS,CAC/B,WAAW,EACX,IAAI,CAACzB,MAAM,CAAC5J,OAAO,EACnBkL,IAAI,CAACI,MAAM,EACXJ,IAAI,CAAC/I,IAAI,CAACnC,OACZ,CAAC;IACD,IAAI,CAACoL,SAAS,EAAE;MACd;IACF;IACA,OAAO,MAAM,IAAI,CAACG,aAAa,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;EACvD,CAAC;EACD,MAAMC,oBAAoB,GAAG,MAAAA,CAAA,KAAW;IACtC,MAAMC,eAAe,GAAGhN,KAAK,CAAC2M,SAAS,CACrC,iBAAiB,EACjB,IAAI,CAACzB,MAAM,CAAC5J,OAAO,EACnBkL,IAAI,CAACI,MAAM,EACXJ,IAAI,CAAC/I,IAAI,CAACnC,OACZ,CAAC;IACD,IAAI,CAAC0L,eAAe,EAAE;MACpB;IACF;IAEA,OAAO,MAAM,IAAI,CAACC,mBAAmB,CAAC,CAAC;EACzC,CAAC;EACD,MAAMC,iBAAiB,GAAG,MAAAA,CAAA,KAAW;IACnC,IAAIC,UAAU,GAAGnN,KAAK,CAAC2M,SAAS,CAC9B,YAAY,EACZ,IAAI,CAACzB,MAAM,CAAC5J,OAAO,EACnBkL,IAAI,CAACI;IACL;IACA;IACF,CAAC;IACD,IAAIO,UAAU,IAAI,IAAI,EAAE;MACtB;MACA,MAAMX,IAAI,CAACY,eAAe,CAAC,IAAI,CAAC;MAChCD,UAAU,GAAGnN,KAAK,CAAC2M,SAAS,CAC1B,YAAY,EACZ,IAAI,CAACzB,MAAM,CAAC5J,OAAO,EACnBkL,IAAI,CAACI,MAAM,EACXJ,IAAI,CAAC/I,IAAI,CAACnC,OACZ,CAAC;IACH;IAEA,IAAI,CAAC6L,UAAU,EAAE;MACf;IACF;IAEA,OAAO,MAAM,IAAI,CAACE,gBAAgB,CAAC,CAAC;EACtC,CAAC;EAED,IAAI,CAACd,KAAK,GAAGW,iBAAiB,CAAC,CAAC,CAC9BvG,IAAI,CAAC,MAAM8F,cAAc,CAAC,CAAC,CAAC,CAC5B9F,IAAI,CAAC,MAAMoG,oBAAoB,CAAC,CAAC,CAAC;EAEpC,MAAMO,MAAM,GAAG,IAAI,CAACf,KAAK,CAAC3H,KAAK;EAC/B,MAAM2I,KAAK,GAAG,IAAI;EAClB,IAAI,CAAChB,KAAK,CAAC3H,KAAK,GAAG,YAAW;IAC5B2I,KAAK,CAACC,OAAO,GAAG,IAAI;IACpB,OAAOF,MAAM,CAACG,KAAK,CAACF,KAAK,CAAChB,KAAK,EAAEnE,SAAS,CAAC;EAC7C,CAAC;EAED,OAAO,IAAI,CAACmE,KAAK;AACnB,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEApL,KAAK,CAACkM,gBAAgB,GAAG,eAAeA,gBAAgBA,CAAC/L,OAAO,EAAE;EAChEwJ,aAAa,CAAC,IAAI,EAAE,kBAAkB,CAAC;EACvC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAC5E,MAAM,IAAI1L,aAAa,CAAC,uDAAuD,CAAC;EAClF;EAEA,MAAMyM,SAAS,GAAGrJ,qBAAqB,CAACwB,OAAO,EAAE,KAAK,CAAC;EACvD,MAAM8H,UAAU,GAAGtJ,qBAAqB,CAACwB,OAAO,EAAE,MAAM,CAAC;;EAEzD;EACA,IAAIA,OAAO,EAAEoM,UAAU,IAAI,IAAI,EAAE;IAC/BpM,OAAO,GAAG;MAAE,GAAGA;IAAQ,CAAC;IACxB,OAAOA,OAAO,CAACoM,UAAU;EAC3B;EAEA,CAACpM,OAAO,CAAC,GAAG,MAAM,IAAI,CAACqM,KAAK,CAACnE,OAAO,CAAC,kBAAkB,EAAE,IAAI,EAAE,CAAClI,OAAO,CAAC,EAAE;IAAEoE,MAAM,EAAEyD;EAAU,CAAC,CAAC,CAACvE,KAAK,CAACC,GAAG,IAAI;IAC5G,IAAIA,GAAG,YAAYrI,MAAM,CAACyN,mBAAmB,EAAE;MAC7C,OAAO,CAACpF,GAAG,CAAC;IACd;IACA,MAAMA,GAAG;EACX,CAAC,CAAC;EAEF,MAAM+I,iBAAiB,GAAG,IAAI,EAAE1C,MAAM,EAAE5J,OAAO,EAAEsM,iBAAiB;EAClE,IAAIA,iBAAiB,IAAI,IAAI,EAAE;IAC7BtM,OAAO,GAAGN,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE2M,iBAAiB,EAAEtM,OAAO,CAAC;EACzD;EAEA,MAAMuM,eAAe,GAAG,IAAI,EAAE3C,MAAM,EAAE5J,OAAO,EAAEwM,SAAS;EACxD,IAAID,eAAe,IAAI,IAAI,EAAE;IAC3BvM,OAAO,GAAGN,MAAM,CAACC,MAAM,CAAC;MAAE6M,SAAS,EAAED;IAAgB,CAAC,EAAEvM,OAAO,CAAC;EAClE;EACA,MAAMyM,MAAM,GAAG,IAAI,EAAE7C,MAAM,EAAE5J,OAAO,EAAEyM,MAAM;EAC5C,IAAIA,MAAM,IAAI,IAAI,EAAE;IAClB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;MAC9BzM,OAAO,GAAGN,MAAM,CAACC,MAAM,CAAC;QAAE8M,MAAM,EAAE,IAAI;QAAEC,IAAI,EAAED;MAAO,CAAC,EAAEzM,OAAO,CAAC;IAClE,CAAC,MAAM,IAAI,OAAOyM,MAAM,KAAK,QAAQ,EAAE;MACrCzM,OAAO,GAAGN,MAAM,CAACC,MAAM,CAAC;QAAE8M,MAAM,EAAE;MAAK,CAAC,EAAEA,MAAM,EAAEzM,OAAO,CAAC;IAC5D;EACF;EACA,MAAM2M,UAAU,GAAG,IAAI,EAAE/C,MAAM,EAAE5J,OAAO,EAAE2M,UAAU;EACpD,IAAIA,UAAU,IAAI,IAAI,EAAE;IACtB3M,OAAO,GAAGN,MAAM,CAACC,MAAM,CAAC;MAAEgN;IAAW,CAAC,EAAE3M,OAAO,CAAC;IAChD,IAAIA,OAAO,CAAC4M,kBAAkB,IAAI,IAAI,EAAE;MACtC;IAAA,CACD,MAAM,IAAI5M,OAAO,CAAC6M,OAAO,IAAI,IAAI,EAAE;MAClCnO,KAAK,CAACmO,OAAO,CAAC7M,OAAO,CAAC;IACxB,CAAC,MAAM,IAAI,IAAI,CAAC4J,MAAM,CAAC5J,OAAO,CAAC4M,kBAAkB,IAAI,IAAI,EAAE;MACzD5M,OAAO,CAAC4M,kBAAkB,GAAG,IAAI,CAAChD,MAAM,CAAC5J,OAAO,CAAC4M,kBAAkB;IACrE,CAAC,MAAM,IAAI,IAAI,CAAChD,MAAM,CAAC5J,OAAO,CAAC6M,OAAO,IAAI,IAAI,EAAE;MAC9C7M,OAAO,CAAC6M,OAAO,GAAG,IAAI,CAACjD,MAAM,CAAC5J,OAAO,CAAC6M,OAAO;MAC7CnO,KAAK,CAACmO,OAAO,CAAC7M,OAAO,CAAC;IACxB;EACF;EAEA,MAAM8M,cAAc,GAAG,IAAI,EAAElD,MAAM,EAAE5J,OAAO,EAAE8M,cAAc;EAC5D,IAAIA,cAAc,IAAI,IAAI,EAAE;IAC1B9M,OAAO,GAAGN,MAAM,CAACC,MAAM,CAAC;MAAEmN,cAAc,EAAE;QAAE,GAAGA,cAAc;QAAEC,MAAM,EAAE;MAAK;IAAE,CAAC,EAAE/M,OAAO,CAAC;EAC3F;EAEA,IAAI;IACF,IAAI,EAAEA,OAAO,YAAY9E,MAAM,CAACyN,mBAAmB,CAAC,EAAE;MACpD,MAAM,IAAI,CAACrI,EAAE,CAACyL,gBAAgB,CAAC,IAAI,CAAChL,aAAa,CAACD,cAAc,EAAEd,OAAO,CAAC;IAC5E;EACF,CAAC,CAAC,OAAOuD,GAAG,EAAE;IACZ,IAAIA,GAAG,IAAI,IAAI,KAAKA,GAAG,CAAC8F,IAAI,KAAK,kBAAkB,IAAI9F,GAAG,CAACyJ,IAAI,KAAK,EAAE,CAAC,EAAE;MACvE,MAAM,IAAI,CAACX,KAAK,CAACvD,QAAQ,CAAC,kBAAkB,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE;QAAErG,KAAK,EAAEc,GAAG;QAAEa,MAAM,EAAE0D;MAAW,CAAC,CAAC;IACjG;EACF;EAEA,MAAM,IAAI,CAACuE,KAAK,CAACvD,QAAQ,CAAC,kBAAkB,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC/H,aAAa,CAAC,EAAE;IAAEqD,MAAM,EAAE0D;EAAW,CAAC,CAAC;EAEjG,OAAO,IAAI,CAAC/G,aAAa;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAlB,KAAK,CAACoN,WAAW,GAAG,eAAeA,WAAWA,CAACjN,OAAO,EAAE;EACtDwJ,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC;EAClC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAC5E,MAAM,IAAI1L,aAAa,CAAC,kDAAkD,CAAC;EAC7E;EAEA,MAAMyQ,UAAU,GAAG7L,OAAO,EAAE6L,UAAU,IACpC,IAAI,CAACjC,MAAM,CAAC5J,OAAO,EAAE6L,UAAU,IAC/B,IAAI,CAACvL,EAAE,CAACgL,MAAM,CAACO,UAAU,IACzB,IAAI,CAACvL,EAAE,CAAC6B,IAAI,EAAEnC,OAAO,EAAE6L,UAAU,IACjC,IAAI;EAEN,IAAIA,UAAU,EAAE;IACd,IAAI;MACF,MAAM,IAAI,CAACE,gBAAgB,CAAC,CAAC;IAC/B,CAAC,CAAC,OAAOxI,GAAG,EAAE;MACZ,IAAIA,GAAG,IAAI,IAAI,KAAKA,GAAG,CAAC8F,IAAI,KAAK,kBAAkB,IAAI9F,GAAG,CAACyJ,IAAI,KAAK,EAAE,CAAC,EAAE;QACvE,MAAMzJ,GAAG;MACX;IACF;EACF;EAEA,MAAM2J,iBAAiB,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC;IAAEC,oBAAoB,EAAE;EAAK,CAAC,CAAC;EAChF,MAAMC,OAAO,GAAG,MAAM,IAAI,CAACC,YAAY,CAAC;IAAE,GAAGtN,OAAO;IAAEuN,MAAM,EAAEL,iBAAiB,CAACK;EAAO,CAAC,CAAC;EACzF,MAAM,IAAI,CAACC,aAAa,CAAC;IAAE,GAAGxN,OAAO;IAAEyN,QAAQ,EAAEP,iBAAiB,CAACO;EAAS,CAAC,CAAC;EAE9E,OAAOJ,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAxN,KAAK,CAAC6N,iBAAiB,GAAG,eAAeA,iBAAiBA,CAACC,WAAW,EAAE;EACtEnE,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC;EAExC,OAAO,MAAM,IAAI,CAACzI,aAAa,CAAC2M,iBAAiB,CAACC,WAAW,CAAC;AAChE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9N,KAAK,CAAC+N,iBAAiB,GAAG,eAAeA,iBAAiBA,CAACvE,IAAI,EAAEwE,UAAU,EAAE;EAC3ErE,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC;EAExC,OAAO,MAAM,IAAI,CAACzI,aAAa,CAAC6M,iBAAiB,CAACvE,IAAI,EAAEwE,UAAU,CAAC;AACrE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAhO,KAAK,CAACiO,eAAe,GAAG,eAAeA,eAAeA,CAACzE,IAAI,EAAE;EAC3DG,aAAa,CAAC,IAAI,EAAE,iBAAiB,CAAC;EAEtC,OAAO,MAAM,IAAI,CAACzI,aAAa,CAAC+M,eAAe,CAACzE,IAAI,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAxJ,KAAK,CAACkO,iBAAiB,GAAG,eAAeA,iBAAiBA,CAAC/N,OAAO,EAAE;EAClEwJ,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC;EAExC,MAAMwE,MAAM,GAAG,MAAM,IAAI,CAACjN,aAAa,CAACgN,iBAAiB,CAAC/N,OAAO,CAAC;EAElE,OAAO,MAAMgO,MAAM,CAACC,OAAO,CAAC,CAAC;AAC/B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEApO,KAAK,CAACsN,WAAW,GAAG,eAAeA,WAAWA,CAACnN,OAAO,EAAE;EACtD,IAAI,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAC5E,MAAM,IAAI1L,aAAa,CAAC,kDAAkD,CAAC;EAC7E;EAEA,MAAMkO,KAAK,GAAG,IAAI;EAElB,IAAI4E,SAAS,GAAG,MAAM5E,KAAK,CAAC6E,WAAW,CAAC,CAAC,CAAC7K,KAAK,CAACC,GAAG,IAAI;IACrD,IAAIA,GAAG,CAAC6K,QAAQ,IAAI,mBAAmB,EAAE;MACvC,OAAOvI,SAAS;IAClB;IACA,MAAMtC,GAAG;EACX,CAAC,CAAC;EACF,IAAI2K,SAAS,KAAKrI,SAAS,EAAE;IAC3BqI,SAAS,GAAG,EAAE;EAChB;EACAA,SAAS,GAAGpQ,mBAAmB,CAACwL,KAAK,EAAE4E,SAAS,CAAC;EAEjD,MAAMtE,MAAM,GAAGN,KAAK,CAACM,MAAM;EAC3B,MAAMyE,aAAa,GAAGtQ,uBAAuB,CAACuL,KAAK,EAAEM,MAAM,CAAC0E,OAAO,CAAC,CAAC,CAAC;EAEtE,MAAMf,MAAM,GAAGgB,gBAAgB,CAAC3E,MAAM,EAAEyE,aAAa,EAAEH,SAAS,CAAC;EACjE,MAAMT,QAAQ,GAAGe,kBAAkB,CAAC5E,MAAM,EAAEyE,aAAa,EAAEH,SAAS,EAAEX,MAAM,EAAEvN,OAAO,CAAC;EAEtF,OAAO;IAAEuN,MAAM;IAAEE;EAAS,CAAC;AAC7B,CAAC;AAED,SAASe,kBAAkBA,CAAC5E,MAAM,EAAEyE,aAAa,EAAEH,SAAS,EAAEX,MAAM,EAAEvN,OAAO,EAAE;EAC7E,MAAMyN,QAAQ,GAAG,EAAE;EACnB,MAAML,oBAAoB,GAAGpN,OAAO,EAAEoN,oBAAoB,IAAI,KAAK;EAEnE,KAAK,MAAM,CAACqB,qBAAqB,EAAEC,kBAAkB,CAAC,IAAIL,aAAa,EAAE;IACvE,IAAIM,KAAK,GAAG,KAAK;IAEjB,MAAM3O,OAAO,GAAGhC,iCAAiC,CAAC4L,MAAM,EAAE/M,KAAK,CAAC6R,kBAAkB,CAAC,CAAC;IAEpF,KAAK,MAAME,KAAK,IAAIV,SAAS,EAAE;MAC7B,IAAIxQ,gBAAgB,CAACkR,KAAK,CAAC,EAAE;QAC3B;MACF;MACA,IACEjR,YAAY,CAAC8Q,qBAAqB,EAAEzO,OAAO,EAAE4O,KAAK,CAAC,IACnD,CAACrB,MAAM,CAACsB,QAAQ,CAACD,KAAK,CAACvF,IAAI,CAAC,EAC5B;QACAsF,KAAK,GAAG,IAAI;QACZ;MACF;IACF;IAEA,IAAI,CAACA,KAAK,EAAE;MACV,IAAIvB,oBAAoB,EAAE;QACxBK,QAAQ,CAACqB,IAAI,CAAC,CAACL,qBAAqB,EAAEC,kBAAkB,CAAC,CAAC;MAC5D,CAAC,MAAM;QACLjB,QAAQ,CAACqB,IAAI,CAACL,qBAAqB,CAAC;MACtC;IACF;EACF;EAEA,OAAOhB,QAAQ;AACjB;AAEA,SAASc,gBAAgBA,CAAC3E,MAAM,EAAEyE,aAAa,EAAEH,SAAS,EAAE;EAC1D,MAAMX,MAAM,GAAG,EAAE;EAEjB,KAAK,MAAMwB,OAAO,IAAIb,SAAS,EAAE;IAC/B,IAAIS,KAAK,GAAG,KAAK;IACjB;IACA,IAAIjR,gBAAgB,CAACqR,OAAO,CAAC,EAAE;MAC7B;IACF;IACA;IACA,IAAIlR,iBAAiB,CAACkR,OAAO,EAAEnF,MAAM,CAAC5J,OAAO,CAAC,EAAE;MAC9C;IACF;IAEA,KAAK,MAAM,CAACyO,qBAAqB,EAAEC,kBAAkB,CAAC,IAAIL,aAAa,EAAE;MACvE,MAAMrO,OAAO,GAAGhC,iCAAiC,CAAC4L,MAAM,EAAE/M,KAAK,CAAC6R,kBAAkB,CAAC,CAAC;MACpFrS,oBAAoB,CAACoS,qBAAqB,EAAEzO,OAAO,EAAE4J,MAAM,CAAC5J,OAAO,CAAC;MAEpE,IAAIrC,YAAY,CAAC8Q,qBAAqB,EAAEzO,OAAO,EAAE+O,OAAO,CAAC,EAAE;QACzDJ,KAAK,GAAG,IAAI;QACZ;MACF;IACF;IAEA,IAAIA,KAAK,EAAE;MACT;IACF;IAEApB,MAAM,CAACuB,IAAI,CAACC,OAAO,CAAC1F,IAAI,CAAC;EAC3B;EAEA,OAAOkE,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA1N,KAAK,CAACyN,YAAY,GAAG,eAAeA,YAAYA,CAACtN,OAAO,EAAE;EACxDwJ,aAAa,CAAC,IAAI,EAAE,cAAc,CAAC;EACnC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAC5E,MAAM,IAAI1L,aAAa,CAAC,mDAAmD,CAAC;EAC9E;EACA,MAAMkO,KAAK,GAAG,IAAI;EAElB,IAAI7F,KAAK,CAACC,OAAO,CAAC1D,OAAO,EAAEuN,MAAM,CAAC,EAAE;IAClC,MAAMtF,GAAG,GAAG,MAAM+G,YAAY,CAAChP,OAAO,CAACuN,MAAM,EAAEjE,KAAK,EAAEtJ,OAAO,CAAC;IAC9D,OAAOiI,GAAG;EACZ;EAEA,MAAMA,GAAG,GAAG,MAAMqB,KAAK,CAAC6D,WAAW,CAAC,CAAC;EACrC,OAAO,MAAM6B,YAAY,CAAC/G,GAAG,CAACsF,MAAM,EAAEjE,KAAK,EAAEtJ,OAAO,CAAC;AACvD,CAAC;AAED,eAAegP,YAAYA,CAACzB,MAAM,EAAEjE,KAAK,EAAEtJ,OAAO,EAAE;EAClD,IAAIuN,MAAM,CAAC7H,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO,EAAE;EACX;EAEA,MAAM9E,UAAU,GAAG0I,KAAK,CAACvI,aAAa;EACtC,IAAIf,OAAO,EAAEiP,WAAW,EAAE;IACxB,MAAM7G,OAAO,CAACC,GAAG,CAACkF,MAAM,CAAChF,GAAG,CAAC2G,SAAS,IAAI;MACxC,OAAO5F,KAAK,CAAChJ,EAAE,CAACA,EAAE,CAAC6O,OAAO,CAAC;QACzBC,OAAO,EAAExO,UAAU,CAACE,cAAc;QAClC8N,KAAK,EAAE;UAAEvF,IAAI,EAAE6F,SAAS;UAAEG,MAAM,EAAE;QAAK;MACzC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;EACL,CAAC,MAAM;IACL,MAAMjH,OAAO,CAACC,GAAG,CAACkF,MAAM,CAAChF,GAAG,CAAC2G,SAAS,IAAItO,UAAU,CAAC0O,SAAS,CAACJ,SAAS,CAAC,CAAC,CAAC;EAC7E;EAEA,OAAO3B,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA1N,KAAK,CAACsO,WAAW,GAAG,eAAeA,WAAWA,CAAA,EAAG;EAC/C3E,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC;EAClC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACtC,MAAM,IAAI1L,aAAa,CAAC,kDAAkD,CAAC;EAC7E;EAEA,IAAI,IAAI,CAAC2F,aAAa,CAACwO,MAAM,EAAE;IAC7B,MAAM,IAAInH,OAAO,CAACoH,OAAO,IAAI;MAC3B,IAAI,CAACzO,aAAa,CAAC0O,QAAQ,CAACD,OAAO,CAAC;IACtC,CAAC,CAAC;EACJ;EAEA,OAAO,IAAI,CAACzO,aAAa,CAACoN,WAAW,CAAC,CAAC,CAACF,OAAO,CAAC,CAAC;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEApO,KAAK,CAAC0L,aAAa,GAAG,eAAeA,aAAaA,CAACvL,OAAO,EAAE;EAC1DwJ,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC;EACpC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAC5E,MAAM,IAAI1L,aAAa,CAAC,oDAAoD,CAAC;EAC/E;EAEA,MAAM,IAAIgN,OAAO,CAAC,CAACoH,OAAO,EAAEE,MAAM,KAAK;IACrCvE,cAAc,CAAC,IAAI,EAAEnL,OAAO,EAAGuD,GAAG,IAAK;MACrC,IAAIA,GAAG,IAAI,IAAI,EAAE;QACf,OAAOmM,MAAM,CAACnM,GAAG,CAAC;MACpB;MACAiM,OAAO,CAAC,CAAC;IACX,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3P,KAAK,CAAC2N,aAAa,GAAG,eAAeA,aAAaA,CAACxN,OAAO,EAAE;EAC1DwJ,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC;EAEpC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAC5E,MAAM,IAAI1L,aAAa,CAAC,oDAAoD,CAAC;EAC/E;EAEA,OAAO,IAAI,CAACmQ,aAAa,CAACvL,OAAO,CAAC;AACpC,CAAC;;AAGD;AACA;AACA;;AAEA,SAASmL,cAAcA,CAAC7B,KAAK,EAAEtJ,OAAO,EAAE2P,QAAQ,EAAE;EAChD,MAAMrB,OAAO,GAAG7K,KAAK,CAACC,OAAO,CAAC1D,OAAO,EAAEyN,QAAQ,CAAC,GAAGzN,OAAO,CAACyN,QAAQ,GAAGnE,KAAK,CAACM,MAAM,CAAC0E,OAAO,CAAC,CAAC;EAC5F,IAAIsB,UAAU;EAEd5P,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAM6P,IAAI,GAAG,SAAAA,CAAStM,GAAG,EAAE;IACzB,IAAIA,GAAG,IAAI,CAAC+F,KAAK,CAAC4C,OAAO,EAAE;MACzB5C,KAAK,CAACjD,IAAI,CAAC,OAAO,EAAE9C,GAAG,CAAC;IAC1B;IACA+F,KAAK,CAACjD,IAAI,CAAC,OAAO,EAAE9C,GAAG,IAAIqM,UAAU,CAAC;IACtCD,QAAQ,IAAIA,QAAQ,CAACpM,GAAG,IAAIqM,UAAU,CAAC;EACzC,CAAC;EAED,KAAK,MAAMhB,KAAK,IAAIN,OAAO,EAAE;IAC3B,IAAI5Q,gBAAgB,CAACkR,KAAK,CAAC,EAAE;MAC3BlQ,KAAK,CAACoR,IAAI,CAAC,uDAAuD,GAChE,cAAc,GAAGxG,KAAK,CAAC3I,SAAS,GAAG,KAAK,GACxC,kEAAkE,GAClE,iCAAiC,CAAC;IACtC;EACF;;EAEA;EACA,MAAMoP,WAAW,GAAG,EAAE;EACtB,KAAK,MAAMnB,KAAK,IAAIN,OAAO,EAAE;IAC3B,MAAMvO,MAAM,GAAG6O,KAAK,CAAC,CAAC,CAAC;IACvB,MAAMoB,YAAY,GAAGpB,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAIoB,YAAY,CAAC3G,IAAI,IAAI,IAAI,EAAE;MAC7B,KAAK,MAAM4G,aAAa,IAAIF,WAAW,EAAE;QACvC,IAAIE,aAAa,CAAC,CAAC,CAAC,CAAC5G,IAAI,IAAI,IAAI,IAAIzL,gBAAgB,CAACqS,aAAa,CAAC,CAAC,CAAC,EAAElQ,MAAM,CAAC,EAAE;UAC/ErB,KAAK,CAACoR,IAAI,CAAC,sCAAsC,GAAGI,IAAI,CAACC,SAAS,CAACpQ,MAAM,CAAC,GACxE,cAAc,GAAGuJ,KAAK,CAAC3I,SAAS,GAAG,KAAK,GACxC,yFAAyF,GACzF,+CAA+C,CAAC;UAClD;QACF;MACF;IACF;IACAoP,WAAW,CAACjB,IAAI,CAACF,KAAK,CAAC;EACzB;EAEA,IAAI,CAACN,OAAO,CAAC5I,MAAM,EAAE;IACnBlI,SAAS,CAAC,YAAW;MACnBqS,IAAI,CAAC,CAAC;IACR,CAAC,CAAC;IACF;EACF;EACA;;EAEA,MAAMO,eAAe,GAAG,SAAAA,CAAS7M,GAAG,EAAExD,MAAM,EAAEC,OAAO,EAAEqJ,IAAI,EAAE;IAC3DC,KAAK,CAACjD,IAAI,CAAC,mBAAmB,EAAE9C,GAAG,EAAExD,MAAM,EAAEC,OAAO,EAAEqJ,IAAI,CAAC;EAC7D,CAAC;EACD,MAAMgH,gBAAgB,GAAG,SAAAA,CAAStQ,MAAM,EAAEC,OAAO,EAAE;IACjDsJ,KAAK,CAACjD,IAAI,CAAC,oBAAoB,EAAEtG,MAAM,EAAEC,OAAO,CAAC;EACnD,CAAC;EAED,MAAMsQ,UAAU,GAAGhH,KAAK,CAACM,MAAM,CAAC2G,WAAW;EAC3C,MAAMC,iBAAiB,GAAGF,UAAU,GAAGA,UAAU,CAAChC,OAAO,CAAC,CAAC,GAAG,EAAE;EAEhE9Q,SAAS,CAAC,YAAW;IACnB;IACA,IAAIwC,OAAO,CAACwL,UAAU,IAAI,CAAClC,KAAK,CAAC1I,UAAU,CAACA,UAAU,EAAE;MACtD0I,KAAK,CAAC1I,UAAU,CAAC6O,QAAQ,CAACgB,MAAM,EAAE,EAAE,CAAC;IACvC,CAAC,MAAM;MACLA,MAAM,CAAC,CAAC;IACV;EACF,CAAC,CAAC;EAGF,SAASA,MAAMA,CAAA,EAAG;IAChB,IAAIzQ,OAAO,CAACwL,UAAU,EAAE;MACtB,IAAIlC,KAAK,CAACM,MAAM,CAAC5J,OAAO,CAACoL,SAAS,KAAK,KAAK,IACvC9B,KAAK,CAACM,MAAM,CAAC5J,OAAO,CAACoL,SAAS,IAAI,IAAI,IAAI9B,KAAK,CAAChJ,EAAE,CAACgL,MAAM,CAACF,SAAS,KAAK,KAAM,EAAE;QACnF,OAAOyE,IAAI,CAAC,CAAC;MACf;IACF;IAEA,MAAMjB,KAAK,GAAGN,OAAO,CAACoC,KAAK,CAAC,CAAC;IAC7B,IAAI,CAAC9B,KAAK,EAAE;MACV,OAAOiB,IAAI,CAAC,CAAC;IACf;IACA,IAAI7P,OAAO,CAACwL,UAAU,IAAIoD,KAAK,CAAC,CAAC,CAAC,CAAC+B,UAAU,KAAK,KAAK,EAAE;MACvD,OAAOF,MAAM,CAAC,CAAC;IACjB;IAEA,IAAID,iBAAiB,CAACI,IAAI,CAAC7F,CAAC,IAAIrM,KAAK,CAACmS,SAAS,CAAC9F,CAAC,EAAE6D,KAAK,CAAC,CAAC,EAAE;MAC1D,OAAO6B,MAAM,CAAC,CAAC;IACjB;IAEA,MAAMK,WAAW,GAAGjU,KAAK,CAAC+R,KAAK,CAAC,CAAC,CAAC,CAAC;IACnC,MAAMoB,YAAY,GAAGnT,KAAK,CAAC+R,KAAK,CAAC,CAAC,CAAC,CAAC;IAEpC,OAAOoB,YAAY,CAACW,UAAU;IAC9B3S,iCAAiC,CAACsL,KAAK,CAACM,MAAM,EAAEoG,YAAY,CAAC;IAC7DvT,iBAAiB,CAAC6M,KAAK,CAACM,MAAM,EAAEoG,YAAY,CAAC;IAC7C3T,oBAAoB,CAACyU,WAAW,EAAEd,YAAY,EAAE1G,KAAK,CAACM,MAAM,CAAC5J,OAAO,CAAC;IAErEqQ,gBAAgB,CAACS,WAAW,EAAE9Q,OAAO,CAAC;;IAEtC;IACA,IAAI+Q,OAAO,GAAG,IAAI;IAClB,IAAI;MACFA,OAAO,GAAGzH,KAAK,CAAC1I,UAAU,CAACoQ,WAAW,CAACF,WAAW,EAAEd,YAAY,CAAC;IACnE,CAAC,CAAC,OAAOzM,GAAG,EAAE;MACZ,IAAI,CAACqM,UAAU,EAAE;QACfA,UAAU,GAAGrM,GAAG;MAClB;MACA,IAAI,CAAC+F,KAAK,CAAC4C,OAAO,EAAE;QAClB5C,KAAK,CAACjD,IAAI,CAAC,OAAO,EAAE9C,GAAG,CAAC;MAC1B;MAEA6M,eAAe,CAAC7M,GAAG,EAAEuN,WAAW,EAAEd,YAAY,CAAC;MAC/CS,MAAM,CAAC,CAAC;MACR;IACF;IAEAM,OAAO,CAAC1L,IAAI,CACVgE,IAAI,IAAI;MACN+G,eAAe,CAAC,IAAI,EAAEU,WAAW,EAAEd,YAAY,EAAE3G,IAAI,CAAC;MACtDoH,MAAM,CAAC,CAAC;IACV,CAAC,EACDlN,GAAG,IAAI;MACL,IAAI,CAACqM,UAAU,EAAE;QACfA,UAAU,GAAGrM,GAAG;MAClB;MACA,IAAI,CAAC+F,KAAK,CAAC4C,OAAO,EAAE;QAClB5C,KAAK,CAACjD,IAAI,CAAC,OAAO,EAAE9C,GAAG,CAAC;MAC1B;MAEA6M,eAAe,CAAC7M,GAAG,EAAEuN,WAAW,EAAEd,YAAY,CAAC;MAC/CS,MAAM,CAAC,CAAC;IACV,CACF,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA5Q,KAAK,CAAC8L,mBAAmB,GAAG,eAAeA,mBAAmBA,CAAA,EAAG;EAC/DnC,aAAa,CAAC,IAAI,EAAE,qBAAqB,CAAC;EAC1C,MAAMyH,OAAO,GAAG,EAAE;EAClB,KAAK,MAAMC,WAAW,IAAI,IAAI,CAACtH,MAAM,CAACuH,cAAc,EAAE;IACpDF,OAAO,CAACnC,IAAI,CAAC,MAAM,IAAI,CAACpB,iBAAiB,CAACwD,WAAW,CAAC,CAAC;EACzD;EACA,OAAOD,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEApR,KAAK,CAAC+J,MAAM;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/J,KAAK,CAACS,EAAE;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAT,KAAK,CAACe,UAAU;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,KAAK,CAACkB,aAAa;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAlB,KAAK,CAACsC,IAAI;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAtC,KAAK,CAACwK,cAAc;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxK,KAAK,CAACuR,gBAAgB,GAAG,SAASA,gBAAgBA,CAACrR,MAAM,EAAEsR,iBAAiB,EAAE;EAC5E7H,aAAa,CAAC,IAAI,EAAE,kBAAkB,CAAC;EAEvC,MAAM8H,SAAS,GAAGA,CAAChQ,GAAG,EAAEkF,KAAK,KAAK;IAChC,IAAI+K,KAAK;IACT,MAAMC,UAAU,GAAG,EAAE;IACrB,MAAMC,SAAS,GAAGnQ,GAAG,CAACoQ,KAAK,CAAC,GAAG,CAAC;IAChC,IAAIC,aAAa,GAAG,IAAI,CAAC/H,MAAM;IAC/B,KAAK,MAAMmB,CAAC,IAAI0G,SAAS,EAAE;MACzB,MAAMpI,IAAI,GAAGoI,SAAS,CAAC1G,CAAC,CAAC;MACzB,IAAI4G,aAAa,EAAEC,OAAO,CAACvI,IAAI,CAAC,EAAE;QAChCkI,KAAK,GAAGI,aAAa,CAACC,OAAO,CAACvI,IAAI,CAAC;QACnC,IAAIgI,iBAAiB,IAAIE,KAAK,IAAIxR,MAAM,EAAE;UACxC,MAAM,IAAI3E,aAAa,CAAC,mCAAmCiO,IAAI,oBAAoBkI,KAAK,GAAG,CAAC;QAC9F;QACA;QACAC,UAAU,CAAC1C,IAAI,CAACyC,KAAK,CAAC;MACxB,CAAC,MAAM;QACLA,KAAK,GAAGlI,IAAI;QACZ;QACAmI,UAAU,CAAC1C,IAAI,CAACzF,IAAI,CAAC;MACvB;;MAEA;MACA,IAAIsI,aAAa,EAAEE,KAAK,CAACN,KAAK,CAAC,EAAE;QAC/BI,aAAa,GAAGA,aAAa,CAACE,KAAK,CAACN,KAAK,CAAC,CAAC3H,MAAM;MACnD,CAAC,MAEC+H,aAAa,GAAG,IAAI;IACxB;IAEA,MAAMG,aAAa,GAAGN,UAAU,CAACO,IAAI,CAAC,GAAG,CAAC;IAC1C,IAAIhS,MAAM,YAAYiS,GAAG,EACvBjS,MAAM,CAACkS,GAAG,CAACH,aAAa,EAAEtL,KAAK,CAAC,CAAC,KAEjCzG,MAAM,CAAC+R,aAAa,CAAC,GAAGtL,KAAK;IAE/B,IAAIsL,aAAa,KAAKxQ,GAAG,EAAE;MACzB;MACA,IAAIvB,MAAM,YAAYiS,GAAG,EAAE;QACzB;QACAjS,MAAM,CAACmS,MAAM,CAAC5Q,GAAG,CAAC;MACpB,CAAC,MAAM;QACL;QACA,OAAOvB,MAAM,CAACuB,GAAG,CAAC,CAAC,CAAC;MACtB;IACF;IACA,OAAOvB,MAAM;EACf,CAAC;EAED,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B;IACA,IAAIA,MAAM,YAAYiS,GAAG,EAAE;MACzB;MACA,KAAK,MAAMG,KAAK,IAAI,IAAIH,GAAG,CAACjS,MAAM,CAAC,EAAE;QACnCA,MAAM,GAAGuR,SAAS,CAACa,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;MACxC;IACF,CAAC,MAAM;MACL;MACA,KAAK,MAAM7Q,GAAG,IAAI5B,MAAM,CAAC6B,IAAI,CAACxB,MAAM,CAAC,EAAE;QACrCA,MAAM,GAAGuR,SAAS,CAAChQ,GAAG,EAAEvB,MAAM,CAACuB,GAAG,CAAC,CAAC;QACpC,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAClB,IAAImC,KAAK,CAACC,OAAO,CAAC3D,MAAM,CAACuB,GAAG,CAAC,CAAC,EAAE;YAC9B,KAAK,MAAMyJ,CAAC,IAAIhL,MAAM,CAACuB,GAAG,CAAC,EAAE;cAC3B;cACAvB,MAAM,CAACuB,GAAG,CAAC,CAACyJ,CAAC,CAAC,GAAG,IAAI,CAACqG,gBAAgB,CAACrR,MAAM,CAACuB,GAAG,CAAC,CAACyJ,CAAC,CAAC,CAAC;YACxD;UACF,CAAC,MAAM;YACL,IAAI,CAACqG,gBAAgB,CAACrR,MAAM,CAACuB,GAAG,CAAC,CAAC;UACpC;QACF;MACF;IACF;IAEA,OAAOvB,MAAM;EACf,CAAC,MAAM;IACL;IACA,OAAOA,MAAM;EACf;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAF,KAAK,CAAC6H,SAAS,GAAG,SAASA,SAASA,CAAC0K,UAAU,EAAEpS,OAAO,EAAE;EACxDwJ,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;EAEhC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,0DAA0D,CAAC;EACrF;EAEA,MAAMiX,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC1I,UAAU,CAAC3J,OAAO,CAAC;EAEtB,OAAOqS,EAAE,CAAC3K,SAAS,CAAC0K,UAAU,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvS,KAAK,CAACyS,UAAU,GAAG,SAASA,UAAUA,CAACF,UAAU,EAAEpS,OAAO,EAAE;EAC1DwJ,aAAa,CAAC,IAAI,EAAE,YAAY,CAAC;EAEjC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,iDAAiD,CAAC;EAC5E;EAEA,MAAMiX,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC1I,UAAU,CAAC3J,OAAO,CAAC;EAEtB,OAAOqS,EAAE,CAACC,UAAU,CAACF,UAAU,CAAC;AAClC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvS,KAAK,CAAC+Q,IAAI,GAAG,SAASA,IAAIA,CAACwB,UAAU,EAAEhN,UAAU,EAAEpF,OAAO,EAAE;EAC1DwJ,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;EAC3B,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACxJ,MAAM,IAAI1L,aAAa,CAAC,2CAA2C,CAAC;EACtE;EAEA,MAAMiX,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC5I,MAAM,CAACrE,UAAU,CAAC;EACrBiN,EAAE,CAAC1I,UAAU,CAAC3J,OAAO,CAAC;EAEtB,OAAOqS,EAAE,CAACzB,IAAI,CAACwB,UAAU,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvS,KAAK,CAAC0S,QAAQ,GAAG,SAASA,QAAQA,CAACC,EAAE,EAAEpN,UAAU,EAAEpF,OAAO,EAAE;EAC1DwJ,aAAa,CAAC,IAAI,EAAE,UAAU,CAAC;EAC/B,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,+CAA+C,CAAC;EAC1E;EAEA,OAAO,IAAI,CAAC+J,OAAO,CAAC;IAAEpC,GAAG,EAAEyP;EAAG,CAAC,EAAEpN,UAAU,EAAEpF,OAAO,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAACsF,OAAO,GAAG,SAASA,OAAOA,CAACiN,UAAU,EAAEhN,UAAU,EAAEpF,OAAO,EAAE;EAChEwJ,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC;EAC9B,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,8CAA8C,CAAC;EACzE;EAEA,MAAMiX,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC5I,MAAM,CAACrE,UAAU,CAAC;EACrBiN,EAAE,CAAC1I,UAAU,CAAC3J,OAAO,CAAC;EAEtB,OAAOqS,EAAE,CAAClN,OAAO,CAACiN,UAAU,CAAC;AAC/B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvS,KAAK,CAAC4S,sBAAsB,GAAG,SAASA,sBAAsBA,CAACzS,OAAO,EAAE;EACtEwJ,aAAa,CAAC,IAAI,EAAE,wBAAwB,CAAC;EAE7C,MAAM6I,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAE3D,OAAOsR,EAAE,CAACI,sBAAsB,CAACzS,OAAO,CAAC;AAC3C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAAC6S,cAAc,GAAG,SAASA,cAAcA,CAACN,UAAU,EAAEpS,OAAO,EAAE;EAClEwJ,aAAa,CAAC,IAAI,EAAE,gBAAgB,CAAC;EACrC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,qDAAqD,CAAC;EAChF;EAEA,MAAMiX,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3D,IAAIf,OAAO,IAAI,IAAI,EAAE;IACnBqS,EAAE,CAAC1I,UAAU,CAAC3J,OAAO,CAAC;EACxB;EAEA,OAAOqS,EAAE,CAACK,cAAc,CAACN,UAAU,CAAC;AACtC,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvS,KAAK,CAAC8S,QAAQ,GAAG,SAASA,QAAQA,CAACR,KAAK,EAAEC,UAAU,EAAEpS,OAAO,EAAE;EAC7DwJ,aAAa,CAAC,IAAI,EAAE,UAAU,CAAC;EAC/B,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,+CAA+C,CAAC;EAC1E;EAEA,MAAMiX,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3D,IAAIf,OAAO,IAAI,IAAI,EAAE;IACnBqS,EAAE,CAAC1I,UAAU,CAAC3J,OAAO,CAAC;EACxB;EAEA,OAAOqS,EAAE,CAACM,QAAQ,CAACR,KAAK,EAAEC,UAAU,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvS,KAAK,CAACwB,KAAK,GAAG,SAASA,KAAKA,CAACgD,IAAI,EAAEuO,GAAG,EAAE;EACtCpJ,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC;EAE5B,KAAKoJ,GAAG,CAAC,CAAC;EACV,MAAMP,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC,CAAC6P,IAAI,CAAC,CAAC,CAAC,CAAC;EACpE,OAAOyB,EAAE,CAAChR,KAAK,CAAC8K,KAAK,CAACkG,EAAE,EAAEvL,SAAS,CAAC;AACtC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAjH,KAAK,CAACmB,MAAM,GAAG,SAASA,MAAMA,CAAA,EAAG;EAC/BwI,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC;EAE7B,MAAM6I,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC,CAAC6P,IAAI,CAAC,CAAC,CAAC,CAAC;EACpE,OAAOyB,EAAE,CAACrR,MAAM,CAACmL,KAAK,CAACkG,EAAE,EAAEvL,SAAS,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAjH,KAAK,CAACgT,gBAAgB,GAAG,UAAST,UAAU,EAAE7N,MAAM,EAAEvE,OAAO,EAAE;EAC7DwJ,aAAa,CAAC,IAAI,EAAE,kBAAkB,CAAC;EACvC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACxJ,MAAM,IAAI1L,aAAa,CAAC,uDAAuD,CAAC;EAClF;EAEA,IAAI2E,MAAM;EACV,IAAIC,OAAO,EAAE;IACXD,MAAM,GAAGC,OAAO,CAACD,MAAM,IAAIC,OAAO,CAACoF,UAAU;EAC/C;EAEAb,MAAM,GAAG1H,KAAK,CAAC0H,MAAM,EAAE;IACrBuO,UAAU,EAAE,IAAI;IAChBC,SAAS,EAAE;EACb,CAAC,CAAC;EAEFhW,4BAA4B,CAACwH,MAAM,EAAEvE,OAAO,EAAE,IAAI,CAAC4J,MAAM,CAAC5J,OAAO,CAAC8F,UAAU,CAAC;EAE7E,MAAMuM,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC5I,MAAM,CAAC1J,MAAM,CAAC;EAEjB,OAAOsS,EAAE,CAACQ,gBAAgB,CAACT,UAAU,EAAE7N,MAAM,EAAEvE,OAAO,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAACmT,iBAAiB,GAAG,UAASR,EAAE,EAAEjO,MAAM,EAAEvE,OAAO,EAAE;EACtDwJ,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC;EACxC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACxJ,MAAM,IAAI1L,aAAa,CAAC,wDAAwD,CAAC;EACnF;;EAEA;EACA,IAAIoX,EAAE,YAAYzX,QAAQ,EAAE;IAC1ByX,EAAE,GAAGA,EAAE,CAAC/K,IAAI,CAAC1E,GAAG;EAClB;EAEA,OAAO,IAAI,CAAC8P,gBAAgB,CAAC3S,IAAI,CAAC,IAAI,EAAE;IAAE6C,GAAG,EAAEyP;EAAG,CAAC,EAAEjO,MAAM,EAAEvE,OAAO,CAAC;AACvE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAACoT,gBAAgB,GAAG,UAASb,UAAU,EAAEpS,OAAO,EAAE;EACrDwJ,aAAa,CAAC,IAAI,EAAE,kBAAkB,CAAC;EAEvC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,uDAAuD,CAAC;EAClF;EAEA,IAAI2E,MAAM;EACV,IAAIC,OAAO,EAAE;IACXD,MAAM,GAAGC,OAAO,CAACyJ,MAAM;IACvBzJ,OAAO,CAACyJ,MAAM,GAAG5D,SAAS;EAC5B;EAEA,MAAMwM,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC5I,MAAM,CAAC1J,MAAM,CAAC;EAEjB,OAAOsS,EAAE,CAACY,gBAAgB,CAACb,UAAU,EAAEpS,OAAO,CAAC;AACjD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAACqT,iBAAiB,GAAG,UAASV,EAAE,EAAExS,OAAO,EAAE;EAC9CwJ,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC;EAExC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IAClH,MAAM,IAAI1L,aAAa,CAAC,wDAAwD,CAAC;EACnF;EAEA,OAAO,IAAI,CAAC6X,gBAAgB,CAAC;IAAElQ,GAAG,EAAEyP;EAAG,CAAC,EAAExS,OAAO,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAACsT,iBAAiB,GAAG,UAAS/O,MAAM,EAAEgP,WAAW,EAAEpT,OAAO,EAAE;EAC/DwJ,aAAa,CAAC,IAAI,EAAE,mBAAmB,CAAC;EAExC,IAAI,OAAO1C,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,OAAOA,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACxJ,MAAM,IAAI1L,aAAa,CAAC,wDAAwD,CAAC;EACnF;EAEA,IAAI2E,MAAM;EACV,IAAIC,OAAO,EAAE;IACXD,MAAM,GAAGC,OAAO,CAACyJ,MAAM;IACvBzJ,OAAO,CAACyJ,MAAM,GAAG5D,SAAS;EAC5B;EAEA,MAAMwM,EAAE,GAAG,IAAI,IAAI,CAAC9W,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAACwF,aAAa,CAAC;EAC3DsR,EAAE,CAAC5I,MAAM,CAAC1J,MAAM,CAAC;EAEjB,OAAOsS,EAAE,CAACc,iBAAiB,CAAC/O,MAAM,EAAEgP,WAAW,EAAEpT,OAAO,CAAC;AAC3D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAAC4Q,MAAM,GAAG,eAAeA,MAAMA,CAAC3Q,GAAG,EAAEE,OAAO,EAAE;EACjD,IAAI,OAAOA,OAAO,KAAK,UAAU,IAC7B,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACtC,MAAM,IAAI1L,aAAa,CAAC,6CAA6C,CAAC;EACxE;EAEAoO,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC;EAE7B,IAAI6J,IAAI;EACR,MAAMC,gBAAgB,GAAG,IAAI,CAAC1J,MAAM,CAAC5J,OAAO,CAACsT,gBAAgB;EAE7D,IAAI7P,KAAK,CAACC,OAAO,CAAC5D,GAAG,CAAC,EAAE;IACtBuT,IAAI,GAAGvT,GAAG;IACVE,OAAO,GAAGA,OAAO,IAAI,IAAI,IAAI,OAAOA,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAG,CAAC,CAAC;EACzE,CAAC,MAAM;IACL,MAAMuT,IAAI,GAAGzM,SAAS,CAACA,SAAS,CAACpB,MAAM,GAAG,CAAC,CAAC;IAC5C1F,OAAO,GAAG,CAAC,CAAC;IACZ,MAAMwT,WAAW,GAAG,OAAOD,IAAI,KAAK,UAAU,IAC5C,OAAOvT,OAAO,KAAK,UAAU,IAC7B,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU;IACpC,IAAI0M,WAAW,EAAE;MACf,MAAM,IAAIpY,aAAa,CAAC,6CAA6C,CAAC;IACxE,CAAC,MAAM;MACLiY,IAAI,GAAG,CAAC,GAAGvM,SAAS,CAAC;MACrB;MACA;MACA;MACA;MACA,IAAIuM,IAAI,CAAC3N,MAAM,GAAG,CAAC,IAAI,CAAC6N,IAAI,EAAE;QAC5BF,IAAI,CAACI,GAAG,CAAC,CAAC;MACZ;IACF;IAEA,IAAIJ,IAAI,CAAC3N,MAAM,KAAK,CAAC,IACjB2N,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,IACfA,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,IACfA,IAAI,CAAC,CAAC,CAAC,CAACrR,OAAO,IAAI,IAAI,IACvBuR,IAAI,IACJlW,kBAAkB,CAACkW,IAAI,CAACvR,OAAO,CAAC,KAAK,eAAe,IACpD,CAAC,IAAI,CAAC4H,MAAM,CAACvF,IAAI,CAAC,SAAS,CAAC,EAAE;MAChC;MACA;MACA3F,KAAK,CAACoR,IAAI,CAAC,sDAAsD,GAC/D,mEAAmE,GACnE,2DAA2D,CAAC;IAChE;EACF;EAEA,IAAIuD,IAAI,CAAC3N,MAAM,KAAK,CAAC,EAAE;IACrB,OAAOjC,KAAK,CAACC,OAAO,CAAC5D,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;EACvC;EACA,IAAImI,GAAG,GAAG,EAAE;EACZ,MAAMyL,cAAc,GAAG,OAAO1T,OAAO,CAAC2T,eAAe,KAAK,SAAS,GAAG,CAAC3T,OAAO,CAAC2T,eAAe,GAAG,IAAI;EAErG,OAAO3T,OAAO,CAAC2T,eAAe,CAAC,CAAC;;EAEhC,IAAI3T,OAAO,CAACgC,OAAO,IAAI,CAAChC,OAAO,CAAC4T,OAAO,IAAIP,IAAI,CAAC3N,MAAM,GAAG,CAAC,EAAE;IAC1D,MAAM,IAAItK,aAAa,CAAC,4FAA4F,CAAC;EACvH;EAEA,IAAI4E,OAAO,CAAC4T,OAAO,EAAE;IACnB,KAAK,IAAI7I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsI,IAAI,CAAC3N,MAAM,EAAEqF,CAAC,EAAE,EAAE;MACpC,IAAI;QACF,MAAMjL,GAAG,GAAGuT,IAAI,CAACtI,CAAC,CAAC;QACnB,MAAMlL,KAAK,GAAG,IAAI,CAACwK,cAAc,IAAIvK,GAAG,CAACwT,gBAAgB,CAAC,IAAI,IAAI,GAChE,IAAI,CAACjJ,cAAc,CAACvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,IAAIhW,uBAAuB,CAAC,IAAI,CAAC+M,cAAc,EAAEvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,GACjH,IAAI;QACN,IAAIzT,KAAK,IAAI,IAAI,EAAE;UACjB,MAAM,IAAIzE,aAAa,CAAC,kBAAkB0E,GAAG,CAACwT,gBAAgB,CAAC,QAAQ,GACvE,oBAAoB,IAAI,CAAC3S,SAAS,GAAG,CAAC;QACxC;QACA,IAAIkT,MAAM,GAAG/T,GAAG;QAChB,IAAI,EAAE+T,MAAM,YAAYhU,KAAK,CAAC,EAAE;UAC9BgU,MAAM,GAAG,IAAIhU,KAAK,CAACgU,MAAM,CAAC;QAC5B;QAEA,MAAMA,MAAM,CAAC1M,KAAK,CAACnH,OAAO,CAAC;QAC3BiI,GAAG,CAAC6G,IAAI,CAAC+E,MAAM,CAAC;MAClB,CAAC,CAAC,OAAOtQ,GAAG,EAAE;QACZ,IAAI,CAACmQ,cAAc,EAAE;UACnBzL,GAAG,CAAC6G,IAAI,CAACvL,GAAG,CAAC;QACf,CAAC,MAAM;UACL,MAAMA,GAAG;QACX;MACF;IACF;IACA,OAAO0E,GAAG;EACZ,CAAC,MAAM,IAAI,CAACyL,cAAc,EAAE;IAC1BzL,GAAG,GAAG,MAAMG,OAAO,CAAC0L,UAAU,CAACT,IAAI,CAAC9K,GAAG,CAAC,MAAMzI,GAAG,IAAI;MACnD,MAAMD,KAAK,GAAG,IAAI,CAACwK,cAAc,IAAIvK,GAAG,CAACwT,gBAAgB,CAAC,IAAI,IAAI,GAChE,IAAI,CAACjJ,cAAc,CAACvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,IAAIhW,uBAAuB,CAAC,IAAI,CAAC+M,cAAc,EAAEvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,GACjH,IAAI;MACN,IAAIzT,KAAK,IAAI,IAAI,EAAE;QACjB,MAAM,IAAIzE,aAAa,CAAC,kBAAkB0E,GAAG,CAACwT,gBAAgB,CAAC,QAAQ,GACnE,oBAAoB,IAAI,CAAC3S,SAAS,GAAG,CAAC;MAC5C;MACA,IAAIkT,MAAM,GAAG/T,GAAG;MAEhB,IAAI,EAAE+T,MAAM,YAAYhU,KAAK,CAAC,EAAE;QAC9BgU,MAAM,GAAG,IAAIhU,KAAK,CAACgU,MAAM,CAAC;MAC5B;MAEA,MAAMA,MAAM,CAAC1M,KAAK,CAACnH,OAAO,CAAC;MAE3B,OAAO6T,MAAM;IACf,CAAC,CAAC,CAAC;IACH5L,GAAG,GAAGA,GAAG,CAACM,GAAG,CAAC5F,MAAM,IAAIA,MAAM,CAACoR,MAAM,KAAK,WAAW,GAAGpR,MAAM,CAAC6D,KAAK,GAAG7D,MAAM,CAACqR,MAAM,CAAC;EACvF,CAAC,MAAM;IACL,IAAIC,UAAU,GAAG,IAAI;IACrBhM,GAAG,GAAG,MAAMG,OAAO,CAACC,GAAG,CAACgL,IAAI,CAAC9K,GAAG,CAAC,MAAMzI,GAAG,IAAI;MAC5C,MAAMD,KAAK,GAAG,IAAI,CAACwK,cAAc,IAAIvK,GAAG,CAACwT,gBAAgB,CAAC,IAAI,IAAI,GAChE,IAAI,CAACjJ,cAAc,CAACvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,IAAIhW,uBAAuB,CAAC,IAAI,CAAC+M,cAAc,EAAEvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,GACjH,IAAI;MACN,IAAIzT,KAAK,IAAI,IAAI,EAAE;QACjB,MAAM,IAAIzE,aAAa,CAAC,kBAAkB0E,GAAG,CAACwT,gBAAgB,CAAC,QAAQ,GACnE,oBAAoB,IAAI,CAAC3S,SAAS,GAAG,CAAC;MAC5C;MACA,IAAI;QACF,IAAIkT,MAAM,GAAG/T,GAAG;QAEhB,IAAI,EAAE+T,MAAM,YAAYhU,KAAK,CAAC,EAAE;UAC9BgU,MAAM,GAAG,IAAIhU,KAAK,CAACgU,MAAM,CAAC;QAC5B;QAEA,MAAMA,MAAM,CAAC1M,KAAK,CAACnH,OAAO,CAAC;QAE3B,OAAO6T,MAAM;MACf,CAAC,CAAC,OAAOtQ,GAAG,EAAE;QACZ,IAAI,CAAC0Q,UAAU,EAAE;UACfA,UAAU,GAAG1Q,GAAG;QAClB;MACF;IACF,CAAC,CAAC,CAAC;IACH,IAAI0Q,UAAU,EAAE;MACd,MAAMA,UAAU;IAClB;EACF;EAGA,IAAI,CAACxQ,KAAK,CAACC,OAAO,CAAC5D,GAAG,CAAC,IAAIuT,IAAI,CAAC3N,MAAM,KAAK,CAAC,EAAE;IAC5C,OAAOuC,GAAG,CAAC,CAAC,CAAC;EACf;EAEA,OAAOA,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEApI,KAAK,CAACwD,SAAS,GAAG,eAAeA,SAASA,CAACvD,GAAG,EAAEE,OAAO,EAAE;EACvDwJ,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;EAEhC,MAAM8J,gBAAgB,GAAG,IAAI,CAAC1J,MAAM,CAAC5J,OAAO,CAACsT,gBAAgB;EAC7D,MAAMzT,KAAK,GAAG,IAAI,CAACwK,cAAc,IAAIvK,GAAG,CAACwT,gBAAgB,CAAC,IAAI,IAAI,GAChE,IAAI,CAACjJ,cAAc,CAACvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,IAAIhW,uBAAuB,CAAC,IAAI,CAAC+M,cAAc,EAAEvK,GAAG,CAACwT,gBAAgB,CAAC,CAAC,GACjH,IAAI;EACN,IAAIzT,KAAK,IAAI,IAAI,EAAE;IACjB,MAAM,IAAIzE,aAAa,CACrB,kBAAkB0E,GAAG,CAACwT,gBAAgB,CAAC,0BAA0B,IAAI,CAAC3S,SAAS,GACjF,CAAC;EACH;EACA,IAAI,EAAEb,GAAG,YAAYD,KAAK,CAAC,EAAE;IAC3BC,GAAG,GAAG,IAAID,KAAK,CAACC,GAAG,CAAC;EACtB;EAEA,OAAO,MAAMA,GAAG,CAACqH,KAAK,CAACnH,OAAO,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAACqU,KAAK,GAAG,UAASC,QAAQ,EAAEnU,OAAO,EAAE;EACxCwJ,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC;EAE5BxJ,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMoU,YAAY,GAAGpU,OAAO,EAAEqU,OAAO,KAAKxO,SAAS,GACjDnH,KAAK,CAAC4V,IAAI,CAACtU,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC,GAChC;IAAE,GAAGA;EAAQ,CAAC;EAChBA,OAAO,CAACsJ,KAAK,GAAG,IAAI;EAGpB,MAAMiL,iBAAiB,GAAGC,EAAE,IAAI;IAC9BL,QAAQ,GAAGA,QAAQ,IAAI,EAAE;IACzB/V,4BAA4B,CAAC+V,QAAQ,EAAE,IAAI,CAACvK,MAAM,EAAE,cAAc,CAAC;IACnE,IAAI,IAAI,CAAC7I,aAAa,CAACwO,MAAM,EAAE;MAC7B,IAAI,CAACxO,aAAa,CAAC0O,QAAQ,CAAC,MAAM;QAChC,IAAI,IAAI,CAACgF,MAAM,EAAE;UACf;QACF;QACA,MAAMC,kBAAkB,GAAG,IAAI,CAAC3T,aAAa,CAACmT,KAAK,CAACC,QAAQ,EAAEC,YAAY,CAAC;QAC3EI,EAAE,CAAC,IAAI,EAAEE,kBAAkB,CAAC;MAC9B,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,MAAMA,kBAAkB,GAAG,IAAI,CAAC3T,aAAa,CAACmT,KAAK,CAACC,QAAQ,EAAEC,YAAY,CAAC;MAC3EI,EAAE,CAAC,IAAI,EAAEE,kBAAkB,CAAC;IAC9B;EACF,CAAC;EAED,OAAO,IAAI5Z,YAAY,CAACyZ,iBAAiB,EAAEJ,QAAQ,EAAEnU,OAAO,CAAC;AAC/D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,KAAK,CAAC8U,YAAY,GAAG,YAAW;EAC9BnL,aAAa,CAAC,IAAI,EAAE,cAAc,CAAC;EAEnC,OAAO,IAAI,CAAClJ,EAAE,CAACqU,YAAY,CAACxI,KAAK,CAAC,IAAI,CAAC7L,EAAE,EAAEwG,SAAS,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAjH,KAAK,CAAC+U,UAAU,GAAG,eAAeA,UAAUA,CAACC,GAAG,EAAE7U,OAAO,EAAE;EACzDwJ,aAAa,CAAC,IAAI,EAAE,YAAY,CAAC;EACjC,IAAI,OAAOxJ,OAAO,KAAK,UAAU,IAC/B,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACpC,MAAM,IAAI1L,aAAa,CAAC,iDAAiD,CAAC;EAC5E;EAEA4E,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAM6H,SAAS,GAAGrJ,qBAAqB,CAACwB,OAAO,EAAE,KAAK,CAAC;EACvD,MAAM8H,UAAU,GAAGtJ,qBAAqB,CAACwB,OAAO,EAAE,MAAM,CAAC;EAEzD,IAAI;IACF,CAAC6U,GAAG,CAAC,GAAG,MAAM,IAAI,CAAC1T,WAAW,CAAC+G,OAAO,CAAC,YAAY,EAAE,IAAI,EAAE,CAAC2M,GAAG,CAAC,EAAE;MAAEzQ,MAAM,EAAEyD;IAAU,CAAC,CAAC;EAC1F,CAAC,CAAC,OAAOpF,KAAK,EAAE;IACd,MAAM,IAAI,CAACtB,WAAW,CAAC2H,QAAQ,CAAC,YAAY,EAAE,IAAI,EAAE,CAAC+L,GAAG,CAAC,EAAE;MAAEpS,KAAK;MAAE2B,MAAM,EAAE0D;IAAW,CAAC,CAAC;EAC3F;EACA,MAAMgN,SAAS,GAAG,IAAI;EACtB,MAAMC,KAAK,GAAG/U,OAAO,CAAC+U,KAAK,IAAI,IAAI;EACnC,MAAMC,SAAS,GAAG,CAAC,CAAChV,OAAO,CAACgV,SAAS;EACrC,MAAMpB,OAAO,GAAG,OAAO5T,OAAO,CAAC4T,OAAO,KAAK,SAAS,GAAG5T,OAAO,CAAC4T,OAAO,GAAG,IAAI;EAC7E,MAAMqB,sBAAsB,GAAG,OAAOjV,OAAO,CAACiV,sBAAsB,KAAK,SAAS,GAAGjV,OAAO,CAACiV,sBAAsB,GAAG,KAAK;EAC3H,MAAMvL,IAAI,GAAG,CAAC,CAAC1J,OAAO,CAAC0J,IAAI;EAE3B,MAAMxH,iBAAiB,GAAG,IAAI,CAAC5B,EAAE,CAAC6B,IAAI,CAACC,4BAA4B,EAAEC,QAAQ,CAAC,CAAC;EAC/E,IAAI,CAAC,CAACrC,OAAO,IAAI,CAACN,MAAM,CAAC4C,MAAM,CAACtC,OAAO,EAAE,SAAS,CAAC,KAAKkC,iBAAiB,EAAEF,OAAO,IAAI,IAAI,EAAE;IAC1FhC,OAAO,GAAG;MAAE,GAAGA,OAAO;MAAEgC,OAAO,EAAEE,iBAAiB,CAACF;IAAQ,CAAC;EAC9D;EAEA,IAAI,CAACyB,KAAK,CAACC,OAAO,CAACmR,GAAG,CAAC,EAAE;IACvBA,GAAG,GAAG,CAACA,GAAG,CAAC;EACb;EAEA,MAAMK,gBAAgB,GAAG,EAAE;EAC3B,MAAMC,+BAA+B,GAAG,IAAInD,GAAG,CAAC,CAAC;EACjD,MAAMf,OAAO,GAAG2C,OAAO,GAAG,IAAI,GAAG,IAAInQ,KAAK,CAACoR,GAAG,CAACnP,MAAM,CAAC;EACtD,eAAe0P,WAAWA,CAACtV,GAAG,EAAE8O,KAAK,EAAE;IACrC;IACA,IAAIlF,IAAI,EAAE;MACR,OAAO5J,GAAG;IACZ;IACA,IAAIuV,aAAa,GAAG,KAAK;IACzB,IAAI,EAAEvV,GAAG,YAAYgV,SAAS,CAAC,EAAE;MAC/B,IAAIhV,GAAG,IAAI,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QAC1C,MAAM,IAAIzE,oBAAoB,CAACyE,GAAG,EAAE,MAAM,GAAG8O,KAAK,EAAE,YAAY,CAAC;MACnE;MACA9O,GAAG,GAAG,IAAIgV,SAAS,CAAChV,GAAG,CAAC;MACxBuV,aAAa,GAAG,IAAI;IACtB;IAEA,IAAIrV,OAAO,CAACgC,OAAO,IAAI,IAAI,EAAE;MAC3BlC,GAAG,CAACmC,QAAQ,CAACjC,OAAO,CAACgC,OAAO,CAAC;IAC/B;IACA,OAAOlC,GAAG,CAACwV,SAAS,CAACD,aAAa,GAAG;MAAEE,0BAA0B,EAAE;IAAK,CAAC,GAAG,IAAI,CAAC,CAC9ElQ,IAAI,CAAC,MAAMvF,GAAG,CAAC,CACfwD,KAAK,CAACb,KAAK,IAAI;MACd,IAAImR,OAAO,KAAK,KAAK,EAAE;QACrBnR,KAAK,CAACmM,KAAK,GAAGA,KAAK;QACnBsG,gBAAgB,CAACpG,IAAI,CAACrM,KAAK,CAAC;QAC5B0S,+BAA+B,CAAClD,GAAG,CAACxP,KAAK,EAAEmM,KAAK,CAAC;QACjDqC,OAAO,CAACrC,KAAK,CAAC,GAAGnM,KAAK;QACtB;MACF;MACA,MAAMA,KAAK;IACb,CAAC,CAAC;EACN;EAEA,MAAM+S,IAAI,GAAG,MAAMrX,aAAa,CAAC0W,GAAG,EAAEO,WAAW,EAAEL,KAAK,CAAC;EAEzD,MAAMU,gBAAgB,GAAG,IAAIzD,GAAG,CAAC,CAAC;EAClC,MAAM0D,4BAA4B,GAAG,IAAI1D,GAAG,CAAC,CAAC;EAC9C,KAAK,IAAIjH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyK,IAAI,CAAC9P,MAAM,EAAE,EAAEqF,CAAC,EAAE;IACpC0K,gBAAgB,CAACxD,GAAG,CAACuD,IAAI,CAACzK,CAAC,CAAC,EAAEA,CAAC,CAAC;EAClC;;EAEA;EACA,MAAM4K,aAAa,GAAGH,IAAI,CAACpR,MAAM,CAAC,UAAStE,GAAG,EAAE;IAC9C,OAAOA,GAAG,IAAI,IAAI;EACpB,CAAC,CAAC;EACF,KAAK,IAAIiL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4K,aAAa,CAACjQ,MAAM,EAAE,EAAEqF,CAAC,EAAE;IAC7C2K,4BAA4B,CAACzD,GAAG,CAAClH,CAAC,EAAE0K,gBAAgB,CAACrY,GAAG,CAACuY,aAAa,CAAC5K,CAAC,CAAC,CAAC,CAAC;EAC7E;;EAEA;EACA;EACA;EACA;EACA,IAAImK,gBAAgB,CAACxP,MAAM,GAAG,CAAC,EAAE;IAC/BwP,gBAAgB,CAACU,IAAI,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;MACpC,OAAOX,+BAA+B,CAAC/X,GAAG,CAACyY,IAAI,CAAC,GAAGV,+BAA+B,CAAC/X,GAAG,CAAC0Y,IAAI,CAAC;IAC9F,CAAC,CAAC;EACJ;;EAEA;EACA,IAAIH,aAAa,CAACjQ,MAAM,KAAK,CAAC,EAAE;IAC9B,IAAIuP,sBAAsB,EAAE;MAC1B,MAAM,IAAI9Z,sBAAsB,CAC9B+Z,gBAAgB,EAChBjE,OAAO,EACP,IAAI,EACJ,YACF,CAAC;IACH;IACA,IAAI+D,SAAS,EAAE;MACb,MAAM/M,GAAG,GAAG;QACV8N,YAAY,EAAE,IAAI;QAClBC,aAAa,EAAE,CAAC;QAChBC,WAAW,EAAE,CAAC;MAChB,CAAC;MACDnX,uBAAuB,CAACmJ,GAAG,EAAEiN,gBAAgB,EAAEA,gBAAgB,CAAC;MAChE,OAAOjN,GAAG;IACZ;IACA,OAAO,EAAE;EACX;EACA,MAAMiO,UAAU,GAAGxM,IAAI,GAAGiM,aAAa,GAAGA,aAAa,CAACpN,GAAG,CAAC,UAASzI,GAAG,EAAE;IACxE,IAAIA,GAAG,CAAC4B,SAAS,CAAC1B,OAAO,CAAC8F,UAAU,EAAE;MACpChG,GAAG,CAACA,GAAG,CAAC4B,SAAS,CAAC1B,OAAO,CAAC8F,UAAU,CAAC,GAAG,CAAC;IAC3C;IACA,MAAMqQ,mBAAmB,GAAGnW,OAAO,EAAEiH,UAAU,KAAK,KAAK,IAAInH,GAAG,CAACsW,oBAAoB,KAAK,CAACtW,GAAG,CAACqD,GAAG,IAAIrD,GAAG,CAACqD,GAAG,CAAC8D,UAAU,KAAK,KAAK,CAAC;IACnI,IAAIkP,mBAAmB,EAAE;MACvBrW,GAAG,CAACsW,oBAAoB,CAACpW,OAAO,EAAEiH,UAAU,CAAC;IAC/C;IACA,IAAInH,GAAG,CAACuW,yBAAyB,CAAC,CAAC,EAAE;MACnC,OAAOvW,GAAG,CAACwW,kBAAkB,CAAC,CAAC;IACjC;IACA,OAAOxW,GAAG,CAACgD,QAAQ,CAACrF,uBAAuB,CAAC;EAC9C,CAAC,CAAC;EAEF,IAAIwK,GAAG;EACP,IAAI;IACFA,GAAG,GAAG,MAAM,IAAI,CAAClH,aAAa,CAAC6T,UAAU,CAACsB,UAAU,EAAElW,OAAO,CAAC;EAChE,CAAC,CAAC,OAAOyC,KAAK,EAAE;IACd;IACA;IACA,IAAIA,KAAK,CAAC8T,WAAW,IAAI,IAAI,IACzB9T,KAAK,CAACE,MAAM,EAAEA,MAAM,EAAE4T,WAAW,IAAI,IAAI,EAAE;MAC7C9T,KAAK,CAAC8T,WAAW,GAAG9T,KAAK,CAACE,MAAM,CAACA,MAAM,CAAC4T,WAAW;IACrD;;IAEA;IACA,MAAMC,cAAc,GAAG/T,KAAK,EAAE8T,WAAW;IACzC,MAAME,cAAc,GAAG,IAAI7S,GAAG,CAAC,CAACnB,KAAK,EAAE8T,WAAW,IAAI,EAAE,EAAEhO,GAAG,CAAChF,GAAG,IAAIA,GAAG,CAACqL,KAAK,CAAC,CAAC;IAEhF,IAAInM,KAAK,CAAC8T,WAAW,IAAI,IAAI,EAAE;MAC7B,KAAK,IAAIxL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtI,KAAK,CAAC8T,WAAW,CAAC7Q,MAAM,EAAE,EAAEqF,CAAC,EAAE;QACjD,MAAM2L,aAAa,GAAGhB,4BAA4B,CAACtY,GAAG,CAACqF,KAAK,CAAC8T,WAAW,CAACxL,CAAC,CAAC,CAAC6D,KAAK,CAAC;QAClFnM,KAAK,CAAC8T,WAAW,CAACxL,CAAC,CAAC,GAAG;UAAE,GAAGtI,KAAK,CAAC8T,WAAW,CAACxL,CAAC,CAAC;UAAE6D,KAAK,EAAE8H;QAAc,CAAC;QACxE,IAAI,CAAC9C,OAAO,EAAE;UACZ3C,OAAO,CAACyF,aAAa,CAAC,GAAGjU,KAAK,CAAC8T,WAAW,CAACxL,CAAC,CAAC;QAC/C;MACF;IACF;IAEA,IAAI,CAAC6I,OAAO,EAAE;MACZ,KAAK,IAAI7I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkG,OAAO,CAACvL,MAAM,EAAE,EAAEqF,CAAC,EAAE;QACvC,IAAIkG,OAAO,CAAClG,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;UACzBkG,OAAO,CAAClG,CAAC,CAAC,GAAGyK,IAAI,CAACzK,CAAC,CAAC;QACtB;MACF;MAEAtI,KAAK,CAACwO,OAAO,GAAGA,OAAO;IACzB;IAEA,IAAI0F,iBAAiB,GAAG,CAAC,CAAC;IAC1BlU,KAAK,CAACmU,YAAY,GAAGjB,aAAa,CAChCvR,MAAM,CAAC,CAACtE,GAAG,EAAEiL,CAAC,KAAK;MACjB,MAAM8L,SAAS,GAAG,CAACL,cAAc,IAAIC,cAAc,CAACK,GAAG,CAAC/L,CAAC,CAAC;MAE1D,IAAI6I,OAAO,EAAE;QACX,IAAI+C,iBAAiB,GAAG,CAAC,CAAC,EAAE;UAC1B,OAAO5L,CAAC,GAAG4L,iBAAiB;QAC9B;QAEA,IAAIE,SAAS,EAAE;UACbF,iBAAiB,GAAG5L,CAAC;QACvB;MACF;MAEA,OAAO,CAAC8L,SAAS;IACnB,CAAC,CAAC,CACFtO,GAAG,CAAC,SAASwO,sBAAsBA,CAACjX,GAAG,EAAE;MACvC,IAAI4J,IAAI,EAAE;QACR,OAAO5J,GAAG;MACZ;MACAA,GAAG,CAACmD,QAAQ,CAAC,CAAC;MACdC,SAAS,CAACpD,GAAG,EAAE,KAAK,CAAC;MACrB,OAAOA,GAAG;IACZ,CAAC,CAAC;IAEJ,IAAIkV,SAAS,IAAIpB,OAAO,KAAK,KAAK,EAAE;MAClC9U,uBAAuB,CAAC2D,KAAK,EAAEyS,gBAAgB,EAAEjE,OAAO,CAAC;IAC3D;IAEA,MAAM,IAAI,CAAC9P,WAAW,CAAC2H,QAAQ,CAAC,YAAY,EAAE,IAAI,EAAE,CAAC+L,GAAG,CAAC,EAAE;MAAEpS,KAAK;MAAE2B,MAAM,EAAE0D;IAAW,CAAC,CAAC;EAC3F;EAEA,IAAI,CAAC4B,IAAI,EAAE;IACT,KAAK,MAAMsN,SAAS,IAAIrB,aAAa,EAAE;MACrCqB,SAAS,CAAC/T,QAAQ,CAAC,CAAC;MACpBC,SAAS,CAAC8T,SAAS,EAAE,KAAK,CAAC;IAC7B;EACF;EAEA,IAAIpD,OAAO,KAAK,KAAK,IAAIqB,sBAAsB,IAAIC,gBAAgB,CAACxP,MAAM,GAAG,CAAC,EAAE;IAC9E,KAAK,IAAIqF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkG,OAAO,CAACvL,MAAM,EAAE,EAAEqF,CAAC,EAAE;MACvC,IAAIkG,OAAO,CAAClG,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;QACzBkG,OAAO,CAAClG,CAAC,CAAC,GAAGyK,IAAI,CAACzK,CAAC,CAAC;MACtB;IACF;IACA,MAAM,IAAI5P,sBAAsB,CAC9B+Z,gBAAgB,EAChBjE,OAAO,EACPhJ,GAAG,EACH,YACF,CAAC;EACH;EAEA,IAAI+M,SAAS,EAAE;IACb,IAAIpB,OAAO,KAAK,KAAK,EAAE;MACrB,KAAK,IAAI7I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkG,OAAO,CAACvL,MAAM,EAAE,EAAEqF,CAAC,EAAE;QACvC,IAAIkG,OAAO,CAAClG,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;UACzBkG,OAAO,CAAClG,CAAC,CAAC,GAAGyK,IAAI,CAACzK,CAAC,CAAC;QACtB;MACF;;MAEA;MACA;MACAjM,uBAAuB,CAACmJ,GAAG,EAAEiN,gBAAgB,EAAEjE,OAAO,CAAC;IACzD;IACA,OAAOhJ,GAAG;EACZ;EAEA,IAAIjI,OAAO,CAACiX,QAAQ,IAAI,IAAI,EAAE;IAC5B,OAAO,IAAI,CAACA,QAAQ,CAACtB,aAAa,EAAE3V,OAAO,CAACiX,QAAQ,CAAC,CAAC3T,KAAK,CAACC,GAAG,IAAI;MACjE,IAAIA,GAAG,IAAI,IAAI,EAAE;QACfA,GAAG,CAACqT,YAAY,GAAGjB,aAAa;MAClC;MACA,MAAMpS,GAAG;IACX,CAAC,CAAC;EACJ;EAEA,MAAM,CAACZ,MAAM,CAAC,GAAG,MAAM,IAAI,CAACxB,WAAW,CAAC2H,QAAQ,CAAC,YAAY,EAAE,IAAI,EAAE,CAAC6M,aAAa,CAAC,EAAE;IAAEvR,MAAM,EAAE0D;EAAW,CAAC,CAAC;EAC7G,OAAOnF,MAAM;AACf,CAAC;;AAED;AACA;AACA;;AAEA,SAASO,SAASA,CAACpD,GAAG,EAAE8S,GAAG,EAAE;EAC3B9S,GAAG,CAAC8C,MAAM,GAAGgQ,GAAG;EAChB9S,GAAG,CAACsG,KAAK,CAAC,OAAO,EAAEwM,GAAG,CAAC;EACvB9S,GAAG,CAACoF,WAAW,CAACmB,IAAI,CAAC,OAAO,EAAEuM,GAAG,CAAC;EAElC,MAAMsE,OAAO,GAAGpX,GAAG,CAACwI,cAAc,CAAC;IAAE6O,QAAQ,EAAE;EAAK,CAAC,CAAC;EACtD,KAAK,MAAM3O,MAAM,IAAI0O,OAAO,EAAE;IAC5B1O,MAAM,CAAC5F,MAAM,GAAGgQ,GAAG;IACnBpK,MAAM,CAACpC,KAAK,CAAC,OAAO,EAAEwM,GAAG,CAAC;EAC5B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/S,KAAK,CAACuX,SAAS,GAAG,eAAeA,SAASA,CAACC,GAAG,EAAErX,OAAO,EAAE;EACvDwJ,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;EAEhC,IAAI,OAAOxJ,OAAO,KAAK,UAAU,IAC7B,OAAO8G,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;IACtC,MAAM,IAAI1L,aAAa,CAAC,gDAAgD,CAAC;EAC3E;EACA4E,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAM6H,SAAS,GAAGrJ,qBAAqB,CAACwB,OAAO,EAAE,KAAK,CAAC;EACvD,MAAM8H,UAAU,GAAGtJ,qBAAqB,CAACwB,OAAO,EAAE,MAAM,CAAC;EAEzD,IAAI;IACF,CAACqX,GAAG,EAAErX,OAAO,CAAC,GAAG,MAAM,IAAI,CAACqM,KAAK,CAACnE,OAAO,CAAC,WAAW,EAAE,IAAI,EAAE,CAACmP,GAAG,EAAErX,OAAO,CAAC,EAAE;MAAEoE,MAAM,EAAEyD;IAAU,CAAC,CAAC;EACrG,CAAC,CAAC,OAAOtE,GAAG,EAAE;I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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}