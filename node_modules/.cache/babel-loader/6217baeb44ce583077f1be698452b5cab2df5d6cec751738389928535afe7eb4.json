{"ast":null,"code":"'use strict';\n\nconst get = require('./get');\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function (filter, schema, castedDoc, options) {\n  options = options || {};\n  const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert ?? schema.base.options.setDefaultsOnInsert;\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = Object.create(null);\n  const updatedValues = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      hasDollarUpdate = true;\n      break;\n    }\n  }\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].charAt(0) === '$') {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    // Also mark all parent prefixes so child-path lookups are O(1).\n    // e.g. 'extraProps.location' also marks 'extraProps'\n    const pieces = schema.paths[path] ?\n    // If the SchemaType already split for us, use that to avoid the extra overhead\n    schema.paths[path].splitPath() : path.split('.');\n    let cur = pieces[0];\n    for (let j = 1; j < pieces.length; ++j) {\n      updatedKeys[cur] = true;\n      cur += '.' + pieces[j];\n    }\n  }\n  if (options?.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n  schema.eachPath(function (path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (typeof def === 'undefined') {\n      return;\n    }\n    const pathPieces = schemaType.splitPath();\n    if (pathPieces.includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n    if (isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate)) {\n      return;\n    }\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n  return castedDoc;\n};\nfunction isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate) {\n  // Check if path is in filter (updatedKeys)\n  if (updatedKeys[path]) {\n    return true;\n  }\n\n  // Check if any parent path is in filter\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (updatedKeys[cur]) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if path is modified in the update\n  if (hasDollarUpdate) {\n    // Check each update operator\n    for (const key in castedDoc) {\n      if (key.charAt(0) === '$') {\n        if (pathExistsInUpdate(castedDoc[key], path, pathPieces)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // No dollar operators, check the castedDoc directly\n    if (pathExistsInUpdate(castedDoc, path, pathPieces)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction pathExistsInUpdate(update, targetPath, pathPieces) {\n  if (update == null || typeof update !== 'object') {\n    return false;\n  }\n\n  // Check exact match\n  if (Object.hasOwn(update, targetPath)) {\n    return true;\n  }\n\n  // Check if any parent path exists\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (Object.hasOwn(update, cur)) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if any child path exists (e.g., path is \"a\" and update has \"a.b\")\n  const prefix = targetPath + '.';\n  for (const key in update) {\n    if (key.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["get","require","module","exports","filter","schema","castedDoc","options","shouldSetDefaultsOnInsert","setDefaultsOnInsert","base","upsert","keys","Object","updatedKeys","create","updatedValues","numKeys","length","hasDollarUpdate","i","charAt","paths","numPaths","path","condition","conditionKeys","numConditionKeys","hasDollarKey","j","indexOf","pieces","splitPath","split","cur","overwrite","eachPath","schemaType","auto","def","getDefault","pathPieces","includes","isModified","$setOnInsert","key","pathExistsInUpdate","update","targetPath","hasOwn","prefix","startsWith"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"],"sourcesContent":["'use strict';\nconst get = require('./get');\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert ?? schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = Object.create(null);\n  const updatedValues = {};\n  const numKeys = keys.length;\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      hasDollarUpdate = true;\n      break;\n    }\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].charAt(0) === '$') {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    // Also mark all parent prefixes so child-path lookups are O(1).\n    // e.g. 'extraProps.location' also marks 'extraProps'\n    const pieces = schema.paths[path] ?\n      // If the SchemaType already split for us, use that to avoid the extra overhead\n      schema.paths[path].splitPath() :\n      path.split('.');\n    let cur = pieces[0];\n    for (let j = 1; j < pieces.length; ++j) {\n      updatedKeys[cur] = true;\n      cur += '.' + pieces[j];\n    }\n  }\n\n  if (options?.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (typeof def === 'undefined') {\n      return;\n    }\n    const pathPieces = schemaType.splitPath();\n    if (pathPieces.includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n    if (isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate)) {\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate) {\n  // Check if path is in filter (updatedKeys)\n  if (updatedKeys[path]) {\n    return true;\n  }\n\n  // Check if any parent path is in filter\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (updatedKeys[cur]) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if path is modified in the update\n  if (hasDollarUpdate) {\n    // Check each update operator\n    for (const key in castedDoc) {\n      if (key.charAt(0) === '$') {\n        if (pathExistsInUpdate(castedDoc[key], path, pathPieces)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // No dollar operators, check the castedDoc directly\n    if (pathExistsInUpdate(castedDoc, path, pathPieces)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction pathExistsInUpdate(update, targetPath, pathPieces) {\n  if (update == null || typeof update !== 'object') {\n    return false;\n  }\n\n  // Check exact match\n  if (Object.hasOwn(update, targetPath)) {\n    return true;\n  }\n\n  // Check if any parent path exists\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (Object.hasOwn(update, cur)) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if any child path exists (e.g., path is \"a\" and update has \"a.b\")\n  const prefix = targetPath + '.';\n  for (const key in update) {\n    if (key.startsWith(prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}