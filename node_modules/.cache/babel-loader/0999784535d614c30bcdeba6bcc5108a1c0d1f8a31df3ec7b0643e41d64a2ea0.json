{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\nconst numericPathSegmentPattern = '\\\\.\\\\d+(?=\\\\.|$)';\nconst hasNumericPathSegmentRE = new RegExp(numericPathSegmentPattern);\nconst numericPathSegmentRE = new RegExp(numericPathSegmentPattern, 'g');\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model?.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  let modelNamesSet;\n  const available = {};\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n  const parts = modelSchema.paths[options.path]?.splitPath() ?? options.path.split('.');\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path, parts);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate ?? doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n    const docSchema = doc?.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path, parts);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema?.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n    if (schema?.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        modelNamesSet = modelNamesSet || new Set();\n        for (const modelName of _modelNames) {\n          if (modelNamesSet.has(modelName) === false) {\n            modelNamesSet.add(modelName);\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n      if (!modelNames) {\n        continue;\n      }\n    }\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n    if (!modelNames) {\n      continue;\n    }\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    let match = get(options, 'match', null);\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n    if (isRefPath) {\n      const normalizedRefPathForDiscriminators = typeof normalizedRefPath === 'string' ? normalizedRefPath.replace(numericPathSegmentRE, '') : normalizedRefPath;\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPathForDiscriminators, ret);\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n  function _getModelNames(doc, schemaType, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n    const originalSchema = schemaType;\n    if (schemaType?.instance === 'Array') {\n      schemaType = schemaType.embeddedSchemaType;\n    }\n    if (schemaType?.$isSchemaMap) {\n      schemaType = schemaType.$__schemaType;\n    }\n    const ref = schemaType?.options?.ref;\n    refPath = schemaType?.options?.refPath;\n    if (schemaType != null && schemaType[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {\n      return {\n        modelNames: null\n      };\n    }\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const res = _getModelNamesFromFunctionRefPath(refPath, doc, schemaType, options.path, modelSchema, options._queryProjection);\n        modelNames = res.modelNames;\n        refPath = res.refPath;\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (!schemaType && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n        if (schemaForCurrentDoc?.embeddedSchemaType) {\n          schemaForCurrentDoc = schemaForCurrentDoc.embeddedSchemaType;\n        }\n      } else {\n        schemaForCurrentDoc = schemaType;\n      }\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null && typeof ref === 'function' && options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((refPath = get(schemaForCurrentDoc, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const res = _getModelNamesFromFunctionRefPath(refPath, doc, schemaForCurrentDoc, options.path, modelSchema, options._queryProjection);\n          modelNames = res.modelNames;\n          refPath = res.refPath;\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return {\n          modelNames: modelNames,\n          justOne: justOne,\n          isRefPath: isRefPath,\n          refPath: refPath\n        };\n      }\n    }\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n    return {\n      modelNames: modelNames,\n      justOne: justOne,\n      isRefPath: isRefPath,\n      refPath: refPath\n    };\n  }\n};\n\n/**\n * Resolve model names for function-style `refPath` and return the first\n * resolved refPath value so discriminator handling can inspect it later.\n *\n * @param {Function} refPath\n * @param {Document|Object} doc\n * @param {SchemaType} schema\n * @param {String} populatePath\n * @param {Schema} modelSchema\n * @param {Object} queryProjection\n * @returns {{modelNames: String[], refPath: String|null}}\n * @private\n */\nfunction _getModelNamesFromFunctionRefPath(refPath, doc, schemaType, populatePath, modelSchema, queryProjection) {\n  const modelNames = [];\n  let normalizedRefPath = null;\n  const schemaPath = schemaType?.path;\n  if (schemaPath != null && populatePath.length > schemaPath.length + 1 && populatePath.charAt(populatePath.length - schemaPath.length - 1) === '.' && populatePath.slice(populatePath.length - schemaPath.length) === schemaPath) {\n    const subdocPath = populatePath.slice(0, populatePath.length - schemaPath.length - 1);\n    const segments = subdocPath.indexOf('.') === -1 ? [subdocPath] : subdocPath.split('.');\n    let hasSubdoc = false;\n    walkSubdocs(doc, '', 0);\n    if (hasSubdoc) {\n      return {\n        modelNames,\n        refPath: normalizedRefPath\n      };\n    }\n    function walkSubdocs(currentSubdoc, indexedPathPrefix, segmentIndex) {\n      if (currentSubdoc == null) {\n        return;\n      }\n      if (segmentIndex >= segments.length) {\n        hasSubdoc = true;\n        const indexedPath = indexedPathPrefix + '.' + schemaPath;\n        const subdocRefPath = refPath.call(currentSubdoc, currentSubdoc, indexedPath);\n        normalizedRefPath = normalizedRefPath || subdocRefPath;\n        modelNames.push(..._getModelNamesFromRefPath(subdocRefPath, doc, populatePath, indexedPath, modelSchema, queryProjection));\n        return;\n      }\n      const segment = segments[segmentIndex];\n      const source = currentSubdoc?._doc ?? currentSubdoc;\n      if (segment === '$*') {\n        if (source instanceof Map) {\n          for (const [key, value] of source.entries()) {\n            if (value != null) {\n              const valuePath = indexedPathPrefix.length === 0 ? key : indexedPathPrefix + '.' + key;\n              walkSubdocs(value, valuePath, segmentIndex + 1);\n            }\n          }\n          return;\n        }\n        if (source != null && typeof source === 'object') {\n          for (const key of Object.keys(source)) {\n            const value = source[key];\n            if (value != null) {\n              const valuePath = indexedPathPrefix.length === 0 ? key : indexedPathPrefix + '.' + key;\n              walkSubdocs(value, valuePath, segmentIndex + 1);\n            }\n          }\n        }\n        return;\n      }\n      const child = source[segment];\n      const childPath = indexedPathPrefix.length === 0 ? segment : indexedPathPrefix + '.' + segment;\n      if (Array.isArray(child)) {\n        for (let i = 0; i < child.length; ++i) {\n          if (child[i] != null) {\n            walkSubdocs(child[i], childPath + '.' + i, segmentIndex + 1);\n          }\n        }\n      } else if (child != null) {\n        walkSubdocs(child, childPath, segmentIndex + 1);\n      }\n    }\n  }\n  const topLevelRefPath = refPath.call(doc, doc, populatePath);\n  normalizedRefPath = normalizedRefPath || topLevelRefPath;\n  modelNames.push(...modelNamesFromRefPath(topLevelRefPath, doc, populatePath, modelSchema, queryProjection));\n  return {\n    modelNames,\n    refPath: normalizedRefPath\n  };\n}\n\n/**\n * Resolve model names from a refPath, preferring the indexed populated path\n * for array subdocuments and falling back to the original populate path if\n * normalization fails.\n *\n * @param {String|Function} refPath\n * @param {Document|Object} doc\n * @param {String} populatePath\n * @param {String} indexedPath\n * @param {Schema} modelSchema\n * @param {Object} queryProjection\n * @returns {String[]}\n * @private\n */\nfunction _getModelNamesFromRefPath(refPath, doc, populatePath, indexedPath, modelSchema, queryProjection) {\n  const populatedPath = typeof refPath === 'string' && hasNumericPathSegmentRE.test(refPath) ? populatePath : indexedPath;\n  try {\n    return modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection);\n  } catch (error) {\n    if (populatedPath === indexedPath && typeof error?.message === 'string' && error.message.startsWith('Could not normalize ref path')) {\n      return modelNamesFromRefPath(refPath, doc, populatePath, modelSchema, queryProjection);\n    }\n    throw error;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n    if (virtual.options.skip != null && !Object.hasOwn(options, 'skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !Object.hasOwn(options, 'limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !Object.hasOwn(options, 'perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    // Use the correct target doc/sub-doc for dynamic ref on nested schema. See gh-12363\n    if (_virtualRes.nestedSchemaPath && typeof virtual.options.ref === 'function') {\n      const subdocs = utils.getValue(_virtualRes.nestedSchemaPath, doc);\n      modelNames = Array.isArray(subdocs) ? subdocs.flatMap(subdoc => virtual._getModelNamesForPopulate(subdoc)) : virtual._getModelNamesForPopulate(subdocs);\n    } else {\n      modelNames = virtual._getModelNamesForPopulate(doc);\n    }\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) || get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection ?? model.db;\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n  if (modelNames == null) {\n    return;\n  }\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n    let ids = ret;\n    const modelNamesForRefPath = data.modelNamesInOrder || modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n    const perDocumentLimit = options.perDocumentLimit == null ? get(options, 'options.perDocumentLimit', null) : options.perDocumentLimit;\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n  return conn.model(modelName);\n}\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind ? Array.isArray(ids) ? utils.array.flatten(ids) : [ids] : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ? model.schema.path(localField) : localFieldPathType.schema;\n  const localFieldGetters = localFieldPath?.getters || [];\n  localField = localFieldPath?.instance === 'Embedded' ? localField + '._id' : localField;\n  const _populateOptions = get(options, 'options', {});\n  const getters = 'getters' in _populateOptions ? _populateOptions.getters : get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val?.$__ != null) {\n    return val._doc._id;\n  }\n  if (val?._id != null && !schema?.$isSchemaMap) {\n    return val._id;\n  }\n  if (Array.isArray(val)) {\n    const rawVal = val.__array ?? val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i]?.$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n  // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema?.[schemaMixedSymbol] == null) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null && schematype.$isMongooseDocumentArray && schematype.Constructor.discriminators != null && utils.hasOwnKeys(schematype.Constructor.discriminators)) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.Constructor.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.Constructor.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator?.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","clone","get","getDiscriminatorByValue","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","modelNamesFromRefPath","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","StrictPopulate","numericPathSegmentPattern","hasNumericPathSegmentRE","RegExp","numericPathSegmentRE","module","exports","getModelsMapForPopulate","model","docs","options","doc","len","length","map","modelNameFromQuery","modelName","schema","refPath","modelNames","modelNamesSet","available","modelSchema","_localModel","nested","path","_virtualRes","virtual","_virtualPopulate","parts","paths","splitPath","split","allSchemaTypes","Array","isArray","filter","v","isStrictPopulateDisabled","strictPopulate","_fullPath","i","justOne","$__","populated","forceRepopulate","constructor","base","docSchema","$__schema","$isMongooseDocumentArray","ref","isUnderneathDocArray","$parentSchemaDocArray","isRefPath","normalizedRefPath","schemaOptions","modelNamesInOrder","instance","data","localField","foreignField","res","_getModelNames","unpopulatedValue","id","addModelNamesToMap","schemasArray","_schema","_modelNames","error","Set","has","add","push","from","endsWith","every","$isMongooseArray","isVirtual","ret","_getLocalFieldValues","String","getValue","_docs","slice","match","hasMatchFunction","call","throwOn$where","normalizedRefPathForDiscriminators","replace","embeddedDiscriminatorModelNames","_findRefPathForDiscriminators","err","schemaType","originalSchema","embeddedSchemaType","$isSchemaMap","$__schemaType","_getModelNamesFromFunctionRefPath","_queryProjection","schemaForCurrentDoc","discriminatorValue","modelForCurrentDoc","discriminatorKey","discriminatorModel","discriminators","_getModelFromConn","db","_getSchema","_arrayPath","subdocPath","vals","subdocsBeingPopulated","array","flatten","subdoc","handleRefFunction","populatePath","queryProjection","schemaPath","charAt","segments","indexOf","hasSubdoc","walkSubdocs","currentSubdoc","indexedPathPrefix","segmentIndex","indexedPath","subdocRefPath","_getModelNamesFromRefPath","segment","source","_doc","Map","key","value","entries","valuePath","Object","keys","child","childPath","topLevelRefPath","populatedPath","test","message","startsWith","virtualPrefix","nestedSchemaPath","field","count","skip","hasOwn","limit","perDocumentLimit","subdocs","flatMap","_getModelNamesForPopulate","baseMatch","assign","convertTo_id","connection","cloneArrays","flatModelNames","k","Model","ids","modelNamesForRefPath","matchIdsToRefPaths","currentOptions","merge","allIds","unpopulatedValues","conn","models","_parent","refPaths","refPathToFind","index","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","_populateOptions","hydratedDoc","hydrate","localFieldValue","localFieldHydratedValue","localFieldArrVal","localFieldArrIndex","applyGetters","val","_id","rawVal","__array","isMongooseArray","$schema","_castForPopulate","$parent","concat","values","pieces","cur","piece","schematype","Constructor","hasOwnKeys","remnant","substring","discriminatorName","discriminator","discriminatorSchema","_path","docValue","forEach","join"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\nconst numericPathSegmentPattern = '\\\\.\\\\d+(?=\\\\.|$)';\nconst hasNumericPathSegmentRE = new RegExp(numericPathSegmentPattern);\nconst numericPathSegmentRE = new RegExp(numericPathSegmentPattern, 'g');\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model?.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  let modelNamesSet;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  const parts = modelSchema.paths[options.path]?.splitPath() ?? options.path.split('.');\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path, parts);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate ?? doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n\n    const docSchema = doc?.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path, parts);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema?.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema?.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        modelNamesSet = modelNamesSet || new Set();\n        for (const modelName of _modelNames) {\n          if (modelNamesSet.has(modelName) === false) {\n            modelNamesSet.add(modelName);\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const normalizedRefPathForDiscriminators = typeof normalizedRefPath === 'string' ?\n        normalizedRefPath.replace(numericPathSegmentRE, '') :\n        normalizedRefPath;\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPathForDiscriminators, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schemaType, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schemaType;\n    if (schemaType?.instance === 'Array') {\n      schemaType = schemaType.embeddedSchemaType;\n    }\n    if (schemaType?.$isSchemaMap) {\n      schemaType = schemaType.$__schemaType;\n    }\n\n    const ref = schemaType?.options?.ref;\n    refPath = schemaType?.options?.refPath;\n    if (schemaType != null &&\n        schemaType[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const res = _getModelNamesFromFunctionRefPath(refPath, doc, schemaType, options.path, modelSchema, options._queryProjection);\n        modelNames = res.modelNames;\n        refPath = res.refPath;\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schemaType && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc?.embeddedSchemaType) {\n          schemaForCurrentDoc = schemaForCurrentDoc.embeddedSchemaType;\n        }\n      } else {\n        schemaForCurrentDoc = schemaType;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((refPath = get(schemaForCurrentDoc, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const res = _getModelNamesFromFunctionRefPath(refPath, doc, schemaForCurrentDoc, options.path, modelSchema, options._queryProjection);\n          modelNames = res.modelNames;\n          refPath = res.refPath;\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/**\n * Resolve model names for function-style `refPath` and return the first\n * resolved refPath value so discriminator handling can inspect it later.\n *\n * @param {Function} refPath\n * @param {Document|Object} doc\n * @param {SchemaType} schema\n * @param {String} populatePath\n * @param {Schema} modelSchema\n * @param {Object} queryProjection\n * @returns {{modelNames: String[], refPath: String|null}}\n * @private\n */\nfunction _getModelNamesFromFunctionRefPath(refPath, doc, schemaType, populatePath, modelSchema, queryProjection) {\n  const modelNames = [];\n  let normalizedRefPath = null;\n  const schemaPath = schemaType?.path;\n\n  if (schemaPath != null &&\n      populatePath.length > schemaPath.length + 1 &&\n      populatePath.charAt(populatePath.length - schemaPath.length - 1) === '.' &&\n      populatePath.slice(populatePath.length - schemaPath.length) === schemaPath\n  ) {\n    const subdocPath = populatePath.slice(0, populatePath.length - schemaPath.length - 1);\n    const segments = subdocPath.indexOf('.') === -1 ? [subdocPath] : subdocPath.split('.');\n    let hasSubdoc = false;\n\n    walkSubdocs(doc, '', 0);\n    if (hasSubdoc) {\n      return { modelNames, refPath: normalizedRefPath };\n    }\n\n    function walkSubdocs(currentSubdoc, indexedPathPrefix, segmentIndex) {\n      if (currentSubdoc == null) {\n        return;\n      }\n\n      if (segmentIndex >= segments.length) {\n        hasSubdoc = true;\n        const indexedPath = indexedPathPrefix + '.' + schemaPath;\n        const subdocRefPath = refPath.call(currentSubdoc, currentSubdoc, indexedPath);\n        normalizedRefPath = normalizedRefPath || subdocRefPath;\n        modelNames.push(..._getModelNamesFromRefPath(subdocRefPath, doc, populatePath, indexedPath, modelSchema, queryProjection));\n        return;\n      }\n\n      const segment = segments[segmentIndex];\n      const source = currentSubdoc?._doc ?? currentSubdoc;\n\n      if (segment === '$*') {\n        if (source instanceof Map) {\n          for (const [key, value] of source.entries()) {\n            if (value != null) {\n              const valuePath = indexedPathPrefix.length === 0 ?\n                key :\n                indexedPathPrefix + '.' + key;\n              walkSubdocs(value, valuePath, segmentIndex + 1);\n            }\n          }\n          return;\n        }\n\n        if (source != null && typeof source === 'object') {\n          for (const key of Object.keys(source)) {\n            const value = source[key];\n            if (value != null) {\n              const valuePath = indexedPathPrefix.length === 0 ?\n                key :\n                indexedPathPrefix + '.' + key;\n              walkSubdocs(value, valuePath, segmentIndex + 1);\n            }\n          }\n        }\n        return;\n      }\n\n      const child = source[segment];\n      const childPath = indexedPathPrefix.length === 0 ?\n        segment :\n        indexedPathPrefix + '.' + segment;\n\n      if (Array.isArray(child)) {\n        for (let i = 0; i < child.length; ++i) {\n          if (child[i] != null) {\n            walkSubdocs(child[i], childPath + '.' + i, segmentIndex + 1);\n          }\n        }\n      } else if (child != null) {\n        walkSubdocs(child, childPath, segmentIndex + 1);\n      }\n    }\n  }\n\n  const topLevelRefPath = refPath.call(doc, doc, populatePath);\n  normalizedRefPath = normalizedRefPath || topLevelRefPath;\n  modelNames.push(...modelNamesFromRefPath(topLevelRefPath, doc, populatePath, modelSchema, queryProjection));\n\n  return { modelNames, refPath: normalizedRefPath };\n}\n\n/**\n * Resolve model names from a refPath, preferring the indexed populated path\n * for array subdocuments and falling back to the original populate path if\n * normalization fails.\n *\n * @param {String|Function} refPath\n * @param {Document|Object} doc\n * @param {String} populatePath\n * @param {String} indexedPath\n * @param {Schema} modelSchema\n * @param {Object} queryProjection\n * @returns {String[]}\n * @private\n */\nfunction _getModelNamesFromRefPath(refPath, doc, populatePath, indexedPath, modelSchema, queryProjection) {\n  const populatedPath = typeof refPath === 'string' && hasNumericPathSegmentRE.test(refPath) ?\n    populatePath :\n    indexedPath;\n\n  try {\n    return modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection);\n  } catch (error) {\n    if (populatedPath === indexedPath &&\n        typeof error?.message === 'string' &&\n        error.message.startsWith('Could not normalize ref path')) {\n      return modelNamesFromRefPath(refPath, doc, populatePath, modelSchema, queryProjection);\n    }\n    throw error;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !Object.hasOwn(options, 'skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !Object.hasOwn(options, 'limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !Object.hasOwn(options, 'perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    // Use the correct target doc/sub-doc for dynamic ref on nested schema. See gh-12363\n    if (_virtualRes.nestedSchemaPath && typeof virtual.options.ref === 'function') {\n      const subdocs = utils.getValue(_virtualRes.nestedSchemaPath, doc);\n      modelNames = Array.isArray(subdocs)\n        ? subdocs.flatMap(subdoc => virtual._getModelNamesForPopulate(subdoc))\n        : virtual._getModelNamesForPopulate(subdocs);\n    } else {\n      modelNames = virtual._getModelNamesForPopulate(doc);\n    }\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection ?? model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n\n    const modelNamesForRefPath = data.modelNamesInOrder || modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind\n      ? Array.isArray(ids)\n        ? utils.array.flatten(ids)\n        : [ids]\n      : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath?.getters || [];\n\n  localField = localFieldPath?.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val?.$__ != null) {\n    return val._doc._id;\n  }\n  if (val?._id != null && !schema?.$isSchemaMap) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array ?? val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i]?.$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      schema?.[schemaMixedSymbol] == null) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseDocumentArray &&\n        schematype.Constructor.discriminators != null &&\n        utils.hasOwnKeys(schematype.Constructor.discriminators)) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.Constructor.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.Constructor.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator?.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}