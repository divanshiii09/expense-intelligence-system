{"ast":null,"code":"'use strict';\n\n/*!\n * ignore\n */\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @param {string[]} [parts] pass in pre-split `path` to avoid extra splitting\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path, parts) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n  const discriminatorKey = schema.discriminatorMapping?.key;\n  if (discriminatorKey && model != null) {\n    if (doc?.[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator?.schema || schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n      if (foundschema.embeddedSchemaType || foundschema.schema) {\n        // array of Mixed?\n        if (foundschema.embeddedSchemaType instanceof Mixed) {\n          return foundschema.embeddedSchemaType;\n        }\n        let schemas = null;\n        if (foundschema.schema?.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' + foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).reduce(function (cur, discriminator) {\n            const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n            if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n              cur.push(discriminators[discriminator]);\n            }\n            return cur;\n          }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(parts.slice(p + 1), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(parts.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length && foundschema.$isMongooseArray && foundschema.embeddedSchemaType.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.embeddedSchemaType;\n          }\n          const ret = search(parts.slice(p), type.schema, null, nestedPath.concat(parts.slice(0, p)));\n          if (ret != null) {\n            return ret;\n          }\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc?.$__ && topLevelDoc.$populated(fullPath, true) && p < parts.length) {\n        const model = topLevelDoc.$populated(fullPath, true).options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(parts.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n          return ret;\n        }\n      }\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model?.schema ?? null;\n        if (schema != null) {\n          const ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  parts = parts || path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};","map":{"version":3,"names":["Mixed","require","get","getDiscriminatorByValue","leanPopulateMap","mpath","populateModelSymbol","module","exports","getSchemaTypes","model","schema","doc","path","parts","pathschema","topLevelDoc","discriminatorKey","discriminatorMapping","key","discriminator","discriminators","Object","keys","reduce","arr","name","disc","concat","search","subdoc","nestedPath","p","length","foundschema","trypath","slice","join","embeddedSchemaType","schemas","discriminatorKeyPath","options","cur","tiedValue","value","indexOf","push","ret","$parentSchemaDocArray","$isSingleNested","_ret","$isMongooseArray","type","$isMongooseDocumentArray","discriminatorPaths","discriminatorName","_schema","$isSchemaMap","$__schemaType","fullPath","$__","$populated","_val","Array","isArray","split","i"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @param {string[]} [parts] pass in pre-split `path` to avoid extra splitting\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path, parts) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping?.key;\n  if (discriminatorKey && model != null) {\n    if (doc?.[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator?.schema || schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.embeddedSchemaType || foundschema.schema) {\n        // array of Mixed?\n        if (foundschema.embeddedSchemaType instanceof Mixed) {\n          return foundschema.embeddedSchemaType;\n        }\n\n        let schemas = null;\n        if (foundschema.schema?.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.embeddedSchemaType.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.embeddedSchemaType;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc?.$__ && topLevelDoc.$populated(fullPath, true) && p < parts.length) {\n        const model = topLevelDoc.$populated(fullPath, true).options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model?.schema ?? null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  parts = parts || path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}