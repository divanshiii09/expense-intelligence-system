{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar createError = require('http-errors');\nvar getBody = require('raw-body');\nvar iconv = require('iconv-lite');\nvar onFinished = require('on-finished');\nvar zlib = require('node:zlib');\nvar hasBody = require('type-is').hasBody;\nvar {\n  getCharset\n} = require('./utils');\n\n/**\n * Module exports.\n */\n\nmodule.exports = read;\n\n/**\n * Read a request into a buffer and parse.\n *\n * @param {Object} req\n * @param {Object} res\n * @param {Function} next\n * @param {Function} parse\n * @param {Function} debug\n * @param {Object} options\n * @private\n */\nfunction read(req, res, next, parse, debug, options) {\n  if (onFinished.isFinished(req)) {\n    debug('body already parsed');\n    next();\n    return;\n  }\n  if (!('body' in req)) {\n    req.body = undefined;\n  }\n\n  // skip requests without bodies\n  if (!hasBody(req)) {\n    debug('skip empty body');\n    next();\n    return;\n  }\n  debug('content-type %j', req.headers['content-type']);\n\n  // determine if request should be parsed\n  if (!options.shouldParse(req)) {\n    debug('skip parsing');\n    next();\n    return;\n  }\n  var encoding = null;\n  if (options?.skipCharset !== true) {\n    encoding = getCharset(req) || options.defaultCharset;\n\n    // validate charset\n    if (!!options?.isValidCharset && !options.isValidCharset(encoding)) {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n        charset: encoding,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n  }\n  var length;\n  var opts = options;\n  var stream;\n\n  // read options\n  var verify = opts.verify;\n  try {\n    // get the content stream\n    stream = contentstream(req, debug, opts.inflate);\n    length = stream.length;\n    stream.length = undefined;\n  } catch (err) {\n    return next(err);\n  }\n\n  // set raw-body options\n  opts.length = length;\n  opts.encoding = verify ? null : encoding;\n\n  // assert charset is supported\n  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {\n    return next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n      charset: encoding.toLowerCase(),\n      type: 'charset.unsupported'\n    }));\n  }\n\n  // read body\n  debug('read body');\n  getBody(stream, opts, function (error, body) {\n    if (error) {\n      var _error;\n      if (error.type === 'encoding.unsupported') {\n        // echo back charset\n        _error = createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n          charset: encoding.toLowerCase(),\n          type: 'charset.unsupported'\n        });\n      } else {\n        // set status code on error\n        _error = createError(400, error);\n      }\n\n      // unpipe from stream and destroy\n      if (stream !== req) {\n        req.unpipe();\n        stream.destroy();\n      }\n\n      // read off entire request\n      dump(req, function onfinished() {\n        next(createError(400, _error));\n      });\n      return;\n    }\n\n    // verify\n    if (verify) {\n      try {\n        debug('verify body');\n        verify(req, res, body, encoding);\n      } catch (err) {\n        next(createError(403, err, {\n          body: body,\n          type: err.type || 'entity.verify.failed'\n        }));\n        return;\n      }\n    }\n\n    // parse\n    var str = body;\n    try {\n      debug('parse body');\n      str = typeof body !== 'string' && encoding !== null ? iconv.decode(body, encoding) : body;\n      req.body = parse(str, encoding);\n    } catch (err) {\n      next(createError(400, err, {\n        body: str,\n        type: err.type || 'entity.parse.failed'\n      }));\n      return;\n    }\n    next();\n  });\n}\n\n/**\n * Get the content stream of the request.\n *\n * @param {Object} req\n * @param {Function} debug\n * @param {boolean} inflate\n * @returns {Object}\n * @private\n */\nfunction contentstream(req, debug, inflate) {\n  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();\n  var length = req.headers['content-length'];\n  debug('content-encoding \"%s\"', encoding);\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, 'content encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    });\n  }\n  if (encoding === 'identity') {\n    req.length = length;\n    return req;\n  }\n  var stream = createDecompressionStream(encoding, debug);\n  req.pipe(stream);\n  return stream;\n}\n\n/**\n * Create a decompression stream for the given encoding.\n * @param {string} encoding\n * @param {Function} debug\n * @returns {Object}\n * @private\n */\nfunction createDecompressionStream(encoding, debug) {\n  switch (encoding) {\n    case 'deflate':\n      debug('inflate body');\n      return zlib.createInflate();\n    case 'gzip':\n      debug('gunzip body');\n      return zlib.createGunzip();\n    case 'br':\n      debug('brotli decompress body');\n      return zlib.createBrotliDecompress();\n    default:\n      throw createError(415, 'unsupported content encoding \"' + encoding + '\"', {\n        encoding: encoding,\n        type: 'encoding.unsupported'\n      });\n  }\n}\n\n/**\n * Dump the contents of a request.\n *\n * @param {Object} req\n * @param {Function} callback\n * @private\n */\nfunction dump(req, callback) {\n  if (onFinished.isFinished(req)) {\n    callback(null);\n  } else {\n    onFinished(req, callback);\n    req.resume();\n  }\n}","map":{"version":3,"names":["createError","require","getBody","iconv","onFinished","zlib","hasBody","getCharset","module","exports","read","req","res","next","parse","debug","options","isFinished","body","undefined","headers","shouldParse","encoding","skipCharset","defaultCharset","isValidCharset","toUpperCase","charset","type","length","opts","stream","verify","contentstream","inflate","err","encodingExists","toLowerCase","error","_error","unpipe","destroy","dump","onfinished","str","decode","createDecompressionStream","pipe","createInflate","createGunzip","createBrotliDecompress","callback","resume"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/body-parser/lib/read.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar getBody = require('raw-body')\nvar iconv = require('iconv-lite')\nvar onFinished = require('on-finished')\nvar zlib = require('node:zlib')\nvar hasBody = require('type-is').hasBody\nvar { getCharset } = require('./utils')\n\n/**\n * Module exports.\n */\n\nmodule.exports = read\n\n/**\n * Read a request into a buffer and parse.\n *\n * @param {Object} req\n * @param {Object} res\n * @param {Function} next\n * @param {Function} parse\n * @param {Function} debug\n * @param {Object} options\n * @private\n */\nfunction read (req, res, next, parse, debug, options) {\n  if (onFinished.isFinished(req)) {\n    debug('body already parsed')\n    next()\n    return\n  }\n\n  if (!('body' in req)) {\n    req.body = undefined\n  }\n\n  // skip requests without bodies\n  if (!hasBody(req)) {\n    debug('skip empty body')\n    next()\n    return\n  }\n\n  debug('content-type %j', req.headers['content-type'])\n\n  // determine if request should be parsed\n  if (!options.shouldParse(req)) {\n    debug('skip parsing')\n    next()\n    return\n  }\n\n  var encoding = null\n  if (options?.skipCharset !== true) {\n    encoding = getCharset(req) || options.defaultCharset\n\n    // validate charset\n    if (!!options?.isValidCharset && !options.isValidCharset(encoding)) {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n        charset: encoding,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n  }\n\n  var length\n  var opts = options\n  var stream\n\n  // read options\n  var verify = opts.verify\n\n  try {\n    // get the content stream\n    stream = contentstream(req, debug, opts.inflate)\n    length = stream.length\n    stream.length = undefined\n  } catch (err) {\n    return next(err)\n  }\n\n  // set raw-body options\n  opts.length = length\n  opts.encoding = verify\n    ? null\n    : encoding\n\n  // assert charset is supported\n  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {\n    return next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n      charset: encoding.toLowerCase(),\n      type: 'charset.unsupported'\n    }))\n  }\n\n  // read body\n  debug('read body')\n  getBody(stream, opts, function (error, body) {\n    if (error) {\n      var _error\n\n      if (error.type === 'encoding.unsupported') {\n        // echo back charset\n        _error = createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n          charset: encoding.toLowerCase(),\n          type: 'charset.unsupported'\n        })\n      } else {\n        // set status code on error\n        _error = createError(400, error)\n      }\n\n      // unpipe from stream and destroy\n      if (stream !== req) {\n        req.unpipe()\n        stream.destroy()\n      }\n\n      // read off entire request\n      dump(req, function onfinished () {\n        next(createError(400, _error))\n      })\n      return\n    }\n\n    // verify\n    if (verify) {\n      try {\n        debug('verify body')\n        verify(req, res, body, encoding)\n      } catch (err) {\n        next(createError(403, err, {\n          body: body,\n          type: err.type || 'entity.verify.failed'\n        }))\n        return\n      }\n    }\n\n    // parse\n    var str = body\n    try {\n      debug('parse body')\n      str = typeof body !== 'string' && encoding !== null\n        ? iconv.decode(body, encoding)\n        : body\n      req.body = parse(str, encoding)\n    } catch (err) {\n      next(createError(400, err, {\n        body: str,\n        type: err.type || 'entity.parse.failed'\n      }))\n      return\n    }\n\n    next()\n  })\n}\n\n/**\n * Get the content stream of the request.\n *\n * @param {Object} req\n * @param {Function} debug\n * @param {boolean} inflate\n * @returns {Object}\n * @private\n */\nfunction contentstream (req, debug, inflate) {\n  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()\n  var length = req.headers['content-length']\n\n  debug('content-encoding \"%s\"', encoding)\n\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, 'content encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n\n  if (encoding === 'identity') {\n    req.length = length\n    return req\n  }\n\n  var stream = createDecompressionStream(encoding, debug)\n  req.pipe(stream)\n  return stream\n}\n\n/**\n * Create a decompression stream for the given encoding.\n * @param {string} encoding\n * @param {Function} debug\n * @returns {Object}\n * @private\n */\nfunction createDecompressionStream (encoding, debug) {\n  switch (encoding) {\n    case 'deflate':\n      debug('inflate body')\n      return zlib.createInflate()\n    case 'gzip':\n      debug('gunzip body')\n      return zlib.createGunzip()\n    case 'br':\n      debug('brotli decompress body')\n      return zlib.createBrotliDecompress()\n    default:\n      throw createError(415, 'unsupported content encoding \"' + encoding + '\"', {\n        encoding: encoding,\n        type: 'encoding.unsupported'\n      })\n  }\n}\n\n/**\n * Dump the contents of a request.\n *\n * @param {Object} req\n * @param {Function} callback\n * @private\n */\nfunction dump (req, callback) {\n  if (onFinished.isFinished(req)) {\n    callback(null)\n  } else {\n    onFinished(req, callback)\n    req.resume()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}