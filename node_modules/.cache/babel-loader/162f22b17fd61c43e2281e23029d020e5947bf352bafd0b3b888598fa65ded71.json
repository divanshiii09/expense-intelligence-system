{"ast":null,"code":"'use strict';\n\nconst Decimal = require('../types/decimal128');\nconst ObjectId = require('../types/objectid');\nconst specialProperties = require('./specialProperties');\nconst isMongooseObject = require('./isMongooseObject');\nconst getFunctionName = require('./getFunctionName');\nconst isBsonType = require('./isBsonType');\nconst isMongooseArray = require('../types/array/isMongooseArray').isMongooseArray;\nconst isObject = require('./isObject');\nconst isPOJO = require('./isPOJO');\nconst symbols = require('./symbols');\nconst trustedSymbol = require('./query/trusted').trustedSymbol;\nconst BSON = require('mongodb/lib/bson');\nconst UUID = BSON.UUID;\nconst Binary = BSON.Binary;\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions and primitives are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n  if (isBsonType(obj, 'Double')) {\n    return new BSON.Double(obj.value);\n  }\n  if (typeof obj === 'number' || typeof obj === 'string' || typeof obj === 'boolean' || typeof obj === 'bigint') {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n  if (isMongooseObject(obj)) {\n    if (options) {\n      if (options.flattenUUIDs) {\n        if (obj instanceof Binary && obj._subtype === Binary.SUBTYPE_UUID) {\n          return obj.toString();\n        }\n        if (obj?.isMongooseBuffer && obj._subtype === Binary.SUBTYPE_UUID) {\n          return obj.toUUID().toString();\n        }\n      }\n      if (options.retainDocuments && obj.$__ != null) {\n        const clonedDoc = obj.$clone();\n        if (obj.__index != null) {\n          clonedDoc.__index = obj.__index;\n        }\n        if (obj.__parentArray != null) {\n          clonedDoc.__parentArray = options.parentArray ?? obj.__parentArray;\n        }\n        clonedDoc.$__setParent(options.parentDoc ?? obj.$__parent);\n        return clonedDoc;\n      }\n      if (options.retainDocuments && obj.$isMongooseMap) {\n        const clonedParent = options.parentDoc ?? obj.$__parent;\n        const MongooseMap = obj.constructor;\n        const ret = new MongooseMap({}, obj.$__path, clonedParent, obj.$__schemaType);\n        for (const [key, value] of obj) {\n          ret.$__set(key, clone(value, {\n            ...options,\n            parentDoc: clonedParent\n          }));\n        }\n        return ret;\n      }\n    }\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n    let ret;\n    if (options?.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n    return ret;\n  }\n  const objConstructor = obj.constructor;\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options?.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options?.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n  if (obj instanceof UUID) {\n    if (options?.flattenUUIDs) {\n      return obj.toJSON();\n    }\n    return new UUID(obj.buffer);\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options?.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options?.minimize;\n  const omitUndefined = options?.omitUndefined;\n  const seen = options?._seen;\n  const ret = {};\n  let hasKeys;\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj && options?.copyTrustedSymbol !== false) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  for (let i = 0; i < len; ++i) {\n    const key = keys[i];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || typeof val !== 'undefined') {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n  let ret = null;\n  if (options?.retainDocuments) {\n    if (arr.isMongooseDocumentArray) {\n      ret = new (arr.$schemaType().schema.base.Types.DocumentArray)([], arr.$path(), arr.$parent(), arr.$schemaType());\n    } else if (arr.isMongooseArray) {\n      ret = new (arr.$parent().schema.base.Types.Array)([], arr.$path(), arr.$parent(), arr.$schemaType());\n    } else {\n      ret = new Array(len);\n    }\n  } else {\n    ret = new Array(len);\n  }\n  arr = isMongooseArray(arr) ? arr.__array : arr;\n  if (ret.isMongooseDocumentArray) {\n    // Create new options object to avoid mutating the shared options.\n    // Subdocs need parentArray to point to their own cloned array.\n    options = {\n      ...options,\n      parentArray: ret\n    };\n  }\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n  return ret;\n}\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}","map":{"version":3,"names":["Decimal","require","ObjectId","specialProperties","isMongooseObject","getFunctionName","isBsonType","isMongooseArray","isObject","isPOJO","symbols","trustedSymbol","BSON","UUID","Binary","clone","obj","options","isArrayChild","Double","value","Array","isArray","cloneArray","flattenUUIDs","_subtype","SUBTYPE_UUID","toString","isMongooseBuffer","toUUID","retainDocuments","$__","clonedDoc","$clone","__index","__parentArray","parentArray","$__setParent","parentDoc","$__parent","$isMongooseMap","clonedParent","MongooseMap","constructor","ret","$__path","$__schemaType","key","$__set","_doc","json","toJSON","toObject","objConstructor","cloneObject","cloneRegExp","flattenObjectIds","id","flattenDecimals","fromString","buffer","schemaTypeSymbol","bson","toBSON","valueOf","module","exports","minimize","omitUndefined","seen","_seen","hasKeys","has","get","set","copyTrustedSymbol","keys","Object","len","length","i","val","arr","isMongooseDocumentArray","$schemaType","schema","base","Types","DocumentArray","$path","$parent","__array","regexp","RegExp","source","flags","lastIndex"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/mongoose/lib/helpers/clone.js"],"sourcesContent":["'use strict';\n\nconst Decimal = require('../types/decimal128');\nconst ObjectId = require('../types/objectid');\nconst specialProperties = require('./specialProperties');\nconst isMongooseObject = require('./isMongooseObject');\nconst getFunctionName = require('./getFunctionName');\nconst isBsonType = require('./isBsonType');\nconst isMongooseArray = require('../types/array/isMongooseArray').isMongooseArray;\nconst isObject = require('./isObject');\nconst isPOJO = require('./isPOJO');\nconst symbols = require('./symbols');\nconst trustedSymbol = require('./query/trusted').trustedSymbol;\nconst BSON = require('mongodb/lib/bson');\nconst UUID = BSON.UUID;\n\nconst Binary = BSON.Binary;\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions and primitives are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (isBsonType(obj, 'Double')) {\n    return new BSON.Double(obj.value);\n  }\n  if (typeof obj === 'number' || typeof obj === 'string' || typeof obj === 'boolean' || typeof obj === 'bigint') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    if (options) {\n      if (options.flattenUUIDs) {\n        if (obj instanceof Binary && obj._subtype === Binary.SUBTYPE_UUID) {\n          return obj.toString();\n        }\n        if (obj?.isMongooseBuffer && obj._subtype === Binary.SUBTYPE_UUID) {\n          return obj.toUUID().toString();\n        }\n      }\n      if (options.retainDocuments && obj.$__ != null) {\n        const clonedDoc = obj.$clone();\n        if (obj.__index != null) {\n          clonedDoc.__index = obj.__index;\n        }\n        if (obj.__parentArray != null) {\n          clonedDoc.__parentArray = options.parentArray ?? obj.__parentArray;\n        }\n        clonedDoc.$__setParent(options.parentDoc ?? obj.$__parent);\n        return clonedDoc;\n      }\n      if (options.retainDocuments && obj.$isMongooseMap) {\n        const clonedParent = options.parentDoc ?? obj.$__parent;\n        const MongooseMap = obj.constructor;\n        const ret = new MongooseMap({}, obj.$__path, clonedParent, obj.$__schemaType);\n        for (const [key, value] of obj) {\n          ret.$__set(key, clone(value, { ...options, parentDoc: clonedParent }));\n        }\n        return ret;\n      }\n    }\n\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    let ret;\n    if (options?.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n\n    return ret;\n  }\n\n  const objConstructor = obj.constructor;\n\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options?.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options?.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  if (obj instanceof UUID) {\n    if (options?.flattenUUIDs) {\n      return obj.toJSON();\n    }\n    return new UUID(obj.buffer);\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options?.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options?.minimize;\n  const omitUndefined = options?.omitUndefined;\n  const seen = options?._seen;\n  const ret = {};\n  let hasKeys;\n\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj && options?.copyTrustedSymbol !== false) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    const key = keys[i];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n\n  let ret = null;\n  if (options?.retainDocuments) {\n    if (arr.isMongooseDocumentArray) {\n      ret = new (arr.$schemaType().schema.base.Types.DocumentArray)([], arr.$path(), arr.$parent(), arr.$schemaType());\n    } else if (arr.isMongooseArray) {\n      ret = new (arr.$parent().schema.base.Types.Array)([], arr.$path(), arr.$parent(), arr.$schemaType());\n    } else {\n      ret = new Array(len);\n    }\n  } else {\n    ret = new Array(len);\n  }\n\n  arr = isMongooseArray(arr) ? arr.__array : arr;\n  if (ret.isMongooseDocumentArray) {\n    // Create new options object to avoid mutating the shared options.\n    // Subdocs need parentArray to point to their own cloned array.\n    options = { ...options, parentArray: ret };\n  }\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n\n  return ret;\n}\n\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}