{"ast":null,"code":"'use strict';\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n  this.args = [...arguments];\n};\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n  this.args = [...arguments];\n};\nKareem.overwriteArguments = function overwriteArguments() {\n  if (!(this instanceof Kareem.overwriteArguments)) {\n    return new Kareem.overwriteArguments(...arguments);\n  }\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args arguments passed to the pre hooks\n * @param {Object} [options] Optional options\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPre = async function execPre(name, context, args, options) {\n  let pres = this._pres.get(name) || [];\n  if (options?.filter) {\n    pres = pres.filter(options.filter);\n  }\n  const numPres = pres.length;\n  let $args = args;\n  let skipWrappedFunction = null;\n  if (!numPres) {\n    return $args;\n  }\n  for (const pre of pres) {\n    const args = [];\n    const _args = [null].concat($args);\n    for (let i = 1; i < _args.length; ++i) {\n      if (i === _args.length - 1 && typeof _args[i] === 'function') {\n        continue; // skip callbacks to avoid accidentally calling the callback from a hook\n      }\n      args.push(_args[i]);\n    }\n    try {\n      const maybePromiseLike = pre.fn.apply(context, args);\n      if (isPromiseLike(maybePromiseLike)) {\n        const result = await maybePromiseLike;\n        if (result instanceof Kareem.overwriteArguments) {\n          $args = result.args;\n        }\n      } else if (maybePromiseLike instanceof Kareem.overwriteArguments) {\n        $args = maybePromiseLike.args;\n      }\n    } catch (error) {\n      if (error instanceof Kareem.skipWrappedFunction) {\n        skipWrappedFunction = error;\n        continue;\n      }\n      if (error instanceof Kareem.overwriteArguments) {\n        $args = error.args;\n        continue;\n      }\n      throw error;\n    }\n  }\n  if (skipWrappedFunction) {\n    throw skipWrappedFunction;\n  }\n  return $args;\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @param {Object} [options] Optional options\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPreSync = function (name, context, args, options) {\n  let pres = this._pres.get(name) || [];\n  if (options?.filter) {\n    pres = pres.filter(options.filter);\n  }\n  const numPres = pres.length;\n  let $args = args || [];\n  for (let i = 0; i < numPres; ++i) {\n    const result = pres[i].fn.apply(context, $args);\n    if (result instanceof Kareem.overwriteArguments) {\n      $args = result.args;\n    }\n  }\n  return $args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options] Optional options\n * @param {Error} [options.error] Error to pass to error-handling middleware\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {void}\n */\nKareem.prototype.execPost = async function execPost(name, context, args, options) {\n  let posts = this._posts.get(name) || [];\n  if (options?.filter) {\n    posts = posts.filter(options.filter);\n  }\n  const numPosts = posts.length;\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n  if (!numPosts) {\n    if (firstError != null) {\n      throw firstError;\n    }\n    return args;\n  }\n  for (const currentPost of posts) {\n    const post = currentPost.fn;\n    let numArgs = 0;\n    const newArgs = [];\n    const argLength = args.length;\n    for (let i = 0; i < argLength; ++i) {\n      if (!args[i] || !args[i]._kareemIgnore) {\n        numArgs += 1;\n        newArgs.push(args[i]);\n      }\n    }\n    // If numCallbackParams set, fill in the rest with null to enforce consistent number of args\n    if (options?.numCallbackParams != null) {\n      numArgs = options.numCallbackParams;\n      for (let i = newArgs.length; i < numArgs; ++i) {\n        newArgs.push(null);\n      }\n    }\n    let resolve;\n    let reject;\n    const cbPromise = new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n    newArgs.push(function nextCallback(err) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n    if (firstError) {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        try {\n          const res = post.apply(context, [firstError].concat(newArgs));\n          if (isPromiseLike(res)) {\n            await res;\n          } else if (post.length === numArgs + 2) {\n            // `numArgs + 2` because we added the error and the callback\n            await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n        }\n      } else {\n        continue;\n      }\n    } else {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        // Skip error handlers if no error\n        continue;\n      } else {\n        let res = null;\n        try {\n          res = post.apply(context, newArgs);\n          if (isPromiseLike(res)) {\n            res = await res;\n          } else if (post.length === numArgs + 1) {\n            // If post function takes a callback, wait for the post function to call the callback\n            res = await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n          continue;\n        }\n        if (res instanceof Kareem.overwriteResult) {\n          args = res.args;\n          continue;\n        }\n      }\n    }\n  }\n  if (firstError != null) {\n    throw firstError;\n  }\n  return args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options] Optional options\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function (name, context, args, options) {\n  let posts = this._posts.get(name) || [];\n  if (options?.filter) {\n    posts = posts.filter(options.filter);\n  }\n  const numPosts = posts.length;\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook. If null/undefined, uses the calling context.\n * @param {Object} [options] Options for the wrapper\n * @param {Function} [options.getOptions] Function that receives the wrapper arguments and returns options for execPreSync/execPostSync. Can return `{ filter }` for both, or `{ pre: { filter }, post: { filter } }` for separate options.\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function (name, fn, context, options) {\n  const _this = this;\n  const getOptions = options?.getOptions;\n  return function syncWrapper() {\n    const _context = context || this;\n    const args = Array.from(arguments);\n    const execOptions = typeof getOptions === 'function' ? getOptions(args) : {};\n    const preOptions = execOptions.pre ?? execOptions;\n    const postOptions = execOptions.post ?? execOptions;\n    const modifiedArgs = _this.execPreSync(name, _context, args, preOptions);\n    const toReturn = fn.apply(_context, modifiedArgs);\n    const result = _this.execPostSync(name, _context, [toReturn], postOptions);\n    return result[0];\n  };\n};\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} options Additional options for the hook\n * @returns {void}\n */\nKareem.prototype.wrap = async function wrap(name, fn, context, args, options) {\n  let ret;\n  let skipWrappedFunction = false;\n  let modifiedArgs = args;\n  try {\n    modifiedArgs = await this.execPre(name, context, args);\n  } catch (error) {\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args;\n      skipWrappedFunction = true;\n    } else {\n      await this.execPost(name, context, args, {\n        ...options,\n        error\n      });\n    }\n  }\n  if (!skipWrappedFunction) {\n    ret = await fn.apply(context, modifiedArgs);\n  }\n  ret = await this.execPost(name, context, [ret], options);\n  return ret[0];\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function (fn) {\n  const clone = this.clone();\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).map(h => Object.assign({}, h, {\n      name: name\n    })).filter(fn);\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n    clone._pres.set(name, hooks);\n  }\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).map(h => Object.assign({}, h, {\n      name: name\n    })).filter(fn);\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n    clone._posts.set(name, hooks);\n  }\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function (name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function (name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the function\n    return fn;\n  }\n  return function kareemWrappedFunction() {\n    const _context = context || this;\n    return _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function (name, options, fn, error, unshift) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  } else if (options == null) {\n    options = {};\n  }\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, {\n      fn: fn\n    }));\n  } else {\n    pres.push(Object.assign({}, options, {\n      fn: fn\n    }));\n  }\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Boolean} [options.errorHandler] Whether this is an error handler\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function (name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, {\n      fn: fn\n    }));\n  } else {\n    posts.push(Object.assign({}, options, {\n      fn: fn\n    }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Register a new error handler for \"name\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\n\nKareem.prototype.postError = function postError(name, options, fn, unshift) {\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  return this.post(name, {\n    ...options,\n    errorHandler: true\n  }, fn, unshift);\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function () {\n  const n = new Kareem();\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function (other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n    // Deduplicate based on `fn`\n    filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n  return ret;\n};\nfunction isPromiseLike(v) {\n  return typeof v === 'object' && v !== null && typeof v.then === 'function';\n}\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\nmodule.exports = Kareem;","map":{"version":3,"names":["Kareem","_pres","Map","_posts","skipWrappedFunction","arguments","args","overwriteResult","overwriteArguments","prototype","execPre","name","context","options","pres","get","filter","numPres","length","$args","pre","_args","concat","i","push","maybePromiseLike","fn","apply","isPromiseLike","result","error","execPreSync","execPost","posts","numPosts","firstError","currentPost","post","numArgs","newArgs","argLength","_kareemIgnore","numCallbackParams","resolve","reject","cbPromise","Promise","_resolve","_reject","nextCallback","err","isErrorHandlingMiddleware","res","execPostSync","createWrapperSync","_this","getOptions","syncWrapper","_context","Array","from","execOptions","preOptions","postOptions","modifiedArgs","toReturn","wrap","ret","clone","keys","hooks","map","h","Object","assign","delete","set","hasHooks","has","createWrapper","kareemWrappedFunction","unshift","Error","postError","errorHandler","n","key","slice","merge","other","sourcePres","deduplicated","p","_p","indexOf","combined","sourcePosts","v","then","module","exports"],"sources":["C:/Users/bhavn/OneDrive/Desktop/FINSIGHT/node_modules/kareem/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\n\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteArguments = function overwriteArguments() {\n  if (!(this instanceof Kareem.overwriteArguments)) {\n    return new Kareem.overwriteArguments(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args arguments passed to the pre hooks\n * @param {Object} [options] Optional options\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPre = async function execPre(name, context, args, options) {\n  let pres = this._pres.get(name) || [];\n  if (options?.filter) {\n    pres = pres.filter(options.filter);\n  }\n  const numPres = pres.length;\n  let $args = args;\n  let skipWrappedFunction = null;\n\n  if (!numPres) {\n    return $args;\n  }\n\n  for (const pre of pres) {\n    const args = [];\n    const _args = [null].concat($args);\n    for (let i = 1; i < _args.length; ++i) {\n      if (i === _args.length - 1 && typeof _args[i] === 'function') {\n        continue; // skip callbacks to avoid accidentally calling the callback from a hook\n      }\n      args.push(_args[i]);\n    }\n\n    try {\n      const maybePromiseLike = pre.fn.apply(context, args);\n      if (isPromiseLike(maybePromiseLike)) {\n        const result = await maybePromiseLike;\n        if (result instanceof Kareem.overwriteArguments) {\n          $args = result.args;\n        }\n      } else if (maybePromiseLike instanceof Kareem.overwriteArguments) {\n        $args = maybePromiseLike.args;\n      }\n    } catch (error) {\n      if (error instanceof Kareem.skipWrappedFunction) {\n        skipWrappedFunction = error;\n        continue;\n      }\n      if (error instanceof Kareem.overwriteArguments) {\n        $args = error.args;\n        continue;\n      }\n      throw error;\n    }\n  }\n\n  if (skipWrappedFunction) {\n    throw skipWrappedFunction;\n  }\n\n  return $args;\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @param {Object} [options] Optional options\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPreSync = function(name, context, args, options) {\n  let pres = this._pres.get(name) || [];\n  if (options?.filter) {\n    pres = pres.filter(options.filter);\n  }\n  const numPres = pres.length;\n  let $args = args || [];\n\n  for (let i = 0; i < numPres; ++i) {\n    const result = pres[i].fn.apply(context, $args);\n    if (result instanceof Kareem.overwriteArguments) {\n      $args = result.args;\n    }\n  }\n\n  return $args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options] Optional options\n * @param {Error} [options.error] Error to pass to error-handling middleware\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {void}\n */\nKareem.prototype.execPost = async function execPost(name, context, args, options) {\n  let posts = this._posts.get(name) || [];\n  if (options?.filter) {\n    posts = posts.filter(options.filter);\n  }\n  const numPosts = posts.length;\n\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n\n  if (!numPosts) {\n    if (firstError != null) {\n      throw firstError;\n    }\n    return args;\n  }\n\n  for (const currentPost of posts) {\n    const post = currentPost.fn;\n    let numArgs = 0;\n    const newArgs = [];\n    const argLength = args.length;\n    for (let i = 0; i < argLength; ++i) {\n      if (!args[i] || !args[i]._kareemIgnore) {\n        numArgs += 1;\n        newArgs.push(args[i]);\n      }\n    }\n    // If numCallbackParams set, fill in the rest with null to enforce consistent number of args\n    if (options?.numCallbackParams != null) {\n      numArgs = options.numCallbackParams;\n      for (let i = newArgs.length; i < numArgs; ++i) {\n        newArgs.push(null);\n      }\n    }\n\n    let resolve;\n    let reject;\n    const cbPromise = new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n    newArgs.push(function nextCallback(err) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n\n    if (firstError) {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        try {\n          const res = post.apply(context, [firstError].concat(newArgs));\n          if (isPromiseLike(res)) {\n            await res;\n          } else if (post.length === numArgs + 2) {\n            // `numArgs + 2` because we added the error and the callback\n            await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n        }\n      } else {\n        continue;\n      }\n    } else {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        // Skip error handlers if no error\n        continue;\n      } else {\n        let res = null;\n        try {\n          res = post.apply(context, newArgs);\n          if (isPromiseLike(res)) {\n            res = await res;\n          } else if (post.length === numArgs + 1) {\n            // If post function takes a callback, wait for the post function to call the callback\n            res = await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n          continue;\n        }\n\n        if (res instanceof Kareem.overwriteResult) {\n          args = res.args;\n          continue;\n        }\n      }\n    }\n  }\n\n  if (firstError != null) {\n    throw firstError;\n  }\n\n  return args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options] Optional options\n * @param {Function} [options.filter] Filter function to select which hooks to run\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function(name, context, args, options) {\n  let posts = this._posts.get(name) || [];\n  if (options?.filter) {\n    posts = posts.filter(options.filter);\n  }\n  const numPosts = posts.length;\n\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook. If null/undefined, uses the calling context.\n * @param {Object} [options] Options for the wrapper\n * @param {Function} [options.getOptions] Function that receives the wrapper arguments and returns options for execPreSync/execPostSync. Can return `{ filter }` for both, or `{ pre: { filter }, post: { filter } }` for separate options.\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function(name, fn, context, options) {\n  const _this = this;\n  const getOptions = options?.getOptions;\n  return function syncWrapper() {\n    const _context = context || this;\n    const args = Array.from(arguments);\n    const execOptions = typeof getOptions === 'function' ? getOptions(args) : {};\n    const preOptions = execOptions.pre ?? execOptions;\n    const postOptions = execOptions.post ?? execOptions;\n\n    const modifiedArgs = _this.execPreSync(name, _context, args, preOptions);\n\n    const toReturn = fn.apply(_context, modifiedArgs);\n\n    const result = _this.execPostSync(name, _context, [toReturn], postOptions);\n\n    return result[0];\n  };\n};\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} options Additional options for the hook\n * @returns {void}\n */\nKareem.prototype.wrap = async function wrap(name, fn, context, args, options) {\n  let ret;\n  let skipWrappedFunction = false;\n  let modifiedArgs = args;\n  try {\n    modifiedArgs = await this.execPre(name, context, args);\n  } catch (error) {\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args;\n      skipWrappedFunction = true;\n    } else {\n      await this.execPost(name, context, args, { ...options, error });\n    }\n  }\n\n  if (!skipWrappedFunction) {\n    ret = await fn.apply(context, modifiedArgs);\n  }\n\n  ret = await this.execPost(name, context, [ret], options);\n\n  return ret[0];\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function(fn) {\n  const clone = this.clone();\n\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n\n    clone._pres.set(name, hooks);\n  }\n\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n\n    clone._posts.set(name, hooks);\n  }\n\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function(name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function(name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the function\n    return fn;\n  }\n  return function kareemWrappedFunction() {\n    const _context = context || this;\n    return _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function(name, options, fn, error, unshift) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  } else if (options == null) {\n    options = {};\n  }\n\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    pres.push(Object.assign({}, options, { fn: fn }));\n  }\n\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Boolean} [options.errorHandler] Whether this is an error handler\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function(name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    posts.push(Object.assign({}, options, { fn: fn }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Register a new error handler for \"name\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\n\nKareem.prototype.postError = function postError(name, options, fn, unshift) {\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  return this.post(name, { ...options, errorHandler: true }, fn, unshift);\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function() {\n  const n = new Kareem();\n\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function(other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n      // Deduplicate based on `fn`\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).\n      filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n\n  return ret;\n};\n\nfunction isPromiseLike(v) {\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\n}\n\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\n\nmodule.exports = Kareem;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}